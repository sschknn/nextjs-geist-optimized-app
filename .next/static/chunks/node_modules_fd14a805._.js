(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}}),
"[project]/node_modules/seedrandom/lib/alea.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -
// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
(function(global, module1, define1) {
    function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
            var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
        };
        // Apply the seeding algorithm from Baagoe.
        me.c = 1;
        me.s0 = mash(' ');
        me.s1 = mash(' ');
        me.s2 = mash(' ');
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
            me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
            me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
            me.s2 += 1;
        }
        mash = null;
    }
    function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
    }
    function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
            return xg.next() * 0x100000000 | 0;
        };
        prng.double = function() {
            return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
        };
        prng.quick = prng;
        if (state) {
            if (typeof state == 'object') copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    function Mash() {
        var n = 0xefc8249d;
        var mash = function(data) {
            data = data.toString();
            for(var i = 0; i < data.length; i++){
                n += data.charCodeAt(i);
                var h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 0x100000000; // 2^32
            }
            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
        return mash;
    }
    if (module1 && module1.exports) {
        module1.exports = impl;
    } else if (define1 && define1.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return impl;
        }(__turbopack_context__.r, exports, module));
    } else {
        this.alea = impl;
    }
})(this, ("TURBOPACK compile-time value", "object") == 'object' && module, typeof define == 'function' && define // present with an AMD loader
);
}}),
"[project]/node_modules/seedrandom/lib/xor128.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this, strseed = '';
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        // Set up generator function.
        me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
            // Integer seed.
            me.x = seed;
        } else {
            // String seed.
            strseed += seed;
        }
        // Mix in string seed, then discard an initial batch of 64 values.
        for(var k = 0; k < strseed.length + 64; k++){
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
        }
    }
    function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
    }
    function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do {
                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);
            }while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (typeof state == 'object') copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) {
        module1.exports = impl;
    } else if (define1 && define1.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return impl;
        }(__turbopack_context__.r, exports, module));
    } else {
        this.xor128 = impl;
    }
})(this, ("TURBOPACK compile-time value", "object") == 'object' && module, typeof define == 'function' && define // present with an AMD loader
);
}}),
"[project]/node_modules/seedrandom/lib/xorwow.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this, strseed = '';
        // Set up generator function.
        me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
            // Integer seed.
            me.x = seed;
        } else {
            // String seed.
            strseed += seed;
        }
        // Mix in string seed, then discard an initial batch of 64 values.
        for(var k = 0; k < strseed.length + 64; k++){
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) {
                me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
        }
    }
    function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
    }
    function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do {
                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);
            }while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (typeof state == 'object') copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) {
        module1.exports = impl;
    } else if (define1 && define1.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return impl;
        }(__turbopack_context__.r, exports, module));
    } else {
        this.xorwow = impl;
    }
})(this, ("TURBOPACK compile-time value", "object") == 'object' && module, typeof define == 'function' && define // present with an AMD loader
);
}}),
"[project]/node_modules/seedrandom/lib/xorshift7.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this;
        // Set up generator function.
        me.next = function() {
            // Update xor generator.
            var X = me.x, i = me.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me.i = i + 1 & 7;
            return v;
        };
        function init(me, seed) {
            var j, w, X = [];
            if (seed === (seed | 0)) {
                // Seed state array using a 32-bit integer.
                w = X[0] = seed;
            } else {
                // Seed state using a string.
                seed = '' + seed;
                for(j = 0; j < seed.length; ++j){
                    X[j & 7] = X[j & 7] << 15 ^ seed.charCodeAt(j) + X[j + 1 & 7] << 13;
                }
            }
            // Enforce an array length of 8, not all zeroes.
            while(X.length < 8)X.push(0);
            for(j = 0; j < 8 && X[j] === 0; ++j);
            if (j == 8) w = X[7] = -1;
            else w = X[j];
            me.x = X;
            me.i = 0;
            // Discard an initial 256 values.
            for(j = 256; j > 0; --j){
                me.next();
            }
        }
        init(me, seed);
    }
    function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
    }
    function impl(seed, opts) {
        if (seed == null) seed = +new Date;
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do {
                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);
            }while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (state.x) copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) {
        module1.exports = impl;
    } else if (define1 && define1.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return impl;
        }(__turbopack_context__.r, exports, module));
    } else {
        this.xorshift7 = impl;
    }
})(this, ("TURBOPACK compile-time value", "object") == 'object' && module, typeof define == 'function' && define // present with an AMD loader
);
}}),
"[project]/node_modules/seedrandom/lib/xor4096.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this;
        // Set up generator function.
        me.next = function() {
            var w = me.w, X = me.X, i = me.i, t, v;
            // Update Weyl generator.
            me.w = w = w + 0x61c88647 | 0;
            // Update xor generator.
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            // Update Xor generator array state.
            v = X[i] = v ^ t;
            me.i = i;
            // Result is the combination.
            return v + (w ^ w >>> 16) | 0;
        };
        function init(me, seed) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed === (seed | 0)) {
                // Numeric seeds initialize v, which is used to generates X.
                v = seed;
                seed = null;
            } else {
                // String seeds are mixed into v and X one character at a time.
                seed = seed + '\0';
                v = 0;
                limit = Math.max(limit, seed.length);
            }
            // Initialize circular array and weyl value.
            for(i = 0, j = -32; j < limit; ++j){
                // Put the unicode characters into the array, and shuffle them.
                if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
                // After 32 shuffles, take v as the starting w value.
                if (j === 0) w = v;
                v ^= v << 10;
                v ^= v >>> 15;
                v ^= v << 4;
                v ^= v >>> 13;
                if (j >= 0) {
                    w = w + 0x61c88647 | 0; // Weyl.
                    t = X[j & 127] ^= v + w; // Combine xor and weyl to init array.
                    i = 0 == t ? i + 1 : 0; // Count zeroes.
                }
            }
            // We have detected all zeroes; make the key nonzero.
            if (i >= 128) {
                X[(seed && seed.length || 0) & 127] = -1;
            }
            // Run the generator 512 times to further mix the state before using it.
            // Factoring this as a function slows the main generator, so it is just
            // unrolled here.  The weyl generator is not advanced while warming up.
            i = 127;
            for(j = 4 * 128; j > 0; --j){
                v = X[i + 34 & 127];
                t = X[i = i + 1 & 127];
                v ^= v << 13;
                t ^= t << 17;
                v ^= v >>> 15;
                t ^= t >>> 12;
                X[i] = v ^ t;
            }
            // Storing state as object members is faster than using closure variables.
            me.w = w;
            me.X = X;
            me.i = i;
        }
        init(me, seed);
    }
    function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
    }
    ;
    function impl(seed, opts) {
        if (seed == null) seed = +new Date;
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do {
                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);
            }while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (state.X) copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) {
        module1.exports = impl;
    } else if (define1 && define1.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return impl;
        }(__turbopack_context__.r, exports, module));
    } else {
        this.xor4096 = impl;
    }
})(this, ("TURBOPACK compile-time value", "object") == 'object' && module, typeof define == 'function' && define // present with an AMD loader
);
}}),
"[project]/node_modules/seedrandom/lib/tychei.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this, strseed = '';
        // Set up generator function.
        me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
        };
        /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */ me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
            // Integer seed.
            me.a = seed / 0x100000000 | 0;
            me.b = seed | 0;
        } else {
            // String seed.
            strseed += seed;
        }
        // Mix in string seed, then discard an initial batch of 64 values.
        for(var k = 0; k < strseed.length + 20; k++){
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
        }
    }
    function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
    }
    ;
    function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do {
                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);
            }while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (typeof state == 'object') copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) {
        module1.exports = impl;
    } else if (define1 && define1.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return impl;
        }(__turbopack_context__.r, exports, module));
    } else {
        this.tychei = impl;
    }
})(this, ("TURBOPACK compile-time value", "object") == 'object' && module, typeof define == 'function' && define // present with an AMD loader
);
}}),
"[project]/node_modules/seedrandom/seedrandom.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/ (function(pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //
    var global = this, width = 256, chunks = 6, digits = 52, rngname = 'random', startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto; // node.js crypto module, initialized at the bottom.
    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
    function seedrandom(seed, options, callback) {
        var key = [];
        options = options == true ? {
            entropy: true
        } : options || {};
        // Flatten the seed string or build one from local entropy if needed.
        var shortseed = mixkey(flatten(options.entropy ? [
            seed,
            tostring(pool)
        ] : seed == null ? autoseed() : seed, 3), key);
        // Use the seed to initialize an ARC4 generator.
        var arc4 = new ARC4(key);
        // This function returns a random double in [0, 1) that contains
        // randomness in every bit of the mantissa of the IEEE 754 value.
        var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0; //   and no 'extra last byte'.
            while(n < significance){
                n = (n + x) * width; //   shifting numerator and
                d *= width; //   denominator and generating a
                x = arc4.g(1); //   new least-significant-byte.
            }
            while(n >= overflow){
                n /= 2; //   last byte, shift everything
                d /= 2; //   right using integer math until
                x >>>= 1; //   we have exactly the desired bits.
            }
            return (n + x) / d; // Form the number within [0, 1).
        };
        prng.int32 = function() {
            return arc4.g(4) | 0;
        };
        prng.quick = function() {
            return arc4.g(4) / 0x100000000;
        };
        prng.double = prng;
        // Mix the randomness into accumulated entropy.
        mixkey(tostring(arc4.S), pool);
        // Calling convention: what to return as a function of prng, seed, is_math.
        return (options.pass || callback || function(prng, seed, is_math_call, state) {
            if (state) {
                // Load the arc4 state from the given state if it has an S array.
                if (state.S) {
                    copy(state, arc4);
                }
                // Only provide the .state method if requested via options.state.
                prng.state = function() {
                    return copy(arc4, {});
                };
            }
            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) {
                math[rngname] = prng;
                return seed;
            } else return prng;
        })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);
    }
    math['seed' + rngname] = seedrandom;
    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        // The empty key [] is treated as [0].
        if (!keylen) {
            key = [
                keylen++
            ];
        }
        // Set up S using the standard key scheduling algorithm.
        while(i < width){
            s[i] = i++;
        }
        for(i = 0; i < width; i++){
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
        }
        // The "g" method returns the next (count) outputs as one number.
        (me.g = function(count) {
            // Using instance members instead of closure state nearly doubles speed.
            var t, r = 0, i = me.i, j = me.j, s = me.S;
            while(count--){
                t = s[i = mask & i + 1];
                r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
            }
            me.i = i;
            me.j = j;
            return r;
        // For robust unpredictability, the function call below automatically
        // discards an initial batch of values.  This is called RC4-drop[256].
        // See http://google.com/search?q=rsa+fluhrer+response&btnI
        })(width);
    }
    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
    function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
    }
    ;
    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
    function flatten(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == 'object') {
            for(prop in obj){
                try {
                    result.push(flatten(obj[prop], depth - 1));
                } catch (e) {}
            }
        }
        return result.length ? result : typ == 'string' ? obj : obj + '\0';
    }
    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
    function mixkey(seed, key) {
        var stringseed = seed + '', smear, j = 0;
        while(j < stringseed.length){
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
    }
    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
    function autoseed() {
        try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
                // The use of 'out' to remember randomBytes makes tight minified code.
                out = out(width);
            } else {
                out = new Uint8Array(width);
                (global.crypto || global.msCrypto).getRandomValues(out);
            }
            return tostring(out);
        } catch (e) {
            var browser = global.navigator, plugins = browser && browser.plugins;
            return [
                +new Date,
                global,
                plugins,
                global.screen,
                tostring(pool)
            ];
        }
    }
    //
    // tostring()
    // Converts an array of charcodes to a string
    //
    function tostring(a) {
        return String.fromCharCode.apply(0, a);
    }
    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
    mixkey(math.random(), pool);
    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    if (("TURBOPACK compile-time value", "object") == 'object' && module.exports) {
        module.exports = seedrandom;
        // When in node.js, try using crypto package for autoseeding.
        try {
            nodecrypto = {};
        } catch (ex) {}
    } else if (typeof define == 'function' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return seedrandom;
        }(__turbopack_context__.r, exports, module));
    }
// End anonymous scope, and pass initial values.
})([], Math // math: package containing random, pow, and seedrandom
);
}}),
"[project]/node_modules/seedrandom/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.
// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __turbopack_context__.r("[project]/node_modules/seedrandom/lib/alea.js [app-client] (ecmascript)");
// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __turbopack_context__.r("[project]/node_modules/seedrandom/lib/xor128.js [app-client] (ecmascript)");
// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __turbopack_context__.r("[project]/node_modules/seedrandom/lib/xorwow.js [app-client] (ecmascript)");
// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __turbopack_context__.r("[project]/node_modules/seedrandom/lib/xorshift7.js [app-client] (ecmascript)");
// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __turbopack_context__.r("[project]/node_modules/seedrandom/lib/xor4096.js [app-client] (ecmascript)");
// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __turbopack_context__.r("[project]/node_modules/seedrandom/lib/tychei.js [app-client] (ecmascript)");
// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __turbopack_context__.r("[project]/node_modules/seedrandom/seedrandom.js [app-client] (ecmascript)");
sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;
module.exports = sr;
}}),
"[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "altToAcc": (()=>altToAcc),
    "build": (()=>build),
    "chroma": (()=>chroma),
    "enharmonic": (()=>enharmonic),
    "freq": (()=>freq),
    "freqToMidi": (()=>freqToMidi),
    "from": (()=>from),
    "fromMidi": (()=>fromMidi),
    "midi": (()=>midi),
    "midiToFreq": (()=>midiToFreq),
    "name": (()=>name),
    "names": (()=>names),
    "oct": (()=>oct),
    "pc": (()=>pc),
    "props": (()=>props),
    "simplify": (()=>simplify),
    "stepToLetter": (()=>stepToLetter),
    "tokenize": (()=>tokenize)
});
var NAMES = "C C# Db D D# Eb E F F# Gb G G# Ab A A# Bb B".split(" ");
var names = function(accTypes) {
    return typeof accTypes !== "string" ? NAMES.slice() : NAMES.filter(function(n) {
        var acc = n[1] || " ";
        return accTypes.indexOf(acc) !== -1;
    });
};
var SHARPS = names(" #");
var FLATS = names(" b");
var REGEX = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function tokenize(str) {
    if (typeof str !== "string") str = "";
    var m = REGEX.exec(str);
    return [
        m[1].toUpperCase(),
        m[2].replace(/x/g, "##"),
        m[3],
        m[4]
    ];
}
var NO_NOTE = Object.freeze({
    pc: null,
    name: null,
    step: null,
    alt: null,
    oct: null,
    octStr: null,
    chroma: null,
    midi: null,
    freq: null
});
var SEMI = [
    0,
    2,
    4,
    5,
    7,
    9,
    11
];
var properties = function(str) {
    var tokens = tokenize(str);
    if (tokens[0] === "" || tokens[3] !== "") return NO_NOTE;
    var letter = tokens[0], acc = tokens[1], octStr = tokens[2];
    var p = {
        letter: letter,
        acc: acc,
        octStr: octStr,
        pc: letter + acc,
        name: letter + acc + octStr,
        step: (letter.charCodeAt(0) + 3) % 7,
        alt: acc[0] === "b" ? -acc.length : acc.length,
        oct: octStr.length ? +octStr : null,
        chroma: 0,
        midi: null,
        freq: null
    };
    p.chroma = (SEMI[p.step] + p.alt + 120) % 12;
    p.midi = p.oct !== null ? SEMI[p.step] + p.alt + 12 * (p.oct + 1) : null;
    p.freq = midiToFreq(p.midi);
    return Object.freeze(p);
};
var memo = function(fn, cache) {
    if (cache === void 0) {
        cache = {};
    }
    return function(str) {
        return cache[str] || (cache[str] = fn(str));
    };
};
var props = memo(properties);
var name = function(str) {
    return props(str).name;
};
var pc = function(str) {
    return props(str).pc;
};
var isMidiRange = function(m) {
    return m >= 0 && m <= 127;
};
var midi = function(note) {
    if (typeof note !== "number" && typeof note !== "string") {
        return null;
    }
    var midi = props(note).midi;
    var value = midi || midi === 0 ? midi : +note;
    return isMidiRange(value) ? value : null;
};
var midiToFreq = function(midi, tuning) {
    if (tuning === void 0) {
        tuning = 440;
    }
    return typeof midi === "number" ? Math.pow(2, (midi - 69) / 12) * tuning : null;
};
var freq = function(note) {
    return props(note).freq || midiToFreq(note);
};
var L2 = Math.log(2);
var L440 = Math.log(440);
var freqToMidi = function(freq) {
    var v = 12 * (Math.log(freq) - L440) / L2 + 69;
    return Math.round(v * 100) / 100;
};
var chroma = function(str) {
    return props(str).chroma;
};
var oct = function(str) {
    return props(str).oct;
};
var LETTERS = "CDEFGAB";
var stepToLetter = function(step) {
    return LETTERS[step];
};
var fillStr = function(s, n) {
    return Array(n + 1).join(s);
};
var numToStr = function(num, op) {
    return typeof num !== "number" ? "" : op(num);
};
var altToAcc = function(alt) {
    return numToStr(alt, function(alt) {
        return alt < 0 ? fillStr("b", -alt) : fillStr("#", alt);
    });
};
var from = function(fromProps, baseNote) {
    if (fromProps === void 0) {
        fromProps = {};
    }
    if (baseNote === void 0) {
        baseNote = null;
    }
    var _a = baseNote ? Object.assign({}, props(baseNote), fromProps) : fromProps, step = _a.step, alt = _a.alt, oct = _a.oct;
    if (typeof step !== "number") return null;
    var letter = stepToLetter(step);
    if (!letter) return null;
    var pc = letter + altToAcc(alt);
    return oct || oct === 0 ? pc + oct : pc;
};
var build = from;
function fromMidi(num, sharps) {
    if (sharps === void 0) {
        sharps = false;
    }
    num = Math.round(num);
    var pcs = sharps === true ? SHARPS : FLATS;
    var pc = pcs[num % 12];
    var o = Math.floor(num / 12) - 1;
    return pc + o;
}
var simplify = function(note, sameAcc) {
    if (sameAcc === void 0) {
        sameAcc = true;
    }
    var _a = props(note), alt = _a.alt, chroma = _a.chroma, midi = _a.midi;
    if (chroma === null) return null;
    var alteration = alt;
    var useSharps = sameAcc === false ? alteration < 0 : alteration > 0;
    return midi === null ? pc(fromMidi(chroma, useSharps)) : fromMidi(midi, useSharps);
};
var enharmonic = function(note) {
    return simplify(note, false);
};
;
}}),
"[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript) <export * as Note>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Note": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/tonal-array/build/es6.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-array.svg?style=flat-square)](https://www.npmjs.com/package/tonal-array)
 *
 * Tonal array utilities. Create ranges, sort notes, ...
 *
 * @example
 * import * as Array;
 * Array.sort(["f", "a", "c"]) // => ["C", "F", "A"]
 *
 * @example
 * const Array = require("tonal-array")
 * Array.range(1, 4) // => [1, 2, 3, 4]
 *
 * @module Array
 */ __turbopack_context__.s({
    "compact": (()=>compact),
    "permutations": (()=>permutations),
    "range": (()=>range),
    "rotate": (()=>rotate),
    "shuffle": (()=>shuffle),
    "sort": (()=>sort),
    "unique": (()=>unique)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript)");
;
// ascending range
function ascR(b, n) {
    for(var a = []; n--; a[n] = n + b){
        ;
    }
    return a;
}
// descending range
function descR(b, n) {
    for(var a = []; n--; a[n] = b - n){
        ;
    }
    return a;
}
function range(a, b) {
    return a === null || b === null ? [] : a < b ? ascR(a, b - a + 1) : descR(a, a - b + 1);
}
function rotate(times, arr) {
    var len = arr.length;
    var n = (times % len + len) % len;
    return arr.slice(n, len).concat(arr.slice(0, n));
}
var compact = function(arr) {
    return arr.filter(function(n) {
        return n === 0 || n;
    });
};
// a function that get note heights (with negative number for pitch classes)
var height = function(name) {
    var m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["props"])(name).midi;
    return m !== null ? m : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["props"])(name + "-100").midi;
};
function sort(src) {
    return compact(src.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["name"])).sort(function(a, b) {
        return height(a) > height(b);
    });
}
function unique(arr) {
    return sort(arr).filter(function(n, i, a) {
        return i === 0 || n !== a[i - 1];
    });
}
var shuffle = function(arr, rnd) {
    if (rnd === void 0) rnd = Math.random;
    var i, t;
    var m = arr.length;
    while(m){
        i = rnd() * m-- | 0;
        t = arr[m];
        arr[m] = arr[i];
        arr[i] = t;
    }
    return arr;
};
var permutations = function(arr) {
    if (arr.length === 0) {
        return [
            []
        ];
    }
    return permutations(arr.slice(1)).reduce(function(acc, perm) {
        return acc.concat(arr.map(function(e, pos) {
            var newPerm = perm.slice();
            newPerm.splice(pos, 0, arr[0]);
            return newPerm;
        }));
    }, []);
};
}}),
"[project]/node_modules/tonal-interval/build/es6.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "altToQ": (()=>altToQ),
    "build": (()=>build),
    "chroma": (()=>chroma),
    "fromSemitones": (()=>fromSemitones),
    "ic": (()=>ic),
    "invert": (()=>invert),
    "name": (()=>name),
    "names": (()=>names),
    "num": (()=>num),
    "props": (()=>props),
    "qToAlt": (()=>qToAlt),
    "semitones": (()=>semitones),
    "simplify": (()=>simplify),
    "tokenize": (()=>tokenize)
});
var IVL_TNL = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var IVL_STR = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX = new RegExp("^" + IVL_TNL + "|" + IVL_STR + "$");
var SIZES = [
    0,
    2,
    4,
    5,
    7,
    9,
    11
];
var TYPES = "PMMPPMM";
var CLASSES = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    5,
    4,
    3,
    2,
    1
];
var NAMES = "1P 2m 2M 3m 3M 4P 5P 6m 6M 7m 7M 8P".split(" ");
var names = function(types) {
    return typeof types !== "string" ? NAMES.slice() : NAMES.filter(function(n) {
        return types.indexOf(n[1]) !== -1;
    });
};
var tokenize = function(str) {
    var m = REGEX.exec("" + str);
    if (m === null) return null;
    return m[1] ? [
        m[1],
        m[2]
    ] : [
        m[4],
        m[3]
    ];
};
var NO_IVL = Object.freeze({
    name: null,
    num: null,
    q: null,
    step: null,
    alt: null,
    dir: null,
    type: null,
    simple: null,
    semitones: null,
    chroma: null,
    oct: null
});
var fillStr = function(s, n) {
    return Array(Math.abs(n) + 1).join(s);
};
var qToAlt = function(type, q) {
    if (q === "M" && type === "M") return 0;
    if (q === "P" && type === "P") return 0;
    if (q === "m" && type === "M") return -1;
    if (/^A+$/.test(q)) return q.length;
    if (/^d+$/.test(q)) return type === "P" ? -q.length : -q.length - 1;
    return null;
};
var altToQ = function(type, alt) {
    if (alt === 0) return type === "M" ? "M" : "P";
    else if (alt === -1 && type === "M") return "m";
    else if (alt > 0) return fillStr("A", alt);
    else if (alt < 0) return fillStr("d", type === "P" ? alt : alt + 1);
    else return null;
};
var numToStep = function(num) {
    return (Math.abs(num) - 1) % 7;
};
var properties = function(str) {
    var t = tokenize(str);
    if (t === null) return NO_IVL;
    var p = {
        num: 0,
        q: "d",
        name: "",
        type: "M",
        step: 0,
        dir: -1,
        simple: 1,
        alt: 0,
        oct: 0,
        semitones: 0,
        chroma: 0,
        ic: 0
    };
    p.num = +t[0];
    p.q = t[1];
    p.step = numToStep(p.num);
    p.type = TYPES[p.step];
    if (p.type === "M" && p.q === "P") return NO_IVL;
    p.name = "" + p.num + p.q;
    p.dir = p.num < 0 ? -1 : 1;
    p.simple = p.num === 8 || p.num === -8 ? p.num : p.dir * (p.step + 1);
    p.alt = qToAlt(p.type, p.q);
    p.oct = Math.floor((Math.abs(p.num) - 1) / 7);
    p.semitones = p.dir * (SIZES[p.step] + p.alt + 12 * p.oct);
    p.chroma = (p.dir * (SIZES[p.step] + p.alt) % 12 + 12) % 12;
    return Object.freeze(p);
};
var cache = {};
function props(str) {
    if (typeof str !== "string") return NO_IVL;
    return cache[str] || (cache[str] = properties(str));
}
var num = function(str) {
    return props(str).num;
};
var name = function(str) {
    return props(str).name;
};
var semitones = function(str) {
    return props(str).semitones;
};
var chroma = function(str) {
    return props(str).chroma;
};
var ic = function(ivl) {
    if (typeof ivl === "string") ivl = props(ivl).chroma;
    return typeof ivl === "number" ? CLASSES[ivl % 12] : null;
};
var build = function(_a) {
    var _b = _a === void 0 ? {} : _a, num = _b.num, step = _b.step, alt = _b.alt, _c = _b.oct, oct = _c === void 0 ? 1 : _c, dir = _b.dir;
    if (step !== undefined) num = step + 1 + 7 * oct;
    if (num === undefined) return null;
    if (typeof alt !== "number") return null;
    var d = typeof dir !== "number" ? "" : dir < 0 ? "-" : "";
    var type = TYPES[numToStep(num)];
    return d + num + altToQ(type, alt);
};
var simplify = function(str) {
    var p = props(str);
    if (p === NO_IVL) return null;
    var intervalProps = p;
    return intervalProps.simple + intervalProps.q;
};
var invert = function(str) {
    var p = props(str);
    if (p === NO_IVL) return null;
    var intervalProps = p;
    var step = (7 - intervalProps.step) % 7;
    var alt = intervalProps.type === "P" ? -intervalProps.alt : -(intervalProps.alt + 1);
    return build({
        step: step,
        alt: alt,
        oct: intervalProps.oct,
        dir: intervalProps.dir
    });
};
var IN = [
    1,
    2,
    2,
    3,
    3,
    4,
    5,
    5,
    6,
    6,
    7,
    7
];
var IQ = "P m M m M P d P m M m M".split(" ");
var fromSemitones = function(num) {
    var d = num < 0 ? -1 : 1;
    var n = Math.abs(num);
    var c = n % 12;
    var o = Math.floor(n / 12);
    return d * (IN[c] + 7 * o) + IQ[c];
};
;
}}),
"[project]/node_modules/tonal-distance/build/es6.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-distance.svg)](https://www.npmjs.com/package/tonal-distance)
 * [![tonal](https://img.shields.io/badge/tonal-distance-yellow.svg)](https://github.com/danigb/tonal/tree/master/packages/tonal/distance)
 *
 * Transpose notes by intervals and find distances between notes
 *
 * @example
 * // es6
 * import * as Distance from "tonal-distance"
 * Distance.interval("C3", "C4") // => "1P"
 *
 * @example
 * // es6 import selected functions
 * import { interval, semitones, transpose } from "tonal-distance"
 *
 * semitones("C" ,"D") // => 2
 * interval("C4", "G4") // => "5P"
 * transpose("C4", "P5") // => "G4"
 *
 * @example
 * // included in tonal facade
 * const Tonal = require("tonal");
 * Tonal.Distance.transpose("C4", "P5")
 * Tonal.Distance.transposeBy("P5", "C4")
 *
 * @module Distance
 */ __turbopack_context__.s({
    "add": (()=>add),
    "addIntervals": (()=>addIntervals),
    "fifths": (()=>fifths),
    "interval": (()=>interval),
    "semitones": (()=>semitones),
    "subtract": (()=>subtract),
    "trFifths": (()=>trFifths),
    "transpose": (()=>transpose),
    "transposeBy": (()=>transposeBy)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$interval$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-interval/build/es6.js [app-client] (ecmascript)");
;
;
// Map from letter step to number of fifths starting from "C":
// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }
var FIFTHS = [
    0,
    2,
    4,
    -1,
    1,
    3,
    5
];
// Given a number of fifths, return the octaves they span
var fOcts = function(f) {
    return Math.floor(f * 7 / 12);
};
// Get the number of octaves it span each step
var FIFTH_OCTS = FIFTHS.map(fOcts);
var encode = function(ref) {
    var step = ref.step;
    var alt = ref.alt;
    var oct = ref.oct;
    var dir = ref.dir;
    if (dir === void 0) dir = 1;
    var f = FIFTHS[step] + 7 * alt;
    if (oct === null) {
        return [
            dir * f
        ];
    }
    var o = oct - FIFTH_OCTS[step] - 4 * alt;
    return [
        dir * f,
        dir * o
    ];
};
// We need to get the steps from fifths
// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]
// We add 1 to fifths to avoid negative numbers, so:
// for ["F", "C", "G", "D", "A", "E", "B"] we have:
var STEPS = [
    3,
    0,
    4,
    1,
    5,
    2,
    6
];
// Return the number of fifths as if it were unaltered
function unaltered(f) {
    var i = (f + 1) % 7;
    return i < 0 ? 7 + i : i;
}
var decode = function(f, o, dir) {
    var step = STEPS[unaltered(f)];
    var alt = Math.floor((f + 1) / 7);
    if (o === undefined) {
        return {
            step: step,
            alt: alt,
            dir: dir
        };
    }
    var oct = o + 4 * alt + FIFTH_OCTS[step];
    return {
        step: step,
        alt: alt,
        oct: oct,
        dir: dir
    };
};
var memo = function(fn, cache) {
    if (cache === void 0) cache = {};
    return function(str) {
        return cache[str] || (cache[str] = fn(str));
    };
};
var encoder = function(props) {
    return memo(function(str) {
        var p = props(str);
        return p.name === null ? null : encode(p);
    });
};
var encodeNote = encoder(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["props"]);
var encodeIvl = encoder(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$interval$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["props"]);
function transpose(note, interval) {
    if (arguments.length === 1) {
        return function(i) {
            return transpose(note, i);
        };
    }
    var n = encodeNote(note);
    var i = encodeIvl(interval);
    if (n === null || i === null) {
        return null;
    }
    var tr = n.length === 1 ? [
        n[0] + i[0]
    ] : [
        n[0] + i[0],
        n[1] + i[1]
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["build"])(decode(tr[0], tr[1]));
}
function trFifths(note, fifths) {
    if (arguments.length === 1) {
        return function(f) {
            return trFifths(note, f);
        };
    }
    var n = encodeNote(note);
    if (n === null) {
        return null;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["build"])(decode(n[0] + fifths));
}
function fifths(from, to) {
    if (arguments.length === 1) {
        return function(to) {
            return fifths(from, to);
        };
    }
    var f = encodeNote(from);
    var t = encodeNote(to);
    if (t === null || f === null) {
        return null;
    }
    return t[0] - f[0];
}
function transposeBy(interval, note) {
    if (arguments.length === 1) {
        return function(n) {
            return transpose(n, interval);
        };
    }
    return transpose(note, interval);
}
var isDescending = function(e) {
    return e[0] * 7 + e[1] * 12 < 0;
};
var decodeIvl = function(i) {
    return isDescending(i) ? decode(-i[0], -i[1], -1) : decode(i[0], i[1], 1);
};
function addIntervals(ivl1, ivl2, dir) {
    var i1 = encodeIvl(ivl1);
    var i2 = encodeIvl(ivl2);
    if (i1 === null || i2 === null) {
        return null;
    }
    var i = [
        i1[0] + dir * i2[0],
        i1[1] + dir * i2[1]
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$interval$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["build"])(decodeIvl(i));
}
function add(ivl1, ivl2) {
    if (arguments.length === 1) {
        return function(i2) {
            return add(ivl1, i2);
        };
    }
    return addIntervals(ivl1, ivl2, 1);
}
function subtract(ivl1, ivl2) {
    if (arguments.length === 1) {
        return function(i2) {
            return add(ivl1, i2);
        };
    }
    return addIntervals(ivl1, ivl2, -1);
}
function interval(from, to) {
    if (arguments.length === 1) {
        return function(t) {
            return interval(from, t);
        };
    }
    var f = encodeNote(from);
    var t = encodeNote(to);
    if (f === null || t === null || f.length !== t.length) {
        return null;
    }
    var d = f.length === 1 ? [
        t[0] - f[0],
        -Math.floor((t[0] - f[0]) * 7 / 12)
    ] : [
        t[0] - f[0],
        t[1] - f[1]
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$interval$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["build"])(decodeIvl(d));
}
function semitones(from, to) {
    if (arguments.length === 1) {
        return function(t) {
            return semitones(from, t);
        };
    }
    var f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["props"])(from);
    var t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["props"])(to);
    return f.midi !== null && t.midi !== null ? t.midi - f.midi : f.chroma !== null && t.chroma !== null ? (t.chroma - f.chroma + 12) % 12 : null;
}
}}),
"[project]/node_modules/tonal-dictionary/build/data/scales.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"chromatic\":[\"1P 2m 2M 3m 3M 4P 4A 5P 6m 6M 7m 7M\"],\"lydian\":[\"1P 2M 3M 4A 5P 6M 7M\"],\"major\":[\"1P 2M 3M 4P 5P 6M 7M\",[\"ionian\"]],\"mixolydian\":[\"1P 2M 3M 4P 5P 6M 7m\",[\"dominant\"]],\"dorian\":[\"1P 2M 3m 4P 5P 6M 7m\"],\"aeolian\":[\"1P 2M 3m 4P 5P 6m 7m\",[\"minor\"]],\"phrygian\":[\"1P 2m 3m 4P 5P 6m 7m\"],\"locrian\":[\"1P 2m 3m 4P 5d 6m 7m\"],\"melodic minor\":[\"1P 2M 3m 4P 5P 6M 7M\"],\"melodic minor second mode\":[\"1P 2m 3m 4P 5P 6M 7m\"],\"lydian augmented\":[\"1P 2M 3M 4A 5A 6M 7M\"],\"lydian dominant\":[\"1P 2M 3M 4A 5P 6M 7m\",[\"lydian b7\"]],\"melodic minor fifth mode\":[\"1P 2M 3M 4P 5P 6m 7m\",[\"hindu\",\"mixolydian b6M\"]],\"locrian #2\":[\"1P 2M 3m 4P 5d 6m 7m\",[\"half-diminished\"]],\"altered\":[\"1P 2m 3m 3M 5d 6m 7m\",[\"super locrian\",\"diminished whole tone\",\"pomeroy\"]],\"harmonic minor\":[\"1P 2M 3m 4P 5P 6m 7M\"],\"phrygian dominant\":[\"1P 2m 3M 4P 5P 6m 7m\",[\"spanish\",\"phrygian major\"]],\"half-whole diminished\":[\"1P 2m 3m 3M 4A 5P 6M 7m\",[\"dominant diminished\"]],\"diminished\":[\"1P 2M 3m 4P 5d 6m 6M 7M\",[\"whole-half diminished\"]],\"major pentatonic\":[\"1P 2M 3M 5P 6M\",[\"pentatonic\"]],\"lydian pentatonic\":[\"1P 3M 4A 5P 7M\",[\"chinese\"]],\"mixolydian pentatonic\":[\"1P 3M 4P 5P 7m\",[\"indian\"]],\"locrian pentatonic\":[\"1P 3m 4P 5d 7m\",[\"minor seven flat five pentatonic\"]],\"minor pentatonic\":[\"1P 3m 4P 5P 7m\"],\"minor six pentatonic\":[\"1P 3m 4P 5P 6M\"],\"minor hexatonic\":[\"1P 2M 3m 4P 5P 7M\"],\"flat three pentatonic\":[\"1P 2M 3m 5P 6M\",[\"kumoi\"]],\"flat six pentatonic\":[\"1P 2M 3M 5P 6m\"],\"major flat two pentatonic\":[\"1P 2m 3M 5P 6M\"],\"whole tone pentatonic\":[\"1P 3M 5d 6m 7m\"],\"ionian pentatonic\":[\"1P 3M 4P 5P 7M\"],\"lydian #5P pentatonic\":[\"1P 3M 4A 5A 7M\"],\"lydian dominant pentatonic\":[\"1P 3M 4A 5P 7m\"],\"minor #7M pentatonic\":[\"1P 3m 4P 5P 7M\"],\"super locrian pentatonic\":[\"1P 3m 4d 5d 7m\"],\"in-sen\":[\"1P 2m 4P 5P 7m\"],\"iwato\":[\"1P 2m 4P 5d 7m\"],\"hirajoshi\":[\"1P 2M 3m 5P 6m\"],\"kumoijoshi\":[\"1P 2m 4P 5P 6m\"],\"pelog\":[\"1P 2m 3m 5P 6m\"],\"vietnamese 1\":[\"1P 3m 4P 5P 6m\"],\"vietnamese 2\":[\"1P 3m 4P 5P 7m\"],\"prometheus\":[\"1P 2M 3M 4A 6M 7m\"],\"prometheus neopolitan\":[\"1P 2m 3M 4A 6M 7m\"],\"ritusen\":[\"1P 2M 4P 5P 6M\"],\"scriabin\":[\"1P 2m 3M 5P 6M\"],\"piongio\":[\"1P 2M 4P 5P 6M 7m\"],\"major blues\":[\"1P 2M 3m 3M 5P 6M\"],\"minor blues\":[\"1P 3m 4P 5d 5P 7m\",[\"blues\"]],\"composite blues\":[\"1P 2M 3m 3M 4P 5d 5P 6M 7m\"],\"augmented\":[\"1P 2A 3M 5P 5A 7M\"],\"augmented heptatonic\":[\"1P 2A 3M 4P 5P 5A 7M\"],\"dorian #4\":[\"1P 2M 3m 4A 5P 6M 7m\"],\"lydian diminished\":[\"1P 2M 3m 4A 5P 6M 7M\"],\"whole tone\":[\"1P 2M 3M 4A 5A 7m\"],\"leading whole tone\":[\"1P 2M 3M 4A 5A 7m 7M\"],\"lydian minor\":[\"1P 2M 3M 4A 5P 6m 7m\"],\"locrian major\":[\"1P 2M 3M 4P 5d 6m 7m\",[\"arabian\"]],\"neopolitan\":[\"1P 2m 3m 4P 5P 6m 7M\"],\"neopolitan minor\":[\"1P 2m 3m 4P 5P 6m 7M\"],\"neopolitan major\":[\"1P 2m 3m 4P 5P 6M 7M\",[\"dorian b2\"]],\"neopolitan major pentatonic\":[\"1P 3M 4P 5d 7m\"],\"romanian minor\":[\"1P 2M 3m 5d 5P 6M 7m\"],\"double harmonic lydian\":[\"1P 2m 3M 4A 5P 6m 7M\"],\"harmonic major\":[\"1P 2M 3M 4P 5P 6m 7M\"],\"double harmonic major\":[\"1P 2m 3M 4P 5P 6m 7M\",[\"gypsy\"]],\"egyptian\":[\"1P 2M 4P 5P 7m\"],\"hungarian minor\":[\"1P 2M 3m 4A 5P 6m 7M\"],\"hungarian major\":[\"1P 2A 3M 4A 5P 6M 7m\"],\"oriental\":[\"1P 2m 3M 4P 5d 6M 7m\"],\"spanish heptatonic\":[\"1P 2m 3m 3M 4P 5P 6m 7m\"],\"flamenco\":[\"1P 2m 3m 3M 4A 5P 7m\"],\"balinese\":[\"1P 2m 3m 4P 5P 6m 7M\"],\"todi raga\":[\"1P 2m 3m 4A 5P 6m 7M\"],\"malkos raga\":[\"1P 3m 4P 6m 7m\"],\"kafi raga\":[\"1P 3m 3M 4P 5P 6M 7m 7M\"],\"purvi raga\":[\"1P 2m 3M 4P 4A 5P 6m 7M\"],\"persian\":[\"1P 2m 3M 4P 5d 6m 7M\"],\"bebop\":[\"1P 2M 3M 4P 5P 6M 7m 7M\"],\"bebop dominant\":[\"1P 2M 3M 4P 5P 6M 7m 7M\"],\"bebop minor\":[\"1P 2M 3m 3M 4P 5P 6M 7m\"],\"bebop major\":[\"1P 2M 3M 4P 5P 5A 6M 7M\"],\"bebop locrian\":[\"1P 2m 3m 4P 5d 5P 6m 7m\"],\"minor bebop\":[\"1P 2M 3m 4P 5P 6m 7m 7M\"],\"mystery #1\":[\"1P 2m 3M 5d 6m 7m\"],\"enigmatic\":[\"1P 2m 3M 5d 6m 7m 7M\"],\"minor six diminished\":[\"1P 2M 3m 4P 5P 6m 6M 7M\"],\"ionian augmented\":[\"1P 2M 3M 4P 5A 6M 7M\"],\"lydian #9\":[\"1P 2m 3M 4A 5P 6M 7M\"],\"ichikosucho\":[\"1P 2M 3M 4P 5d 5P 6M 7M\"],\"six tone symmetric\":[\"1P 2m 3M 4P 5A 6M\"]}"));}}),
"[project]/node_modules/tonal-dictionary/build/data/chords.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"4\":[\"1P 4P 7m 10m\",[\"quartal\"]],\"64\":[\"5P 8P 10M\"],\"5\":[\"1P 5P\"],\"M\":[\"1P 3M 5P\",[\"Major\",\"\"]],\"M#5\":[\"1P 3M 5A\",[\"augmented\",\"maj#5\",\"Maj#5\",\"+\",\"aug\"]],\"M#5add9\":[\"1P 3M 5A 9M\",[\"+add9\"]],\"M13\":[\"1P 3M 5P 7M 9M 13M\",[\"maj13\",\"Maj13\"]],\"M13#11\":[\"1P 3M 5P 7M 9M 11A 13M\",[\"maj13#11\",\"Maj13#11\",\"M13+4\",\"M13#4\"]],\"M6\":[\"1P 3M 5P 13M\",[\"6\"]],\"M6#11\":[\"1P 3M 5P 6M 11A\",[\"M6b5\",\"6#11\",\"6b5\"]],\"M69\":[\"1P 3M 5P 6M 9M\",[\"69\"]],\"M69#11\":[\"1P 3M 5P 6M 9M 11A\"],\"M7#11\":[\"1P 3M 5P 7M 11A\",[\"maj7#11\",\"Maj7#11\",\"M7+4\",\"M7#4\"]],\"M7#5\":[\"1P 3M 5A 7M\",[\"maj7#5\",\"Maj7#5\",\"maj9#5\",\"M7+\"]],\"M7#5sus4\":[\"1P 4P 5A 7M\"],\"M7#9#11\":[\"1P 3M 5P 7M 9A 11A\"],\"M7add13\":[\"1P 3M 5P 6M 7M 9M\"],\"M7b5\":[\"1P 3M 5d 7M\"],\"M7b6\":[\"1P 3M 6m 7M\"],\"M7b9\":[\"1P 3M 5P 7M 9m\"],\"M7sus4\":[\"1P 4P 5P 7M\"],\"M9\":[\"1P 3M 5P 7M 9M\",[\"maj9\",\"Maj9\"]],\"M9#11\":[\"1P 3M 5P 7M 9M 11A\",[\"maj9#11\",\"Maj9#11\",\"M9+4\",\"M9#4\"]],\"M9#5\":[\"1P 3M 5A 7M 9M\",[\"Maj9#5\"]],\"M9#5sus4\":[\"1P 4P 5A 7M 9M\"],\"M9b5\":[\"1P 3M 5d 7M 9M\"],\"M9sus4\":[\"1P 4P 5P 7M 9M\"],\"Madd9\":[\"1P 3M 5P 9M\",[\"2\",\"add9\",\"add2\"]],\"Maj7\":[\"1P 3M 5P 7M\",[\"maj7\",\"M7\"]],\"Mb5\":[\"1P 3M 5d\"],\"Mb6\":[\"1P 3M 13m\"],\"Msus2\":[\"1P 2M 5P\",[\"add9no3\",\"sus2\"]],\"Msus4\":[\"1P 4P 5P\",[\"sus\",\"sus4\"]],\"Maddb9\":[\"1P 3M 5P 9m\"],\"7\":[\"1P 3M 5P 7m\",[\"Dominant\",\"Dom\"]],\"9\":[\"1P 3M 5P 7m 9M\",[\"79\"]],\"11\":[\"1P 5P 7m 9M 11P\"],\"13\":[\"1P 3M 5P 7m 9M 13M\",[\"13_\"]],\"11b9\":[\"1P 5P 7m 9m 11P\"],\"13#11\":[\"1P 3M 5P 7m 9M 11A 13M\",[\"13+4\",\"13#4\"]],\"13#9\":[\"1P 3M 5P 7m 9A 13M\",[\"13#9_\"]],\"13#9#11\":[\"1P 3M 5P 7m 9A 11A 13M\"],\"13b5\":[\"1P 3M 5d 6M 7m 9M\"],\"13b9\":[\"1P 3M 5P 7m 9m 13M\"],\"13b9#11\":[\"1P 3M 5P 7m 9m 11A 13M\"],\"13no5\":[\"1P 3M 7m 9M 13M\"],\"13sus4\":[\"1P 4P 5P 7m 9M 13M\",[\"13sus\"]],\"69#11\":[\"1P 3M 5P 6M 9M 11A\"],\"7#11\":[\"1P 3M 5P 7m 11A\",[\"7+4\",\"7#4\",\"7#11_\",\"7#4_\"]],\"7#11b13\":[\"1P 3M 5P 7m 11A 13m\",[\"7b5b13\"]],\"7#5\":[\"1P 3M 5A 7m\",[\"+7\",\"7aug\",\"aug7\"]],\"7#5#9\":[\"1P 3M 5A 7m 9A\",[\"7alt\",\"7#5#9_\",\"7#9b13_\"]],\"7#5b9\":[\"1P 3M 5A 7m 9m\"],\"7#5b9#11\":[\"1P 3M 5A 7m 9m 11A\"],\"7#5sus4\":[\"1P 4P 5A 7m\"],\"7#9\":[\"1P 3M 5P 7m 9A\",[\"7#9_\"]],\"7#9#11\":[\"1P 3M 5P 7m 9A 11A\",[\"7b5#9\"]],\"7#9#11b13\":[\"1P 3M 5P 7m 9A 11A 13m\"],\"7#9b13\":[\"1P 3M 5P 7m 9A 13m\"],\"7add6\":[\"1P 3M 5P 7m 13M\",[\"67\",\"7add13\"]],\"7b13\":[\"1P 3M 7m 13m\"],\"7b5\":[\"1P 3M 5d 7m\"],\"7b6\":[\"1P 3M 5P 6m 7m\"],\"7b9\":[\"1P 3M 5P 7m 9m\"],\"7b9#11\":[\"1P 3M 5P 7m 9m 11A\",[\"7b5b9\"]],\"7b9#9\":[\"1P 3M 5P 7m 9m 9A\"],\"7b9b13\":[\"1P 3M 5P 7m 9m 13m\"],\"7b9b13#11\":[\"1P 3M 5P 7m 9m 11A 13m\",[\"7b9#11b13\",\"7b5b9b13\"]],\"7no5\":[\"1P 3M 7m\"],\"7sus4\":[\"1P 4P 5P 7m\",[\"7sus\"]],\"7sus4b9\":[\"1P 4P 5P 7m 9m\",[\"susb9\",\"7susb9\",\"7b9sus\",\"7b9sus4\",\"phryg\"]],\"7sus4b9b13\":[\"1P 4P 5P 7m 9m 13m\",[\"7b9b13sus4\"]],\"9#11\":[\"1P 3M 5P 7m 9M 11A\",[\"9+4\",\"9#4\",\"9#11_\",\"9#4_\"]],\"9#11b13\":[\"1P 3M 5P 7m 9M 11A 13m\",[\"9b5b13\"]],\"9#5\":[\"1P 3M 5A 7m 9M\",[\"9+\"]],\"9#5#11\":[\"1P 3M 5A 7m 9M 11A\"],\"9b13\":[\"1P 3M 7m 9M 13m\"],\"9b5\":[\"1P 3M 5d 7m 9M\"],\"9no5\":[\"1P 3M 7m 9M\"],\"9sus4\":[\"1P 4P 5P 7m 9M\",[\"9sus\"]],\"m\":[\"1P 3m 5P\"],\"m#5\":[\"1P 3m 5A\",[\"m+\",\"mb6\"]],\"m11\":[\"1P 3m 5P 7m 9M 11P\",[\"_11\"]],\"m11A 5\":[\"1P 3m 6m 7m 9M 11P\"],\"m11b5\":[\"1P 3m 7m 12d 2M 4P\",[\"h11\",\"_11b5\"]],\"m13\":[\"1P 3m 5P 7m 9M 11P 13M\",[\"_13\"]],\"m6\":[\"1P 3m 4P 5P 13M\",[\"_6\"]],\"m69\":[\"1P 3m 5P 6M 9M\",[\"_69\"]],\"m7\":[\"1P 3m 5P 7m\",[\"minor7\",\"_\",\"_7\"]],\"m7#5\":[\"1P 3m 6m 7m\"],\"m7add11\":[\"1P 3m 5P 7m 11P\",[\"m7add4\"]],\"m7b5\":[\"1P 3m 5d 7m\",[\"half-diminished\",\"h7\",\"_7b5\"]],\"m9\":[\"1P 3m 5P 7m 9M\",[\"_9\"]],\"m9#5\":[\"1P 3m 6m 7m 9M\"],\"m9b5\":[\"1P 3m 7m 12d 2M\",[\"h9\",\"-9b5\"]],\"mMaj7\":[\"1P 3m 5P 7M\",[\"mM7\",\"_M7\"]],\"mMaj7b6\":[\"1P 3m 5P 6m 7M\",[\"mM7b6\"]],\"mM9\":[\"1P 3m 5P 7M 9M\",[\"mMaj9\",\"-M9\"]],\"mM9b6\":[\"1P 3m 5P 6m 7M 9M\",[\"mMaj9b6\"]],\"mb6M7\":[\"1P 3m 6m 7M\"],\"mb6b9\":[\"1P 3m 6m 9m\"],\"o\":[\"1P 3m 5d\",[\"mb5\",\"dim\"]],\"o7\":[\"1P 3m 5d 13M\",[\"diminished\",\"m6b5\",\"dim7\"]],\"o7M7\":[\"1P 3m 5d 6M 7M\"],\"oM7\":[\"1P 3m 5d 7M\"],\"sus24\":[\"1P 2M 4P 5P\",[\"sus4add9\"]],\"+add#9\":[\"1P 3M 5A 9A\"],\"madd4\":[\"1P 3m 4P 5P\"],\"madd9\":[\"1P 3m 5P 9M\"]}"));}}),
"[project]/node_modules/tonal-dictionary/build/es6.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-dictionary.svg)](https://www.npmjs.com/package/tonal-dictionary)
 *
 * `tonal-dictionary` contains a dictionary of musical scales and chords
 *
 * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.
 *
 * @example
 * // es6
 * import * as Dictionary from "tonal-dictionary"
 * // es5
 * const Dictionary = require("tonal-dictionary")
 *
 * @example
 * Dictionary.chord("Maj7") // => ["1P", "3M", "5P", "7M"]
 *
 * @module Dictionary
 */ __turbopack_context__.s({
    "chord": (()=>chord),
    "combine": (()=>combine),
    "dictionary": (()=>dictionary),
    "pcset": (()=>pcset),
    "scale": (()=>scale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$data$2f$scales$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-dictionary/build/data/scales.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$data$2f$chords$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-dictionary/build/data/chords.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-pcset/build/es6.js [app-client] (ecmascript)");
;
;
;
var dictionary = function(raw) {
    var keys = Object.keys(raw).sort();
    var data = [];
    var index = [];
    var add = function(name, ivls, chroma) {
        data[name] = ivls;
        index[chroma] = index[chroma] || [];
        index[chroma].push(name);
    };
    keys.forEach(function(key) {
        var ivls = raw[key][0].split(" ");
        var alias = raw[key][1];
        var chr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chroma"])(ivls);
        add(key, ivls, chr);
        if (alias) {
            alias.forEach(function(a) {
                return add(a, ivls, chr);
            });
        }
    });
    var allKeys = Object.keys(data).sort();
    var dict = function(name) {
        return data[name];
    };
    dict.names = function(p) {
        if (typeof p === "string") {
            return (index[p] || []).slice();
        } else {
            return (p === true ? allKeys : keys).slice();
        }
    };
    return dict;
};
var combine = function(a, b) {
    var dict = function(name) {
        return a(name) || b(name);
    };
    dict.names = function(p) {
        return a.names(p).concat(b.names(p));
    };
    return dict;
};
var scale = dictionary(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$data$2f$scales$2e$json__$28$json$29$__["default"]);
var chord = dictionary(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$data$2f$chords$2e$json__$28$json$29$__["default"]);
var pcset = combine(scale, chord);
}}),
"[project]/node_modules/tonal-pcset/build/es6.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-pcset.svg?style=flat-square)](https://www.npmjs.com/package/tonal-pcset)
 * [![tonal](https://img.shields.io/badge/tonal-pcset-yellow.svg?style=flat-square)](https://www.npmjs.com/browse/keyword/tonal)
 *
 * `tonal-pcset` is a collection of functions to work with pitch class sets, oriented
 * to make comparations (isEqual, isSubset, isSuperset)
 *
 * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.
 *
 * You can install via npm: `npm i --save tonal-pcset`
 *
 * ```js
 * // es6
 * import PcSet from "tonal-pcset"
 * var PcSet = require("tonal-pcset")
 *
 * PcSet.isEqual("c2 d5 e6", "c6 e3 d1") // => true
 * ```
 *
 * ## API documentation
 *
 * @module PcSet
 */ __turbopack_context__.s({
    "chroma": (()=>chroma),
    "chromas": (()=>chromas),
    "filter": (()=>filter),
    "includes": (()=>includes),
    "intervals": (()=>intervals),
    "isChroma": (()=>isChroma),
    "isEqual": (()=>isEqual),
    "isSubsetOf": (()=>isSubsetOf),
    "isSupersetOf": (()=>isSupersetOf),
    "modes": (()=>modes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$interval$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-interval/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-array/build/es6.js [app-client] (ecmascript)");
;
;
;
var chr = function(str) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chroma"])(str) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$interval$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chroma"])(str) || 0;
};
var pcsetNum = function(set) {
    return parseInt(chroma(set), 2);
};
var clen = function(chroma) {
    return chroma.replace(/0/g, "").length;
};
function chroma(set) {
    if (isChroma(set)) {
        return set;
    }
    if (!Array.isArray(set)) {
        return "";
    }
    var b = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ];
    set.map(chr).forEach(function(i) {
        b[i] = 1;
    });
    return b.join("");
}
var all = null;
function chromas(n) {
    all = all || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["range"])(2048, 4095).map(function(n) {
        return n.toString(2);
    });
    return typeof n === "number" ? all.filter(function(chroma) {
        return clen(chroma) === n;
    }) : all.slice();
}
function modes(set, normalize) {
    normalize = normalize !== false;
    var binary = chroma(set).split("");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compact"])(binary.map(function(_, i) {
        var r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotate"])(i, binary);
        return normalize && r[0] === "0" ? null : r.join("");
    }));
}
var REGEX = /^[01]{12}$/;
function isChroma(set) {
    return REGEX.test(set);
}
var IVLS = "1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M".split(" ");
function intervals(set) {
    if (!isChroma(set)) {
        return [];
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compact"])(set.split("").map(function(d, i) {
        return d === "1" ? IVLS[i] : null;
    }));
}
function isEqual(s1, s2) {
    if (arguments.length === 1) {
        return function(s) {
            return isEqual(s1, s);
        };
    }
    return chroma(s1) === chroma(s2);
}
function isSubsetOf(set, notes) {
    if (arguments.length > 1) {
        return isSubsetOf(set)(notes);
    }
    set = pcsetNum(set);
    return function(notes) {
        notes = pcsetNum(notes);
        return notes !== set && (notes & set) === notes;
    };
}
function isSupersetOf(set, notes) {
    if (arguments.length > 1) {
        return isSupersetOf(set)(notes);
    }
    set = pcsetNum(set);
    return function(notes) {
        notes = pcsetNum(notes);
        return notes !== set && (notes | set) === notes;
    };
}
function includes(set, note) {
    if (arguments.length > 1) {
        return includes(set)(note);
    }
    set = chroma(set);
    return function(note) {
        return set[chr(note)] === "1";
    };
}
function filter(set, notes) {
    if (arguments.length === 1) {
        return function(n) {
            return filter(set, n);
        };
    }
    return notes.filter(includes(set));
}
}}),
"[project]/node_modules/tonal-scale/build/es6.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-scale.svg?style=flat-square)](https://www.npmjs.com/package/tonal-scale)
 *
 * A scale is a collection of pitches in ascending or descending order.
 *
 * This module provides functions to get and manipulate scales.
 *
 * @example
 * // es6
 * import * as Scale from "tonal-scale"
 * // es5
 * const Scale = require("tonal-scale");
 *
 * @example
 * Scale.notes("Ab bebop") // => [ "Ab", "Bb", "C", "Db", "Eb", "F", "Gb", "G" ]
 * Scale.names() => ["major", "minor", ...]
 * @module Scale
 */ __turbopack_context__.s({
    "chords": (()=>chords),
    "exists": (()=>exists),
    "intervals": (()=>intervals),
    "modeNames": (()=>modeNames),
    "names": (()=>names),
    "notes": (()=>notes),
    "props": (()=>props),
    "subsets": (()=>subsets),
    "supersets": (()=>supersets),
    "toScale": (()=>toScale),
    "tokenize": (()=>tokenize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-pcset/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$distance$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-distance/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-dictionary/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-array/build/es6.js [app-client] (ecmascript)");
;
;
;
;
;
var NO_SCALE = Object.freeze({
    name: null,
    intervals: [],
    names: [],
    chroma: null,
    setnum: null
});
var properties = function(name) {
    var intervals = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"])(name);
    if (!intervals) {
        return NO_SCALE;
    }
    var s = {
        intervals: intervals,
        name: name
    };
    s.chroma = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chroma"])(intervals);
    s.setnum = parseInt(s.chroma, 2);
    s.names = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"].names(s.chroma);
    return Object.freeze(s);
};
var memoize = function(fn, cache) {
    return function(str) {
        return cache[str] || (cache[str] = fn(str));
    };
};
var props = memoize(properties, {});
var names = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"].names;
var intervals = function(name) {
    var p = tokenize(name);
    return props(p[1]).intervals;
};
function notes(nameOrTonic, name) {
    var p = tokenize(nameOrTonic);
    name = name || p[1];
    return intervals(name).map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$distance$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transpose"])(p[0]));
}
function exists(name) {
    var p = tokenize(name);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"])(p[1]) !== undefined;
}
function tokenize(str) {
    if (typeof str !== "string") {
        return [
            "",
            ""
        ];
    }
    var i = str.indexOf(" ");
    var tonic = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["name"])(str.substring(0, i)) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["name"])(str) || "";
    var name = tonic !== "" ? str.substring(tonic.length + 1) : str;
    return [
        tonic,
        name.length ? name : ""
    ];
}
var modeNames = function(name) {
    var ivls = intervals(name);
    var tonics = notes(name);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["modes"])(ivls).map(function(chroma, i) {
        var name = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"].names(chroma)[0];
        if (name) {
            return [
                tonics[i] || ivls[i],
                name
            ];
        }
    }).filter(function(x) {
        return x;
    });
};
var chords = function(name) {
    var inScale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSubsetOf"])(intervals(name));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"].names().filter(function(name) {
        return inScale((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"])(name));
    });
};
var toScale = function(notes) {
    var pcset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compact"])(notes.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pc"]));
    if (!pcset.length) {
        return pcset;
    }
    var tonic = pcset[0];
    var scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unique"])(pcset);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotate"])(scale.indexOf(tonic), scale);
};
var supersets = function(name) {
    if (!intervals(name).length) {
        return [];
    }
    var isSuperset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSupersetOf"])(intervals(name));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"].names().filter(function(name) {
        return isSuperset((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"])(name));
    });
};
var subsets = function(name) {
    var isSubset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSubsetOf"])(intervals(name));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"].names().filter(function(name) {
        return isSubset((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"])(name));
    });
};
}}),
"[project]/node_modules/tonal-chord/build/es6.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-chord.svg)](https://www.npmjs.com/package/tonal-chord)
 * [![tonal](https://img.shields.io/badge/tonal-chord-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)
 *
 * `tonal-chord` is a collection of functions to manipulate musical chords
 *
 * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.
 *
 * @example
 * // es6
 * import * as Chord from "tonal-chord"
 * // es5
 * const Chord = require("tonal-chord")
 *
 * @example
 * Chord.notes("CMaj7") // => ["C", "E", "G", "B"]
 *
 * @module Chord
 */ __turbopack_context__.s({
    "exists": (()=>exists),
    "intervals": (()=>intervals),
    "names": (()=>names),
    "notes": (()=>notes),
    "props": (()=>props),
    "subsets": (()=>subsets),
    "supersets": (()=>supersets),
    "tokenize": (()=>tokenize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$distance$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-distance/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-dictionary/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-pcset/build/es6.js [app-client] (ecmascript)");
;
;
;
;
var names = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"].names;
var NO_CHORD = Object.freeze({
    name: null,
    names: [],
    intervals: [],
    chroma: null,
    setnum: null
});
var properties = function(name) {
    var intervals = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"])(name);
    if (!intervals) {
        return NO_CHORD;
    }
    var s = {
        intervals: intervals,
        name: name
    };
    s.chroma = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chroma"])(intervals);
    s.setnum = parseInt(s.chroma, 2);
    s.names = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"].names(s.chroma);
    return s;
};
var memo = function(fn, cache) {
    if (cache === void 0) cache = {};
    return function(str) {
        return cache[str] || (cache[str] = fn(str));
    };
};
var props = memo(properties);
var intervals = function(name) {
    return props(tokenize(name)[1]).intervals;
};
function notes(nameOrTonic, name) {
    if (name) {
        return props(name).intervals.map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$distance$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transpose"])(nameOrTonic));
    }
    var ref = tokenize(nameOrTonic);
    var tonic = ref[0];
    var type = ref[1];
    return props(type).intervals.map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$distance$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transpose"])(tonic));
}
var exists = function(name) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"])(tokenize(name)[1]) !== undefined;
};
var supersets = function(name) {
    if (!intervals(name).length) {
        return [];
    }
    var isSuperset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSupersetOf"])(intervals(name));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"].names().filter(function(name) {
        return isSuperset((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"])(name));
    });
};
var subsets = function(name) {
    var isSubset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSubsetOf"])(intervals(name));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"].names().filter(function(name) {
        return isSubset((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"])(name));
    });
};
// 6, 64, 7, 9, 11 and 13 are consider part of the chord
// (see https://github.com/danigb/tonal/issues/55)
var NUM_TYPES = /^(6|64|7|9|11|13)$/;
function tokenize(name) {
    var p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tokenize"])(name);
    if (p[0] === "") {
        return [
            "",
            name
        ];
    }
    // aug is augmented (see https://github.com/danigb/tonal/issues/55)
    if (p[0] === "A" && p[3] === "ug") {
        return [
            "",
            "aug"
        ];
    }
    if (NUM_TYPES.test(p[2])) {
        return [
            p[0] + p[1],
            p[2] + p[3]
        ];
    } else {
        return [
            p[0] + p[1] + p[2],
            p[3]
        ];
    }
}
}}),
"[project]/node_modules/tonal-chord/build/es6.js [app-client] (ecmascript) <export * as Chord>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Chord": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$chord$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$chord$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-chord/build/es6.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/tonal/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * [![npm version](https://img.shields.io/npm/v/tonal-key.svg?style=flat-square)](https://www.npmjs.com/package/tonal-key)
 *
 * The `Tonal` module is a facade to the rest of the modules. They are namespaced,
 * so for example to use `pc` function from `tonal-note` you have to write:
 * `Tonal.Note.pc`
 *
 * It exports the following modules:
 * - Note
 * - Interval
 * - Distance
 * - Scale
 * - Chord
 * - PcSet
 *
 * Additionally this facade exports some functions without namespace (see "Methods" below)
 *
 * @example
 * // es6 modules
 * import * as Tonal from "tonal"
 * Tonal.Note.name("cx") // => "C##"
 *
 * @example
 * import { Note } from "tonal"
 * Note.name("bb") // => "Bb"
 *
 * @example
 * // es5 node modules
 * var Tonal = require("tonal");
 * Tonal.Distance.transpose(Tonal.Note.pc("C#2"), "M3") // => "E#"
 * Tonal.Chord.notes("Dmaj7") // => ["D", "F#", "A", "C#"]
 *
 * @module Tonal
 */ __turbopack_context__.s({
    "chord": (()=>chord),
    "freq": (()=>freq),
    "interval": (()=>interval),
    "midi": (()=>midi),
    "note": (()=>note),
    "scale": (()=>scale),
    "transpose": (()=>transpose)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-array/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$interval$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-interval/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$distance$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-distance/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-dictionary/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$scale$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-scale/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$chord$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-chord/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-pcset/build/es6.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
const transpose = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$distance$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transpose"];
const interval = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$distance$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["interval"];
const note = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["props"];
const midi = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["midi"];
const freq = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["freq"];
const chord = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chord"];
const scale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scale"];
}}),
"[project]/node_modules/tonal/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$array$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-array/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$note$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-note/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$interval$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-interval/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$distance$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-distance/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$dictionary$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-dictionary/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$scale$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-scale/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$chord$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-chord/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2d$pcset$2f$build$2f$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tonal-pcset/build/es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tonal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/tonal/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@protobufjs/aspromise/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = asPromise;
/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */ /**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */ function asPromise(fn, ctx /*, varargs */ ) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while(index < arguments.length)params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err /*, varargs */ ) {
            if (pending) {
                pending = false;
                if (err) reject(err);
                else {
                    var params = new Array(arguments.length - 1), offset = 0;
                    while(offset < params.length)params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}
}}),
"[project]/node_modules/@protobufjs/base64/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var base64 = exports;
/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */ base64.length = function length(string) {
    var p = string.length;
    if (!p) return 0;
    var n = 0;
    while(--p % 4 > 1 && string.charAt(p) === "=")++n;
    return Math.ceil(string.length * 3) / 4 - n;
};
// Base64 encoding table
var b64 = new Array(64);
// Base64 decoding table
var s64 = new Array(123);
// 65..90, 97..122, 48..57, 43, 47
for(var i = 0; i < 64;)s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */ base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i = 0, j = 0, t; // temporary
    while(start < end){
        var b = buffer[start++];
        switch(j){
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1) chunk[i++] = 61;
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
var invalidEncoding = "invalid encoding";
/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */ base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t; // temporary
    for(var i = 0; i < string.length;){
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1) break;
        if ((c = s64[c]) === undefined) throw Error(invalidEncoding);
        switch(j){
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1) throw Error(invalidEncoding);
    return offset - start;
};
/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */ base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};
}}),
"[project]/node_modules/@protobufjs/eventemitter/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = EventEmitter;
/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */ function EventEmitter() {
    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */ this._listeners = {};
}
/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn: fn,
        ctx: ctx || this
    });
    return this;
};
/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined) this._listeners = {};
    else {
        if (fn === undefined) this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for(var i = 0; i < listeners.length;)if (listeners[i].fn === fn) listeners.splice(i, 1);
            else ++i;
        }
    }
    return this;
};
/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [], i = 1;
        for(; i < arguments.length;)args.push(arguments[i++]);
        for(i = 0; i < listeners.length;)listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};
}}),
"[project]/node_modules/@protobufjs/float/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = factory(factory);
/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */ /**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ // Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {
    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([
            -0
        ]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */ exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }
        /* istanbul ignore next */ exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */ exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    // float: ieee754
    })();
    else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val)) writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }
        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([
            -0
        ]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */ exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }
        /* istanbul ignore next */ exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */ exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    // double: ieee754
    })();
    else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) {
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) {
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024) exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }
        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
    return exports;
}
// uint helpers
function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
}
function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}
function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
}
}}),
"[project]/node_modules/@protobufjs/inquire/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = inquire;
/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */ function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length)) return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}
}}),
"[project]/node_modules/@protobufjs/utf8/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var utf8 = exports;
/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */ utf8.length = function utf8_length(string) {
    var len = 0, c = 0;
    for(var i = 0; i < string.length; ++i){
        c = string.charCodeAt(i);
        if (c < 128) len += 1;
        else if (c < 2048) len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else len += 3;
    }
    return len;
};
/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */ utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1) return "";
    var parts = null, chunk = [], i = 0, t; // temporary
    while(start < end){
        t = buffer[start++];
        if (t < 128) chunk[i++] = t;
        else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */ utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2; // character 2
    for(var i = 0; i < string.length; ++i){
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        }
    }
    return offset - start;
};
}}),
"[project]/node_modules/@protobufjs/pool/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = pool;
/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ /**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */ /**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */ function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX) return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) offset = (offset | 7) + 1;
        return buf;
    };
}
}}),
"[project]/node_modules/protobufjs/src/util/longbits.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = LongBits;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */ function LongBits(lo, hi) {
    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.
    /**
     * Low bits.
     * @type {number}
     */ this.lo = lo >>> 0;
    /**
     * High bits.
     * @type {number}
     */ this.hi = hi >>> 0;
}
/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */ var zero = LongBits.zero = new LongBits(0, 0);
zero.toNumber = function() {
    return 0;
};
zero.zzEncode = zero.zzDecode = function() {
    return this;
};
zero.length = function() {
    return 1;
};
/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */ var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.fromNumber = function fromNumber(value) {
    if (value === 0) return zero;
    var sign = value < 0;
    if (sign) value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295) hi = 0;
        }
    }
    return new LongBits(lo, hi);
};
/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.from = function from(value) {
    if (typeof value === "number") return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);
        else return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};
/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */ LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo) hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};
/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */ LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
        low: this.lo | 0,
        high: this.hi | 0,
        unsigned: Boolean(unsigned)
    };
};
var charCodeAt = String.prototype.charCodeAt;
/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */ LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash) return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
};
/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */ LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
};
/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
};
/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
};
/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */ LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
};
}}),
"[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var util = exports;
// used to return a Promise where callback is omitted
util.asPromise = __turbopack_context__.r("[project]/node_modules/@protobufjs/aspromise/index.js [app-client] (ecmascript)");
// converts to / from base64 encoded strings
util.base64 = __turbopack_context__.r("[project]/node_modules/@protobufjs/base64/index.js [app-client] (ecmascript)");
// base class of rpc.Service
util.EventEmitter = __turbopack_context__.r("[project]/node_modules/@protobufjs/eventemitter/index.js [app-client] (ecmascript)");
// float handling accross browsers
util.float = __turbopack_context__.r("[project]/node_modules/@protobufjs/float/index.js [app-client] (ecmascript)");
// requires modules optionally and hides the call from bundlers
util.inquire = __turbopack_context__.r("[project]/node_modules/@protobufjs/inquire/index.js [app-client] (ecmascript)");
// converts to / from utf8 encoded strings
util.utf8 = __turbopack_context__.r("[project]/node_modules/@protobufjs/utf8/index.js [app-client] (ecmascript)");
// provides a node-like buffer pool in the browser
util.pool = __turbopack_context__.r("[project]/node_modules/@protobufjs/pool/index.js [app-client] (ecmascript)");
// utility to work with the low and high bits of a 64 bit value
util.LongBits = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/longbits.js [app-client] (ecmascript)");
/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */ util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */ util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || this; // eslint-disable-line no-invalid-this
/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes
/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes
/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};
/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */ util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};
/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */ util.isObject = function isObject(value) {
    return value && typeof value === "object";
};
/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isset = /**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};
/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */ /**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */ util.Buffer = function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */ return null;
    }
}();
// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;
// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;
/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */ util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */ return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
};
/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */ util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */  : Array;
/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */ /**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire("long");
/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */ util.key2Re = /^true|false|0|1$/;
/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */ util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
};
/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */ util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};
/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */ function merge(dst, src, ifNotSet) {
    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];
    return dst;
}
util.merge = merge;
/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */ util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};
/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */ function newError(name) {
    function CustomError(message, properties) {
        if (!(this instanceof CustomError)) return new CustomError(message, properties);
        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function
        Object.defineProperty(this, "message", {
            get: function() {
                return message;
            }
        });
        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);
        else Object.defineProperty(this, "stack", {
            value: new Error().stack || ""
        });
        if (properties) merge(this, properties);
    }
    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
    Object.defineProperty(CustomError.prototype, "name", {
        get: function() {
            return name;
        }
    });
    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };
    return CustomError;
}
util.newError = newError;
/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */ util.ProtocolError = newError("ProtocolError");
/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */ /**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */ /**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */ util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;
    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */ return function() {
        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];
    };
};
/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */ /**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */ util.oneOfSetter = function setOneOf(fieldNames) {
    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */ return function(name) {
        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];
    };
};
/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */ util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};
// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */ if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {
        return new Buffer(size);
    };
};
}}),
"[project]/node_modules/protobufjs/src/writer.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = Writer;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
var BufferWriter; // cyclic
var LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;
/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */ function Op(fn, len, val) {
    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */ this.fn = fn;
    /**
     * Value byte length.
     * @type {number}
     */ this.len = len;
    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */ this.next = undefined;
    /**
     * Value to write.
     * @type {*}
     */ this.val = val; // type varies
}
/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function
/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */ function State(writer) {
    /**
     * Current head.
     * @type {Writer.Op}
     */ this.head = writer.head;
    /**
     * Current tail.
     * @type {Writer.Op}
     */ this.tail = writer.tail;
    /**
     * Current buffer length.
     * @type {number}
     */ this.len = writer.len;
    /**
     * Next state.
     * @type {State|null}
     */ this.next = writer.states;
}
/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */ function Writer() {
    /**
     * Current length.
     * @type {number}
     */ this.len = 0;
    /**
     * Operations head.
     * @type {Object}
     */ this.head = new Op(noop, 0, 0);
    /**
     * Operations tail
     * @type {Object}
     */ this.tail = this.head;
    /**
     * Linked forked states.
     * @type {Object|null}
     */ this.states = null;
// When a value is written, the writer calculates its byte length and puts it into a linked
// list of operations to perform when finish() is called. This both allows us to allocate
// buffers of the exact required size and reduces the amount of work we have to do compared
// to first calculating over objects and then encoding over objects. In our case, the encoding
// part is just a linked list walk calling operations with already prepared values.
}
var create = function create() {
    return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    } : function create_array() {
        return new Writer();
    };
};
/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */ Writer.create = create();
/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ Writer.alloc = function alloc(size) {
    return new util.Array(size);
};
// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */ Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
    while(val > 127){
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */ function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
};
/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
     : this.uint32(value);
};
/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
    while(val.hi){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while(val.lo > 127){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.int64 = Writer.prototype.uint64;
/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};
/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;
/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;
/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};
/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};
var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos); // also works for plain array values
} : function writeBytes_for(val, buf, pos) {
    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];
};
/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */ Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len) return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};
/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
};
/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */ Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};
/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */ Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
    }
    return this;
};
/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */ Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};
/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */ Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while(head){
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};
Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};
}}),
"[project]/node_modules/protobufjs/src/writer_buffer.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = BufferWriter;
// extends Writer
var Writer = __turbopack_context__.r("[project]/node_modules/protobufjs/src/writer.js [app-client] (ecmascript)");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */ function BufferWriter() {
    Writer.call(this);
}
BufferWriter._configure = function() {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */ BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
    // also works for plain array values
    } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) val.copy(buf, pos, 0, val.length);
        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];
    };
};
/**
 * @override
 */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value)) value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};
function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) util.utf8.write(val, buf, pos);
    else if (buf.utf8Write) buf.utf8Write(val, pos);
    else buf.write(val, pos);
}
/**
 * @override
 */ BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len) this._push(writeStringBuffer, len, value);
    return this;
};
/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */ BufferWriter._configure();
}}),
"[project]/node_modules/protobufjs/src/reader.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = Reader;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
var BufferReader; // cyclic
var LongBits = util.LongBits, utf8 = util.utf8;
/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}
/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */ function Reader(buffer) {
    /**
     * Read buffer.
     * @type {Uint8Array}
     */ this.buf = buffer;
    /**
     * Read buffer position.
     * @type {number}
     */ this.pos = 0;
    /**
     * Read buffer length.
     * @type {number}
     */ this.len = buffer.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
} : function create_array(buffer) {
    if (Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
};
var create = function create() {
    return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);
        })(buffer);
    } : create_array;
};
/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */ Reader.create = create();
Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;
/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
}();
/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};
/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};
/* eslint-disable no-invalid-this */ function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
        for(; i < 4; ++i){
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) return bits;
        i = 0;
    } else {
        for(; i < 3; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) {
        for(; i < 5; ++i){
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    } else {
        for(; i < 5; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    }
    /* istanbul ignore next */ throw Error("invalid varint encoding");
}
/* eslint-enable no-invalid-this */ /**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */ Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};
function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
}
/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.fixed32 = function read_fixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
};
/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.sfixed32 = function read_sfixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
};
/* eslint-disable no-invalid-this */ function readFixed64() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
/* eslint-enable no-invalid-this */ /**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.float = function read_float() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};
/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.double = function read_double() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */ Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf)) return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
     ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
};
/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */ Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};
/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */ Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
        }while (this.buf[this.pos++] & 128)
    }
    return this;
};
/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */ Reader.prototype.skipType = function(wireType) {
    switch(wireType){
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while((wireType = this.uint32() & 7) !== 4){
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;
        /* istanbul ignore next */ default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};
Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {
        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }
    });
};
}}),
"[project]/node_modules/protobufjs/src/reader_buffer.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = BufferReader;
// extends Reader
var Reader = __turbopack_context__.r("[project]/node_modules/protobufjs/src/reader.js [app-client] (ecmascript)");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */ function BufferReader(buffer) {
    Reader.call(this, buffer);
/**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */ }
BufferReader._configure = function() {
    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;
};
/**
 * @override
 */ BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */ BufferReader._configure();
}}),
"[project]/node_modules/protobufjs/src/rpc/service.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = Service;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */ /**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */ /**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */ function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */ this.rpcImpl = rpcImpl;
    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */ this.requestDelimited = Boolean(requestDelimited);
    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */ this.responseDelimited = Boolean(responseDelimited);
}
/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request) throw TypeError("request must be specified");
    var self = this;
    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);
    if (!self.rpcImpl) {
        setTimeout(function() {
            callback(Error("already ended"));
        }, 0);
        return undefined;
    }
    try {
        return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
            if (err) {
                self.emit("error", err, method);
                return callback(err);
            }
            if (response === null) {
                self.end(/* endedByRPC */ true);
                return undefined;
            }
            if (!(response instanceof responseCtor)) {
                try {
                    response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }
            }
            self.emit("data", response, method);
            return callback(null, response);
        });
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() {
            callback(err);
        }, 0);
        return undefined;
    }
};
/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */ Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};
}}),
"[project]/node_modules/protobufjs/src/rpc.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Streaming RPC helpers.
 * @namespace
 */ var rpc = exports;
/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */ /**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */ rpc.Service = __turbopack_context__.r("[project]/node_modules/protobufjs/src/rpc/service.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/protobufjs/src/roots.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = {}; /**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */ 
}}),
"[project]/node_modules/protobufjs/src/index-minimal.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var protobuf = exports;
/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */ protobuf.build = "minimal";
// Serialization
protobuf.Writer = __turbopack_context__.r("[project]/node_modules/protobufjs/src/writer.js [app-client] (ecmascript)");
protobuf.BufferWriter = __turbopack_context__.r("[project]/node_modules/protobufjs/src/writer_buffer.js [app-client] (ecmascript)");
protobuf.Reader = __turbopack_context__.r("[project]/node_modules/protobufjs/src/reader.js [app-client] (ecmascript)");
protobuf.BufferReader = __turbopack_context__.r("[project]/node_modules/protobufjs/src/reader_buffer.js [app-client] (ecmascript)");
// Utility
protobuf.util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
protobuf.rpc = __turbopack_context__.r("[project]/node_modules/protobufjs/src/rpc.js [app-client] (ecmascript)");
protobuf.roots = __turbopack_context__.r("[project]/node_modules/protobufjs/src/roots.js [app-client] (ecmascript)");
protobuf.configure = configure;
/* istanbul ignore next */ /**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */ function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}
// Set up buffer utility according to the environment
configure();
}}),
"[project]/node_modules/protobufjs/minimal.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// minimal library entry point.
"use strict";
module.exports = __turbopack_context__.r("[project]/node_modules/protobufjs/src/index-minimal.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/node-fetch/browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// ref: https://github.com/tc39/proposal-global
var getGlobal = function() {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('unable to locate global object');
};
var globalObject = getGlobal();
module.exports = exports = globalObject.fetch;
// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
    exports.default = globalObject.fetch.bind(globalObject);
}
exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;
}}),
"[project]/node_modules/@babel/runtime/helpers/arrayWithHoles.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
        var e, n, i, u, a = [], f = !0, o = !1;
        try {
            if (i = (t = t.call(r)).next, 0 === l) {
                if (Object(t) !== t) return;
                f = !1;
            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
            o = !0, n = r;
        } finally{
            try {
                if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally{
                if (o) throw n;
            }
        }
        return a;
    }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/arrayLikeToArray.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var arrayLikeToArray = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/arrayLikeToArray.js [app-client] (ecmascript)");
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
    }
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/nonIterableRest.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/slicedToArray.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var arrayWithHoles = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/arrayWithHoles.js [app-client] (ecmascript)");
var iterableToArrayLimit = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js [app-client] (ecmascript)");
var unsupportedIterableToArray = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js [app-client] (ecmascript)");
var nonIterableRest = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/nonIterableRest.js [app-client] (ecmascript)");
function _slicedToArray(r, e) {
    return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/classCallCheck.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/typeof.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
function _typeof(o) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/toPrimitive.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var _typeof = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/typeof.js [app-client] (ecmascript)")["default"];
function toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/toPropertyKey.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var _typeof = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/typeof.js [app-client] (ecmascript)")["default"];
var toPrimitive = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toPrimitive.js [app-client] (ecmascript)");
function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/runtime/helpers/createClass.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var toPropertyKey = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toPropertyKey.js [app-client] (ecmascript)");
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/automation-events/build/es5/bundle.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? factory(exports, __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/slicedToArray.js [app-client] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/classCallCheck.js [app-client] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createClass.js [app-client] (ecmascript)")) : ("TURBOPACK unreachable", undefined);
})(this, function(exports1, _slicedToArray, _classCallCheck, _createClass) {
    'use strict';
    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {
        return {
            endTime: endTime,
            insertTime: insertTime,
            type: 'exponentialRampToValue',
            value: value
        };
    };
    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {
        return {
            endTime: endTime,
            insertTime: insertTime,
            type: 'linearRampToValue',
            value: value
        };
    };
    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {
        return {
            startTime: startTime,
            type: 'setValue',
            value: value
        };
    };
    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {
        return {
            duration: duration,
            startTime: startTime,
            type: 'setValueCurve',
            values: values
        };
    };
    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {
        var startTime = _ref.startTime, target = _ref.target, timeConstant = _ref.timeConstant;
        return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);
    };
    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {
        return automationEvent.type === 'exponentialRampToValue';
    };
    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {
        return automationEvent.type === 'linearRampToValue';
    };
    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {
        return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);
    };
    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {
        return automationEvent.type === 'setValue';
    };
    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {
        return automationEvent.type === 'setValueCurve';
    };
    var _getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {
        var automationEvent = automationEvents[index];
        return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, _getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);
    };
    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {
        return currentAutomationEvent === undefined ? [
            nextAutomationEvent.insertTime,
            defaultValue
        ] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [
            currentAutomationEvent.endTime,
            currentAutomationEvent.value
        ] : isSetValueAutomationEvent(currentAutomationEvent) ? [
            currentAutomationEvent.startTime,
            currentAutomationEvent.value
        ] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [
            currentAutomationEvent.startTime + currentAutomationEvent.duration,
            currentAutomationEvent.values[currentAutomationEvent.values.length - 1]
        ] : [
            currentAutomationEvent.startTime,
            _getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)
        ];
    };
    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {
        return automationEvent.type === 'cancelAndHold';
    };
    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {
        return automationEvent.type === 'cancelScheduledValues';
    };
    var getEventTime = function getEventTime(automationEvent) {
        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
            return automationEvent.cancelTime;
        }
        if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {
            return automationEvent.endTime;
        }
        return automationEvent.startTime;
    };
    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {
        var endTime = _ref.endTime, value = _ref.value;
        if (valueAtStartTime === value) {
            return value;
        }
        if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {
            return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));
        }
        return 0;
    };
    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {
        var endTime = _ref.endTime, value = _ref.value;
        return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);
    };
    var interpolateValue = function interpolateValue(values, theoreticIndex) {
        var lowerIndex = Math.floor(theoreticIndex);
        var upperIndex = Math.ceil(theoreticIndex);
        if (lowerIndex === upperIndex) {
            return values[lowerIndex];
        }
        return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];
    };
    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {
        var duration = _ref.duration, startTime = _ref.startTime, values = _ref.values;
        var theoreticIndex = (time - startTime) / duration * (values.length - 1);
        return interpolateValue(values, theoreticIndex);
    };
    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {
        return automationEvent.type === 'setTarget';
    };
    var AutomationEventList = /*#__PURE__*/ function() {
        function AutomationEventList(defaultValue) {
            _classCallCheck(this, AutomationEventList);
            this._automationEvents = [];
            this._currenTime = 0;
            this._defaultValue = defaultValue;
        }
        return _createClass(AutomationEventList, [
            {
                key: Symbol.iterator,
                value: function value() {
                    return this._automationEvents[Symbol.iterator]();
                }
            },
            {
                key: "add",
                value: function add(automationEvent) {
                    var eventTime = getEventTime(automationEvent);
                    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
                        var index = this._automationEvents.findIndex(function(currentAutomationEvent) {
                            if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {
                                return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;
                            }
                            return getEventTime(currentAutomationEvent) >= eventTime;
                        });
                        var removedAutomationEvent = this._automationEvents[index];
                        if (index !== -1) {
                            this._automationEvents = this._automationEvents.slice(0, index);
                        }
                        if (isCancelAndHoldAutomationEvent(automationEvent)) {
                            var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];
                            if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {
                                if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {
                                    throw new Error('The internal list is malformed.');
                                }
                                var startTime = lastAutomationEvent === undefined ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);
                                var startValue = lastAutomationEvent === undefined ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;
                                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);
                                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);
                                this._automationEvents.push(truncatedAutomationEvent);
                            }
                            if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {
                                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));
                            }
                            if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {
                                var duration = eventTime - lastAutomationEvent.startTime;
                                var ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;
                                var length = Math.max(2, 1 + Math.ceil(duration * ratio));
                                var fraction = duration / (length - 1) * ratio;
                                var values = lastAutomationEvent.values.slice(0, length);
                                if (fraction < 1) {
                                    for(var i = 1; i < length; i += 1){
                                        var factor = fraction * i % 1;
                                        values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;
                                    }
                                }
                                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);
                            }
                        }
                    } else {
                        var _index = this._automationEvents.findIndex(function(currentAutomationEvent) {
                            return getEventTime(currentAutomationEvent) > eventTime;
                        });
                        var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];
                        if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {
                            return false;
                        }
                        var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;
                        if (_index === -1) {
                            this._automationEvents.push(persistentAutomationEvent);
                        } else {
                            if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {
                                return false;
                            }
                            this._automationEvents.splice(_index, 0, persistentAutomationEvent);
                        }
                    }
                    return true;
                }
            },
            {
                key: "flush",
                value: function flush(time) {
                    var index = this._automationEvents.findIndex(function(currentAutomationEvent) {
                        return getEventTime(currentAutomationEvent) > time;
                    });
                    if (index > 1) {
                        var remainingAutomationEvents = this._automationEvents.slice(index - 1);
                        var firstRemainingAutomationEvent = remainingAutomationEvents[0];
                        if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {
                            remainingAutomationEvents.unshift(createSetValueAutomationEvent(_getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));
                        }
                        this._automationEvents = remainingAutomationEvents;
                    }
                }
            },
            {
                key: "getValue",
                value: function getValue(time) {
                    if (this._automationEvents.length === 0) {
                        return this._defaultValue;
                    }
                    var indexOfNextEvent = this._automationEvents.findIndex(function(automationEvent) {
                        return getEventTime(automationEvent) > time;
                    });
                    var nextAutomationEvent = this._automationEvents[indexOfNextEvent];
                    var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;
                    var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];
                    if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {
                        return getTargetValueAtTime(time, _getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);
                    }
                    if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
                        return currentAutomationEvent.value;
                    }
                    if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {
                        if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {
                            return getValueCurveValueAtTime(time, currentAutomationEvent);
                        }
                        return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];
                    }
                    if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
                        return currentAutomationEvent.value;
                    }
                    if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {
                        var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue), _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2), startTime = _getEndTimeAndValueOf2[0], value = _getEndTimeAndValueOf2[1];
                        return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);
                    }
                    if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {
                        var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue), _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2), _startTime = _getEndTimeAndValueOf4[0], _value = _getEndTimeAndValueOf4[1];
                        return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);
                    }
                    return this._defaultValue;
                }
            }
        ]);
    }();
    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {
        return {
            cancelTime: cancelTime,
            type: 'cancelAndHold'
        };
    };
    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {
        return {
            cancelTime: cancelTime,
            type: 'cancelScheduledValues'
        };
    };
    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {
        return {
            endTime: endTime,
            type: 'exponentialRampToValue',
            value: value
        };
    };
    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {
        return {
            endTime: endTime,
            type: 'linearRampToValue',
            value: value
        };
    };
    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {
        return {
            startTime: startTime,
            target: target,
            timeConstant: timeConstant,
            type: 'setTarget'
        };
    };
    exports1.AutomationEventList = AutomationEventList;
    exports1.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;
    exports1.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;
    exports1.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;
    exports1.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;
    exports1.createSetTargetAutomationEvent = createSetTargetAutomationEvent;
    exports1.createSetValueAutomationEvent = createSetValueAutomationEvent;
    exports1.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;
});
}}),
"[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ __turbopack_context__.s({
    "__addDisposableResource": (()=>__addDisposableResource),
    "__assign": (()=>__assign),
    "__asyncDelegator": (()=>__asyncDelegator),
    "__asyncGenerator": (()=>__asyncGenerator),
    "__asyncValues": (()=>__asyncValues),
    "__await": (()=>__await),
    "__awaiter": (()=>__awaiter),
    "__classPrivateFieldGet": (()=>__classPrivateFieldGet),
    "__classPrivateFieldIn": (()=>__classPrivateFieldIn),
    "__classPrivateFieldSet": (()=>__classPrivateFieldSet),
    "__createBinding": (()=>__createBinding),
    "__decorate": (()=>__decorate),
    "__disposeResources": (()=>__disposeResources),
    "__esDecorate": (()=>__esDecorate),
    "__exportStar": (()=>__exportStar),
    "__extends": (()=>__extends),
    "__generator": (()=>__generator),
    "__importDefault": (()=>__importDefault),
    "__importStar": (()=>__importStar),
    "__makeTemplateObject": (()=>__makeTemplateObject),
    "__metadata": (()=>__metadata),
    "__param": (()=>__param),
    "__propKey": (()=>__propKey),
    "__read": (()=>__read),
    "__rest": (()=>__rest),
    "__rewriteRelativeImportExtension": (()=>__rewriteRelativeImportExtension),
    "__runInitializers": (()=>__runInitializers),
    "__setFunctionName": (()=>__setFunctionName),
    "__spread": (()=>__spread),
    "__spreadArray": (()=>__spreadArray),
    "__spreadArrays": (()=>__spreadArrays),
    "__values": (()=>__values),
    "default": (()=>__TURBOPACK__default__export__)
});
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
;
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
}
;
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
;
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
;
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    "TURBOPACK unreachable";
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    "TURBOPACK unreachable";
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    "TURBOPACK unreachable";
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    "TURBOPACK unreachable";
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
            value: raw
        });
    } else {
        cooked.raw = raw;
    }
    return cooked;
}
;
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop()){
            try {
                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                if (r.dispose) {
                    var result = r.dispose.call(r.value);
                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                        fail(e);
                        return next();
                    });
                } else s |= 1;
            } catch (e) {
                fail(e);
            }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
    }
    return path;
}
const __TURBOPACK__default__export__ = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
};
}}),
"[project]/node_modules/midi-file/lib/midi-parser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// data can be any array-like object.  It just needs to support .length, .slice, and an element getter []
function parseMidi(data) {
    var p = new Parser(data);
    var headerChunk = p.readChunk();
    if (headerChunk.id != 'MThd') throw "Bad MIDI file.  Expected 'MHdr', got: '" + headerChunk.id + "'";
    var header = parseHeader(headerChunk.data);
    var tracks = [];
    for(var i = 0; !p.eof() && i < header.numTracks; i++){
        var trackChunk = p.readChunk();
        if (trackChunk.id != 'MTrk') throw "Bad MIDI file.  Expected 'MTrk', got: '" + trackChunk.id + "'";
        var track = parseTrack(trackChunk.data);
        tracks.push(track);
    }
    return {
        header: header,
        tracks: tracks
    };
}
function parseHeader(data) {
    var p = new Parser(data);
    var format = p.readUInt16();
    var numTracks = p.readUInt16();
    var result = {
        format: format,
        numTracks: numTracks
    };
    var timeDivision = p.readUInt16();
    if (timeDivision & 0x8000) {
        result.framesPerSecond = 0x100 - (timeDivision >> 8);
        result.ticksPerFrame = timeDivision & 0xFF;
    } else {
        result.ticksPerBeat = timeDivision;
    }
    return result;
}
function parseTrack(data) {
    var p = new Parser(data);
    var events = [];
    while(!p.eof()){
        var event = readEvent();
        events.push(event);
    }
    return events;
    "TURBOPACK unreachable";
    var lastEventTypeByte;
    function readEvent() {
        var event = {};
        event.deltaTime = p.readVarInt();
        var eventTypeByte = p.readUInt8();
        if ((eventTypeByte & 0xf0) === 0xf0) {
            // system / meta event
            if (eventTypeByte === 0xff) {
                // meta event
                event.meta = true;
                var metatypeByte = p.readUInt8();
                var length = p.readVarInt();
                switch(metatypeByte){
                    case 0x00:
                        event.type = 'sequenceNumber';
                        if (length !== 2) throw "Expected length for sequenceNumber event is 2, got " + length;
                        event.number = p.readUInt16();
                        return event;
                    case 0x01:
                        event.type = 'text';
                        event.text = p.readString(length);
                        return event;
                    case 0x02:
                        event.type = 'copyrightNotice';
                        event.text = p.readString(length);
                        return event;
                    case 0x03:
                        event.type = 'trackName';
                        event.text = p.readString(length);
                        return event;
                    case 0x04:
                        event.type = 'instrumentName';
                        event.text = p.readString(length);
                        return event;
                    case 0x05:
                        event.type = 'lyrics';
                        event.text = p.readString(length);
                        return event;
                    case 0x06:
                        event.type = 'marker';
                        event.text = p.readString(length);
                        return event;
                    case 0x07:
                        event.type = 'cuePoint';
                        event.text = p.readString(length);
                        return event;
                    case 0x20:
                        event.type = 'channelPrefix';
                        if (length != 1) throw "Expected length for channelPrefix event is 1, got " + length;
                        event.channel = p.readUInt8();
                        return event;
                    case 0x21:
                        event.type = 'portPrefix';
                        if (length != 1) throw "Expected length for portPrefix event is 1, got " + length;
                        event.port = p.readUInt8();
                        return event;
                    case 0x2f:
                        event.type = 'endOfTrack';
                        if (length != 0) throw "Expected length for endOfTrack event is 0, got " + length;
                        return event;
                    case 0x51:
                        event.type = 'setTempo';
                        if (length != 3) throw "Expected length for setTempo event is 3, got " + length;
                        event.microsecondsPerBeat = p.readUInt24();
                        return event;
                    case 0x54:
                        event.type = 'smpteOffset';
                        if (length != 5) throw "Expected length for smpteOffset event is 5, got " + length;
                        var hourByte = p.readUInt8();
                        var FRAME_RATES = {
                            0x00: 24,
                            0x20: 25,
                            0x40: 29,
                            0x60: 30
                        };
                        event.frameRate = FRAME_RATES[hourByte & 0x60];
                        event.hour = hourByte & 0x1f;
                        event.min = p.readUInt8();
                        event.sec = p.readUInt8();
                        event.frame = p.readUInt8();
                        event.subFrame = p.readUInt8();
                        return event;
                    case 0x58:
                        event.type = 'timeSignature';
                        if (length != 2 && length != 4) throw "Expected length for timeSignature event is 4 or 2, got " + length;
                        event.numerator = p.readUInt8();
                        event.denominator = 1 << p.readUInt8();
                        if (length === 4) {
                            event.metronome = p.readUInt8();
                            event.thirtyseconds = p.readUInt8();
                        } else {
                            event.metronome = 0x24;
                            event.thirtyseconds = 0x08;
                        }
                        return event;
                    case 0x59:
                        event.type = 'keySignature';
                        if (length != 2) throw "Expected length for keySignature event is 2, got " + length;
                        event.key = p.readInt8();
                        event.scale = p.readUInt8();
                        return event;
                    case 0x7f:
                        event.type = 'sequencerSpecific';
                        event.data = p.readBytes(length);
                        return event;
                    default:
                        event.type = 'unknownMeta';
                        event.data = p.readBytes(length);
                        event.metatypeByte = metatypeByte;
                        return event;
                }
            } else if (eventTypeByte == 0xf0) {
                event.type = 'sysEx';
                var length = p.readVarInt();
                event.data = p.readBytes(length);
                return event;
            } else if (eventTypeByte == 0xf7) {
                event.type = 'endSysEx';
                var length = p.readVarInt();
                event.data = p.readBytes(length);
                return event;
            } else {
                throw "Unrecognised MIDI event type byte: " + eventTypeByte;
            }
        } else {
            // channel event
            var param1;
            if ((eventTypeByte & 0x80) === 0) {
                // running status - reuse lastEventTypeByte as the event type.
                // eventTypeByte is actually the first parameter
                if (lastEventTypeByte === null) throw "Running status byte encountered before status byte";
                param1 = eventTypeByte;
                eventTypeByte = lastEventTypeByte;
                event.running = true;
            } else {
                param1 = p.readUInt8();
                lastEventTypeByte = eventTypeByte;
            }
            var eventType = eventTypeByte >> 4;
            event.channel = eventTypeByte & 0x0f;
            switch(eventType){
                case 0x08:
                    event.type = 'noteOff';
                    event.noteNumber = param1;
                    event.velocity = p.readUInt8();
                    return event;
                case 0x09:
                    var velocity = p.readUInt8();
                    event.type = velocity === 0 ? 'noteOff' : 'noteOn';
                    event.noteNumber = param1;
                    event.velocity = velocity;
                    if (velocity === 0) event.byte9 = true;
                    return event;
                case 0x0a:
                    event.type = 'noteAftertouch';
                    event.noteNumber = param1;
                    event.amount = p.readUInt8();
                    return event;
                case 0x0b:
                    event.type = 'controller';
                    event.controllerType = param1;
                    event.value = p.readUInt8();
                    return event;
                case 0x0c:
                    event.type = 'programChange';
                    event.programNumber = param1;
                    return event;
                case 0x0d:
                    event.type = 'channelAftertouch';
                    event.amount = param1;
                    return event;
                case 0x0e:
                    event.type = 'pitchBend';
                    event.value = param1 + (p.readUInt8() << 7) - 0x2000;
                    return event;
                default:
                    throw "Unrecognised MIDI event type: " + eventType;
            }
        }
    }
}
function Parser(data) {
    this.buffer = data;
    this.bufferLen = this.buffer.length;
    this.pos = 0;
}
Parser.prototype.eof = function() {
    return this.pos >= this.bufferLen;
};
Parser.prototype.readUInt8 = function() {
    var result = this.buffer[this.pos];
    this.pos += 1;
    return result;
};
Parser.prototype.readInt8 = function() {
    var u = this.readUInt8();
    if (u & 0x80) return u - 0x100;
    else return u;
};
Parser.prototype.readUInt16 = function() {
    var b0 = this.readUInt8(), b1 = this.readUInt8();
    return (b0 << 8) + b1;
};
Parser.prototype.readInt16 = function() {
    var u = this.readUInt16();
    if (u & 0x8000) return u - 0x10000;
    else return u;
};
Parser.prototype.readUInt24 = function() {
    var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8();
    return (b0 << 16) + (b1 << 8) + b2;
};
Parser.prototype.readInt24 = function() {
    var u = this.readUInt24();
    if (u & 0x800000) return u - 0x1000000;
    else return u;
};
Parser.prototype.readUInt32 = function() {
    var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8(), b3 = this.readUInt8();
    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
};
Parser.prototype.readBytes = function(len) {
    var bytes = this.buffer.slice(this.pos, this.pos + len);
    this.pos += len;
    return bytes;
};
Parser.prototype.readString = function(len) {
    var bytes = this.readBytes(len);
    return String.fromCharCode.apply(null, bytes);
};
Parser.prototype.readVarInt = function() {
    var result = 0;
    while(!this.eof()){
        var b = this.readUInt8();
        if (b & 0x80) {
            result += b & 0x7f;
            result <<= 7;
        } else {
            // b is last byte
            return result + b;
        }
    }
    // premature eof
    return result;
};
Parser.prototype.readChunk = function() {
    var id = this.readString(4);
    var length = this.readUInt32();
    var data = this.readBytes(length);
    return {
        id: id,
        length: length,
        data: data
    };
};
module.exports = parseMidi;
}}),
"[project]/node_modules/midi-file/lib/midi-writer.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// data should be the same type of format returned by parseMidi
// for maximum compatibililty, returns an array of byte values, suitable for conversion to Buffer, Uint8Array, etc.
// opts:
// - running              reuse previous eventTypeByte when possible, to compress file
// - useByte9ForNoteOff   use 0x09 for noteOff when velocity is zero
function writeMidi(data, opts) {
    if (typeof data !== 'object') throw 'Invalid MIDI data';
    opts = opts || {};
    var header = data.header || {};
    var tracks = data.tracks || [];
    var i, len = tracks.length;
    var w = new Writer();
    writeHeader(w, header, len);
    for(i = 0; i < len; i++){
        writeTrack(w, tracks[i], opts);
    }
    return w.buffer;
}
function writeHeader(w, header, numTracks) {
    var format = header.format == null ? 1 : header.format;
    var timeDivision = 128;
    if (header.timeDivision) {
        timeDivision = header.timeDivision;
    } else if (header.ticksPerFrame && header.framesPerSecond) {
        timeDivision = -(header.framesPerSecond & 0xFF) << 8 | header.ticksPerFrame & 0xFF;
    } else if (header.ticksPerBeat) {
        timeDivision = header.ticksPerBeat & 0x7FFF;
    }
    var h = new Writer();
    h.writeUInt16(format);
    h.writeUInt16(numTracks);
    h.writeUInt16(timeDivision);
    w.writeChunk('MThd', h.buffer);
}
function writeTrack(w, track, opts) {
    var t = new Writer();
    var i, len = track.length;
    var eventTypeByte = null;
    for(i = 0; i < len; i++){
        // Reuse last eventTypeByte when opts.running is set, or event.running is explicitly set on it.
        // parseMidi will set event.running for each event, so that we can get an exact copy by default.
        // Explicitly set opts.running to false, to override event.running and never reuse last eventTypeByte.
        if (opts.running === false || !opts.running && !track[i].running) eventTypeByte = null;
        eventTypeByte = writeEvent(t, track[i], eventTypeByte, opts.useByte9ForNoteOff);
    }
    w.writeChunk('MTrk', t.buffer);
}
function writeEvent(w, event, lastEventTypeByte, useByte9ForNoteOff) {
    var type = event.type;
    var deltaTime = event.deltaTime;
    var text = event.text || '';
    var data = event.data || [];
    var eventTypeByte = null;
    w.writeVarInt(deltaTime);
    switch(type){
        // meta events
        case 'sequenceNumber':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x00);
            w.writeVarInt(2);
            w.writeUInt16(event.number);
            break;
        case 'text':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x01);
            w.writeVarInt(text.length);
            w.writeString(text);
            break;
        case 'copyrightNotice':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x02);
            w.writeVarInt(text.length);
            w.writeString(text);
            break;
        case 'trackName':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x03);
            w.writeVarInt(text.length);
            w.writeString(text);
            break;
        case 'instrumentName':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x04);
            w.writeVarInt(text.length);
            w.writeString(text);
            break;
        case 'lyrics':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x05);
            w.writeVarInt(text.length);
            w.writeString(text);
            break;
        case 'marker':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x06);
            w.writeVarInt(text.length);
            w.writeString(text);
            break;
        case 'cuePoint':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x07);
            w.writeVarInt(text.length);
            w.writeString(text);
            break;
        case 'channelPrefix':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x20);
            w.writeVarInt(1);
            w.writeUInt8(event.channel);
            break;
        case 'portPrefix':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x21);
            w.writeVarInt(1);
            w.writeUInt8(event.port);
            break;
        case 'endOfTrack':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x2F);
            w.writeVarInt(0);
            break;
        case 'setTempo':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x51);
            w.writeVarInt(3);
            w.writeUInt24(event.microsecondsPerBeat);
            break;
        case 'smpteOffset':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x54);
            w.writeVarInt(5);
            var FRAME_RATES = {
                24: 0x00,
                25: 0x20,
                29: 0x40,
                30: 0x60
            };
            var hourByte = event.hour & 0x1F | FRAME_RATES[event.frameRate];
            w.writeUInt8(hourByte);
            w.writeUInt8(event.min);
            w.writeUInt8(event.sec);
            w.writeUInt8(event.frame);
            w.writeUInt8(event.subFrame);
            break;
        case 'timeSignature':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x58);
            w.writeVarInt(4);
            w.writeUInt8(event.numerator);
            var denominator = Math.floor(Math.log(event.denominator) / Math.LN2) & 0xFF;
            w.writeUInt8(denominator);
            w.writeUInt8(event.metronome);
            w.writeUInt8(event.thirtyseconds || 8);
            break;
        case 'keySignature':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x59);
            w.writeVarInt(2);
            w.writeInt8(event.key);
            w.writeUInt8(event.scale);
            break;
        case 'sequencerSpecific':
            w.writeUInt8(0xFF);
            w.writeUInt8(0x7F);
            w.writeVarInt(data.length);
            w.writeBytes(data);
            break;
        case 'unknownMeta':
            if (event.metatypeByte != null) {
                w.writeUInt8(0xFF);
                w.writeUInt8(event.metatypeByte);
                w.writeVarInt(data.length);
                w.writeBytes(data);
            }
            break;
        // system-exclusive
        case 'sysEx':
            w.writeUInt8(0xF0);
            w.writeVarInt(data.length);
            w.writeBytes(data);
            break;
        case 'endSysEx':
            w.writeUInt8(0xF7);
            w.writeVarInt(data.length);
            w.writeBytes(data);
            break;
        // channel events
        case 'noteOff':
            // Use 0x90 when opts.useByte9ForNoteOff is set and velocity is zero, or when event.byte9 is explicitly set on it.
            // parseMidi will set event.byte9 for each event, so that we can get an exact copy by default.
            // Explicitly set opts.useByte9ForNoteOff to false, to override event.byte9 and always use 0x80 for noteOff events.
            var noteByte = useByte9ForNoteOff !== false && event.byte9 || useByte9ForNoteOff && event.velocity == 0 ? 0x90 : 0x80;
            eventTypeByte = noteByte | event.channel;
            if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
            w.writeUInt8(event.noteNumber);
            w.writeUInt8(event.velocity);
            break;
        case 'noteOn':
            eventTypeByte = 0x90 | event.channel;
            if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
            w.writeUInt8(event.noteNumber);
            w.writeUInt8(event.velocity);
            break;
        case 'noteAftertouch':
            eventTypeByte = 0xA0 | event.channel;
            if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
            w.writeUInt8(event.noteNumber);
            w.writeUInt8(event.amount);
            break;
        case 'controller':
            eventTypeByte = 0xB0 | event.channel;
            if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
            w.writeUInt8(event.controllerType);
            w.writeUInt8(event.value);
            break;
        case 'programChange':
            eventTypeByte = 0xC0 | event.channel;
            if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
            w.writeUInt8(event.programNumber);
            break;
        case 'channelAftertouch':
            eventTypeByte = 0xD0 | event.channel;
            if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
            w.writeUInt8(event.amount);
            break;
        case 'pitchBend':
            eventTypeByte = 0xE0 | event.channel;
            if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
            var value14 = 0x2000 + event.value;
            var lsb14 = value14 & 0x7F;
            var msb14 = value14 >> 7 & 0x7F;
            w.writeUInt8(lsb14);
            w.writeUInt8(msb14);
            break;
        default:
            throw 'Unrecognized event type: ' + type;
    }
    return eventTypeByte;
}
function Writer() {
    this.buffer = [];
}
Writer.prototype.writeUInt8 = function(v) {
    this.buffer.push(v & 0xFF);
};
Writer.prototype.writeInt8 = Writer.prototype.writeUInt8;
Writer.prototype.writeUInt16 = function(v) {
    var b0 = v >> 8 & 0xFF, b1 = v & 0xFF;
    this.writeUInt8(b0);
    this.writeUInt8(b1);
};
Writer.prototype.writeInt16 = Writer.prototype.writeUInt16;
Writer.prototype.writeUInt24 = function(v) {
    var b0 = v >> 16 & 0xFF, b1 = v >> 8 & 0xFF, b2 = v & 0xFF;
    this.writeUInt8(b0);
    this.writeUInt8(b1);
    this.writeUInt8(b2);
};
Writer.prototype.writeInt24 = Writer.prototype.writeUInt24;
Writer.prototype.writeUInt32 = function(v) {
    var b0 = v >> 24 & 0xFF, b1 = v >> 16 & 0xFF, b2 = v >> 8 & 0xFF, b3 = v & 0xFF;
    this.writeUInt8(b0);
    this.writeUInt8(b1);
    this.writeUInt8(b2);
    this.writeUInt8(b3);
};
Writer.prototype.writeInt32 = Writer.prototype.writeUInt32;
Writer.prototype.writeBytes = function(arr) {
    this.buffer = this.buffer.concat(Array.prototype.slice.call(arr, 0));
};
Writer.prototype.writeString = function(str) {
    var i, len = str.length, arr = [];
    for(i = 0; i < len; i++){
        arr.push(str.codePointAt(i));
    }
    this.writeBytes(arr);
};
Writer.prototype.writeVarInt = function(v) {
    if (v < 0) throw "Cannot write negative variable-length integer";
    if (v <= 0x7F) {
        this.writeUInt8(v);
    } else {
        var i = v;
        var bytes = [];
        bytes.push(i & 0x7F);
        i >>= 7;
        while(i){
            var b = i & 0x7F | 0x80;
            bytes.push(b);
            i >>= 7;
        }
        this.writeBytes(bytes.reverse());
    }
};
Writer.prototype.writeChunk = function(id, data) {
    this.writeString(id);
    this.writeUInt32(data.length);
    this.writeBytes(data);
};
module.exports = writeMidi;
}}),
"[project]/node_modules/midi-file/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
exports.parseMidi = __turbopack_context__.r("[project]/node_modules/midi-file/lib/midi-parser.js [app-client] (ecmascript)");
exports.writeMidi = __turbopack_context__.r("[project]/node_modules/midi-file/lib/midi-writer.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/@tonejs/midi/dist/BinarySearch.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.insert = exports.search = void 0;
/**
 * Return the index of the element at or before the given property
 * @hidden
 */ function search(array, value, prop) {
    if (prop === void 0) {
        prop = "ticks";
    }
    var beginning = 0;
    var len = array.length;
    var end = len;
    if (len > 0 && array[len - 1][prop] <= value) {
        return len - 1;
    }
    while(beginning < end){
        // calculate the midpoint for roughly equal partition
        var midPoint = Math.floor(beginning + (end - beginning) / 2);
        var event_1 = array[midPoint];
        var nextEvent = array[midPoint + 1];
        if (event_1[prop] === value) {
            // choose the last one that has the same value
            for(var i = midPoint; i < array.length; i++){
                var testEvent = array[i];
                if (testEvent[prop] === value) {
                    midPoint = i;
                }
            }
            return midPoint;
        } else if (event_1[prop] < value && nextEvent[prop] > value) {
            return midPoint;
        } else if (event_1[prop] > value) {
            // search lower
            end = midPoint;
        } else if (event_1[prop] < value) {
            // search upper
            beginning = midPoint + 1;
        }
    }
    return -1;
}
exports.search = search;
/**
 * Does a binary search to insert the note
 * in the correct spot in the array
 * @hidden
 */ function insert(array, event, prop) {
    if (prop === void 0) {
        prop = "ticks";
    }
    if (array.length) {
        var index = search(array, event[prop], prop);
        array.splice(index + 1, 0, event);
    } else {
        array.push(event);
    }
}
exports.insert = insert; //# sourceMappingURL=BinarySearch.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/Header.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Header = exports.keySignatureKeys = void 0;
var BinarySearch_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/BinarySearch.js [app-client] (ecmascript)");
var privatePPQMap = new WeakMap();
/**
 * @hidden
 */ exports.keySignatureKeys = [
    "Cb",
    "Gb",
    "Db",
    "Ab",
    "Eb",
    "Bb",
    "F",
    "C",
    "G",
    "D",
    "A",
    "E",
    "B",
    "F#",
    "C#"
];
/**
 * The parsed MIDI file header.
 */ var Header = function() {
    function Header(midiData) {
        var _this = this;
        /**
         * The array of all the tempo events.
         */ this.tempos = [];
        /**
         * The time signatures.
         */ this.timeSignatures = [];
        /**
         * The time signatures.
         */ this.keySignatures = [];
        /**
         * Additional meta events.
         */ this.meta = [];
        /**
         * The name of the MIDI file;
         */ this.name = "";
        // Look through all the tracks for tempo changes.
        privatePPQMap.set(this, 480);
        if (midiData) {
            privatePPQMap.set(this, midiData.header.ticksPerBeat);
            // Check time signature and tempo events from all of the tracks.
            midiData.tracks.forEach(function(track) {
                track.forEach(function(event) {
                    if (event.meta) {
                        if (event.type === "timeSignature") {
                            _this.timeSignatures.push({
                                ticks: event.absoluteTime,
                                timeSignature: [
                                    event.numerator,
                                    event.denominator
                                ]
                            });
                        } else if (event.type === "setTempo") {
                            _this.tempos.push({
                                bpm: 60000000 / event.microsecondsPerBeat,
                                ticks: event.absoluteTime
                            });
                        } else if (event.type === "keySignature") {
                            _this.keySignatures.push({
                                key: exports.keySignatureKeys[event.key + 7],
                                scale: event.scale === 0 ? "major" : "minor",
                                ticks: event.absoluteTime
                            });
                        }
                    }
                });
            });
            // Check the first track for other relevant data.
            var firstTrackCurrentTicks_1 = 0; // Used for absolute times.
            midiData.tracks[0].forEach(function(event) {
                firstTrackCurrentTicks_1 += event.deltaTime;
                if (event.meta) {
                    if (event.type === "trackName") {
                        _this.name = event.text;
                    } else if (event.type === "text" || event.type === "cuePoint" || event.type === "marker" || event.type === "lyrics") {
                        _this.meta.push({
                            text: event.text,
                            ticks: firstTrackCurrentTicks_1,
                            type: event.type
                        });
                    }
                }
            });
            this.update();
        }
    }
    /**
     * This must be invoked after any changes are made to the tempo array
     * or the timeSignature array for the updated values to be reflected.
     */ Header.prototype.update = function() {
        var _this = this;
        var currentTime = 0;
        var lastEventBeats = 0;
        // Make sure it's sorted;
        this.tempos.sort(function(a, b) {
            return a.ticks - b.ticks;
        });
        this.tempos.forEach(function(event, index) {
            var lastBPM = index > 0 ? _this.tempos[index - 1].bpm : _this.tempos[0].bpm;
            var beats = event.ticks / _this.ppq - lastEventBeats;
            var elapsedSeconds = 60 / lastBPM * beats;
            event.time = elapsedSeconds + currentTime;
            currentTime = event.time;
            lastEventBeats += beats;
        });
        this.timeSignatures.sort(function(a, b) {
            return a.ticks - b.ticks;
        });
        this.timeSignatures.forEach(function(event, index) {
            var lastEvent = index > 0 ? _this.timeSignatures[index - 1] : _this.timeSignatures[0];
            var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;
            var elapsedMeasures = elapsedBeats / lastEvent.timeSignature[0] / (lastEvent.timeSignature[1] / 4);
            lastEvent.measures = lastEvent.measures || 0;
            event.measures = elapsedMeasures + lastEvent.measures;
        });
    };
    /**
     * Convert ticks into seconds based on the tempo changes.
     */ Header.prototype.ticksToSeconds = function(ticks) {
        // Find the relevant position.
        var index = (0, BinarySearch_1.search)(this.tempos, ticks);
        if (index !== -1) {
            var tempo = this.tempos[index];
            var tempoTime = tempo.time;
            var elapsedBeats = (ticks - tempo.ticks) / this.ppq;
            return tempoTime + 60 / tempo.bpm * elapsedBeats;
        } else {
            // Assume 120.
            var beats = ticks / this.ppq;
            return 60 / 120 * beats;
        }
    };
    /**
     * Convert ticks into measures based off of the time signatures.
     */ Header.prototype.ticksToMeasures = function(ticks) {
        var index = (0, BinarySearch_1.search)(this.timeSignatures, ticks);
        if (index !== -1) {
            var timeSigEvent = this.timeSignatures[index];
            var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;
            return timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;
        } else {
            return ticks / this.ppq / 4;
        }
    };
    Object.defineProperty(Header.prototype, "ppq", {
        /**
         * The number of ticks per quarter note.
         */ get: function() {
            return privatePPQMap.get(this);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Convert seconds to ticks based on the tempo events.
     */ Header.prototype.secondsToTicks = function(seconds) {
        // Find the relevant position.
        var index = (0, BinarySearch_1.search)(this.tempos, seconds, "time");
        if (index !== -1) {
            var tempo = this.tempos[index];
            var tempoTime = tempo.time;
            var elapsedTime = seconds - tempoTime;
            var elapsedBeats = elapsedTime / (60 / tempo.bpm);
            return Math.round(tempo.ticks + elapsedBeats * this.ppq);
        } else {
            // Assume 120.
            var beats = seconds / (60 / 120);
            return Math.round(beats * this.ppq);
        }
    };
    /**
     * Convert the header into an object.
     */ Header.prototype.toJSON = function() {
        return {
            keySignatures: this.keySignatures,
            meta: this.meta,
            name: this.name,
            ppq: this.ppq,
            tempos: this.tempos.map(function(t) {
                return {
                    bpm: t.bpm,
                    ticks: t.ticks
                };
            }),
            timeSignatures: this.timeSignatures
        };
    };
    /**
     * Parse a header json object.
     */ Header.prototype.fromJSON = function(json) {
        this.name = json.name;
        // Clone all the attributes.
        this.tempos = json.tempos.map(function(t) {
            return Object.assign({}, t);
        });
        this.timeSignatures = json.timeSignatures.map(function(t) {
            return Object.assign({}, t);
        });
        this.keySignatures = json.keySignatures.map(function(t) {
            return Object.assign({}, t);
        });
        this.meta = json.meta.map(function(t) {
            return Object.assign({}, t);
        });
        privatePPQMap.set(this, json.ppq);
        this.update();
    };
    /**
     * Update the tempo of the midi to a single tempo. Will remove and replace
     * any other tempos currently set and update all of the event timing.
     * @param bpm The tempo in beats per second.
     */ Header.prototype.setTempo = function(bpm) {
        this.tempos = [
            {
                bpm: bpm,
                ticks: 0
            }
        ];
        this.update();
    };
    return Header;
}();
exports.Header = Header; //# sourceMappingURL=Header.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/ControlChange.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ControlChange = exports.controlChangeIds = exports.controlChangeNames = void 0;
/**
 * A map of values to control change names
 * @hidden
 */ exports.controlChangeNames = {
    1: "modulationWheel",
    2: "breath",
    4: "footController",
    5: "portamentoTime",
    7: "volume",
    8: "balance",
    10: "pan",
    64: "sustain",
    65: "portamentoTime",
    66: "sostenuto",
    67: "softPedal",
    68: "legatoFootswitch",
    84: "portamentoControl"
};
/**
 * swap the keys and values
 * @hidden
 */ exports.controlChangeIds = Object.keys(exports.controlChangeNames).reduce(function(obj, key) {
    obj[exports.controlChangeNames[key]] = key;
    return obj;
}, {});
var privateHeaderMap = new WeakMap();
var privateCCNumberMap = new WeakMap();
/**
 * Represents a control change event
 */ var ControlChange = function() {
    /**
     * @param event
     * @param header
     */ function ControlChange(event, header) {
        privateHeaderMap.set(this, header);
        privateCCNumberMap.set(this, event.controllerType);
        this.ticks = event.absoluteTime;
        this.value = event.value;
    }
    Object.defineProperty(ControlChange.prototype, "number", {
        /**
         * The controller number
         */ get: function() {
            return privateCCNumberMap.get(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ControlChange.prototype, "name", {
        /**
         * return the common name of the control number if it exists
         */ get: function() {
            if (exports.controlChangeNames[this.number]) {
                return exports.controlChangeNames[this.number];
            } else {
                return null;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ControlChange.prototype, "time", {
        /**
         * The time of the event in seconds
         */ get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
        },
        set: function(t) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t);
        },
        enumerable: false,
        configurable: true
    });
    ControlChange.prototype.toJSON = function() {
        return {
            number: this.number,
            ticks: this.ticks,
            time: this.time,
            value: this.value
        };
    };
    return ControlChange;
}();
exports.ControlChange = ControlChange; //# sourceMappingURL=ControlChange.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/ControlChanges.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createControlChanges = void 0;
var ControlChange_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/ControlChange.js [app-client] (ecmascript)");
/**
 * Automatically creates an alias for named control values using Proxies
 * @hidden
 */ function createControlChanges() {
    return new Proxy({}, {
        // tslint:disable-next-line: typedef
        get: function(target, handler) {
            if (target[handler]) {
                return target[handler];
            } else if (ControlChange_1.controlChangeIds.hasOwnProperty(handler)) {
                return target[ControlChange_1.controlChangeIds[handler]];
            }
        },
        // tslint:disable-next-line: typedef
        set: function(target, handler, value) {
            if (ControlChange_1.controlChangeIds.hasOwnProperty(handler)) {
                target[ControlChange_1.controlChangeIds[handler]] = value;
            } else {
                target[handler] = value;
            }
            return true;
        }
    });
}
exports.createControlChanges = createControlChanges; //# sourceMappingURL=ControlChanges.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/PitchBend.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PitchBend = void 0;
var privateHeaderMap = new WeakMap();
/**
 * Represents a pitch bend event.
 */ var PitchBend = function() {
    /**
     * @param event
     * @param header
     */ function PitchBend(event, header) {
        privateHeaderMap.set(this, header);
        this.ticks = event.absoluteTime;
        this.value = event.value;
    }
    Object.defineProperty(PitchBend.prototype, "time", {
        /**
         * The time of the event in seconds
         */ get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
        },
        set: function(t) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t);
        },
        enumerable: false,
        configurable: true
    });
    PitchBend.prototype.toJSON = function() {
        return {
            ticks: this.ticks,
            time: this.time,
            value: this.value
        };
    };
    return PitchBend;
}();
exports.PitchBend = PitchBend; //# sourceMappingURL=PitchBend.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/InstrumentMaps.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DrumKitByPatchID = exports.InstrumentFamilyByID = exports.instrumentByPatchID = void 0;
exports.instrumentByPatchID = [
    "acoustic grand piano",
    "bright acoustic piano",
    "electric grand piano",
    "honky-tonk piano",
    "electric piano 1",
    "electric piano 2",
    "harpsichord",
    "clavi",
    "celesta",
    "glockenspiel",
    "music box",
    "vibraphone",
    "marimba",
    "xylophone",
    "tubular bells",
    "dulcimer",
    "drawbar organ",
    "percussive organ",
    "rock organ",
    "church organ",
    "reed organ",
    "accordion",
    "harmonica",
    "tango accordion",
    "acoustic guitar (nylon)",
    "acoustic guitar (steel)",
    "electric guitar (jazz)",
    "electric guitar (clean)",
    "electric guitar (muted)",
    "overdriven guitar",
    "distortion guitar",
    "guitar harmonics",
    "acoustic bass",
    "electric bass (finger)",
    "electric bass (pick)",
    "fretless bass",
    "slap bass 1",
    "slap bass 2",
    "synth bass 1",
    "synth bass 2",
    "violin",
    "viola",
    "cello",
    "contrabass",
    "tremolo strings",
    "pizzicato strings",
    "orchestral harp",
    "timpani",
    "string ensemble 1",
    "string ensemble 2",
    "synthstrings 1",
    "synthstrings 2",
    "choir aahs",
    "voice oohs",
    "synth voice",
    "orchestra hit",
    "trumpet",
    "trombone",
    "tuba",
    "muted trumpet",
    "french horn",
    "brass section",
    "synthbrass 1",
    "synthbrass 2",
    "soprano sax",
    "alto sax",
    "tenor sax",
    "baritone sax",
    "oboe",
    "english horn",
    "bassoon",
    "clarinet",
    "piccolo",
    "flute",
    "recorder",
    "pan flute",
    "blown bottle",
    "shakuhachi",
    "whistle",
    "ocarina",
    "lead 1 (square)",
    "lead 2 (sawtooth)",
    "lead 3 (calliope)",
    "lead 4 (chiff)",
    "lead 5 (charang)",
    "lead 6 (voice)",
    "lead 7 (fifths)",
    "lead 8 (bass + lead)",
    "pad 1 (new age)",
    "pad 2 (warm)",
    "pad 3 (polysynth)",
    "pad 4 (choir)",
    "pad 5 (bowed)",
    "pad 6 (metallic)",
    "pad 7 (halo)",
    "pad 8 (sweep)",
    "fx 1 (rain)",
    "fx 2 (soundtrack)",
    "fx 3 (crystal)",
    "fx 4 (atmosphere)",
    "fx 5 (brightness)",
    "fx 6 (goblins)",
    "fx 7 (echoes)",
    "fx 8 (sci-fi)",
    "sitar",
    "banjo",
    "shamisen",
    "koto",
    "kalimba",
    "bag pipe",
    "fiddle",
    "shanai",
    "tinkle bell",
    "agogo",
    "steel drums",
    "woodblock",
    "taiko drum",
    "melodic tom",
    "synth drum",
    "reverse cymbal",
    "guitar fret noise",
    "breath noise",
    "seashore",
    "bird tweet",
    "telephone ring",
    "helicopter",
    "applause",
    "gunshot"
];
exports.InstrumentFamilyByID = [
    "piano",
    "chromatic percussion",
    "organ",
    "guitar",
    "bass",
    "strings",
    "ensemble",
    "brass",
    "reed",
    "pipe",
    "synth lead",
    "synth pad",
    "synth effects",
    "world",
    "percussive",
    "sound effects"
];
exports.DrumKitByPatchID = {
    0: "standard kit",
    8: "room kit",
    16: "power kit",
    24: "electronic kit",
    25: "tr-808 kit",
    32: "jazz kit",
    40: "brush kit",
    48: "orchestra kit",
    56: "sound fx kit"
}; //# sourceMappingURL=InstrumentMaps.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/Instrument.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Instrument = void 0;
var InstrumentMaps_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/InstrumentMaps.js [app-client] (ecmascript)");
/**
 * @hidden
 */ var privateTrackMap = new WeakMap();
/**
 * Describes the MIDI instrument of a track.
 */ var Instrument = function() {
    /**
     * @param trackData
     * @param track
     */ function Instrument(trackData, track) {
        /**
         * The instrument number. Defaults to 0.
         */ this.number = 0;
        privateTrackMap.set(this, track);
        this.number = 0;
        if (trackData) {
            var programChange = trackData.find(function(e) {
                return e.type === "programChange";
            });
            // Set 'number' from 'programNumber' if exists.
            if (programChange) {
                this.number = programChange.programNumber;
            }
        }
    }
    Object.defineProperty(Instrument.prototype, "name", {
        /**
         * The common name of the instrument.
         */ get: function() {
            if (this.percussion) {
                return InstrumentMaps_1.DrumKitByPatchID[this.number];
            } else {
                return InstrumentMaps_1.instrumentByPatchID[this.number];
            }
        },
        set: function(n) {
            var patchNumber = InstrumentMaps_1.instrumentByPatchID.indexOf(n);
            if (patchNumber !== -1) {
                this.number = patchNumber;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Instrument.prototype, "family", {
        /**
         * The instrument family, e.g. "piano".
         */ get: function() {
            if (this.percussion) {
                return "drums";
            } else {
                return InstrumentMaps_1.InstrumentFamilyByID[Math.floor(this.number / 8)];
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Instrument.prototype, "percussion", {
        /**
         * If the instrument is a percussion instrument.
         */ get: function() {
            var track = privateTrackMap.get(this);
            return track.channel === 9;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Convert it to JSON form.
     */ Instrument.prototype.toJSON = function() {
        return {
            family: this.family,
            number: this.number,
            name: this.name
        };
    };
    /**
     * Convert from JSON form.
     */ Instrument.prototype.fromJSON = function(json) {
        this.number = json.number;
    };
    return Instrument;
}();
exports.Instrument = Instrument; //# sourceMappingURL=Instrument.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/Note.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Note = void 0;
/**
 * Convert a MIDI note into a pitch.
 */ function midiToPitch(midi) {
    var octave = Math.floor(midi / 12) - 1;
    return midiToPitchClass(midi) + octave.toString();
}
/**
 * Convert a MIDI note to a pitch class (just the pitch no octave).
 */ function midiToPitchClass(midi) {
    var scaleIndexToNote = [
        "C",
        "C#",
        "D",
        "D#",
        "E",
        "F",
        "F#",
        "G",
        "G#",
        "A",
        "A#",
        "B"
    ];
    var note = midi % 12;
    return scaleIndexToNote[note];
}
/**
 * Convert a pitch class to a MIDI note.
 */ function pitchClassToMidi(pitch) {
    var scaleIndexToNote = [
        "C",
        "C#",
        "D",
        "D#",
        "E",
        "F",
        "F#",
        "G",
        "G#",
        "A",
        "A#",
        "B"
    ];
    return scaleIndexToNote.indexOf(pitch);
}
/**
 * Convert a pitch to a MIDI number.
 */ // tslint:disable-next-line: only-arrow-functions typedef
var pitchToMidi = function() {
    var regexp = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;
    var noteToScaleIndex = {
        // tslint:disable-next-line: object-literal-sort-keys
        cbb: -2,
        cb: -1,
        c: 0,
        "c#": 1,
        cx: 2,
        dbb: 0,
        db: 1,
        d: 2,
        "d#": 3,
        dx: 4,
        ebb: 2,
        eb: 3,
        e: 4,
        "e#": 5,
        ex: 6,
        fbb: 3,
        fb: 4,
        f: 5,
        "f#": 6,
        fx: 7,
        gbb: 5,
        gb: 6,
        g: 7,
        "g#": 8,
        gx: 9,
        abb: 7,
        ab: 8,
        a: 9,
        "a#": 10,
        ax: 11,
        bbb: 9,
        bb: 10,
        b: 11,
        "b#": 12,
        bx: 13
    };
    return function(note) {
        var split = regexp.exec(note);
        var pitch = split[1];
        var octave = split[2];
        var index = noteToScaleIndex[pitch.toLowerCase()];
        return index + (parseInt(octave, 10) + 1) * 12;
    };
}();
var privateHeaderMap = new WeakMap();
/**
 * A Note consists of a `noteOn` and `noteOff` event.
 */ var Note = function() {
    function Note(noteOn, noteOff, header) {
        privateHeaderMap.set(this, header);
        this.midi = noteOn.midi;
        this.velocity = noteOn.velocity;
        this.noteOffVelocity = noteOff.velocity;
        this.ticks = noteOn.ticks;
        this.durationTicks = noteOff.ticks - noteOn.ticks;
    }
    Object.defineProperty(Note.prototype, "name", {
        /**
         * The note name and octave in scientific pitch notation, e.g. "C4".
         */ get: function() {
            return midiToPitch(this.midi);
        },
        set: function(n) {
            this.midi = pitchToMidi(n);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Note.prototype, "octave", {
        /**
         * The notes octave number.
         */ get: function() {
            return Math.floor(this.midi / 12) - 1;
        },
        set: function(o) {
            var diff = o - this.octave;
            this.midi += diff * 12;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Note.prototype, "pitch", {
        /**
         * The pitch class name. e.g. "A".
         */ get: function() {
            return midiToPitchClass(this.midi);
        },
        set: function(p) {
            this.midi = 12 * (this.octave + 1) + pitchClassToMidi(p);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Note.prototype, "duration", {
        /**
         * The duration of the segment in seconds.
         */ get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks + this.durationTicks) - header.ticksToSeconds(this.ticks);
        },
        set: function(d) {
            var header = privateHeaderMap.get(this);
            var noteEndTicks = header.secondsToTicks(this.time + d);
            this.durationTicks = noteEndTicks - this.ticks;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Note.prototype, "time", {
        /**
         * The time of the event in seconds.
         */ get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
        },
        set: function(t) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Note.prototype, "bars", {
        /**
         * The number of measures (and partial measures) to this beat.
         * Takes into account time signature changes.
         * @readonly
         */ get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToMeasures(this.ticks);
        },
        enumerable: false,
        configurable: true
    });
    Note.prototype.toJSON = function() {
        return {
            duration: this.duration,
            durationTicks: this.durationTicks,
            midi: this.midi,
            name: this.name,
            ticks: this.ticks,
            time: this.time,
            velocity: this.velocity
        };
    };
    return Note;
}();
exports.Note = Note; //# sourceMappingURL=Note.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/Track.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Track = void 0;
var BinarySearch_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/BinarySearch.js [app-client] (ecmascript)");
var ControlChange_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/ControlChange.js [app-client] (ecmascript)");
var ControlChanges_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/ControlChanges.js [app-client] (ecmascript)");
var PitchBend_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/PitchBend.js [app-client] (ecmascript)");
var Instrument_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/Instrument.js [app-client] (ecmascript)");
var Note_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/Note.js [app-client] (ecmascript)");
var privateHeaderMap = new WeakMap();
/**
 * A Track is a collection of 'notes' and 'controlChanges'.
 */ var Track = function() {
    function Track(trackData, header) {
        var _this = this;
        /**
         * The name of the track.
         */ this.name = "";
        /**
         * The track's note events.
         */ this.notes = [];
        /**
         * The control change events.
         */ this.controlChanges = (0, ControlChanges_1.createControlChanges)();
        /**
         * The pitch bend events.
         */ this.pitchBends = [];
        privateHeaderMap.set(this, header);
        if (trackData) {
            // Get the name of the track.
            var nameEvent = trackData.find(function(e) {
                return e.type === "trackName";
            });
            // Set empty name if 'trackName' event isn't found.
            this.name = nameEvent ? nameEvent.text : "";
        }
        this.instrument = new Instrument_1.Instrument(trackData, this);
        // Defaults to 0.
        this.channel = 0;
        if (trackData) {
            var noteOns = trackData.filter(function(event) {
                return event.type === "noteOn";
            });
            var noteOffs = trackData.filter(function(event) {
                return event.type === "noteOff";
            });
            var _loop_1 = function() {
                var currentNote = noteOns.shift();
                // Set the channel based on the note.
                this_1.channel = currentNote.channel;
                // Find the corresponding note off.
                var offIndex = noteOffs.findIndex(function(note) {
                    return note.noteNumber === currentNote.noteNumber && note.absoluteTime >= currentNote.absoluteTime;
                });
                if (offIndex !== -1) {
                    // Once it's got the note off, add it.
                    var noteOff = noteOffs.splice(offIndex, 1)[0];
                    this_1.addNote({
                        durationTicks: noteOff.absoluteTime - currentNote.absoluteTime,
                        midi: currentNote.noteNumber,
                        noteOffVelocity: noteOff.velocity / 127,
                        ticks: currentNote.absoluteTime,
                        velocity: currentNote.velocity / 127
                    });
                }
            };
            var this_1 = this;
            while(noteOns.length){
                _loop_1();
            }
            var controlChanges = trackData.filter(function(event) {
                return event.type === "controller";
            });
            controlChanges.forEach(function(event) {
                _this.addCC({
                    number: event.controllerType,
                    ticks: event.absoluteTime,
                    value: event.value / 127
                });
            });
            var pitchBends = trackData.filter(function(event) {
                return event.type === "pitchBend";
            });
            pitchBends.forEach(function(event) {
                _this.addPitchBend({
                    ticks: event.absoluteTime,
                    // Scale the value between -2^13 to 2^13 to -2 to 2.
                    value: event.value / Math.pow(2, 13)
                });
            });
            var endOfTrackEvent = trackData.find(function(event) {
                return event.type === "endOfTrack";
            });
            this.endOfTrackTicks = endOfTrackEvent !== undefined ? endOfTrackEvent.absoluteTime : undefined;
        }
    }
    /**
     * Add a note to the notes array.
     * @param props The note properties to add.
     */ Track.prototype.addNote = function(props) {
        var header = privateHeaderMap.get(this);
        var note = new Note_1.Note({
            midi: 0,
            ticks: 0,
            velocity: 1
        }, {
            ticks: 0,
            velocity: 0
        }, header);
        Object.assign(note, props);
        (0, BinarySearch_1.insert)(this.notes, note, "ticks");
        return this;
    };
    /**
     * Add a control change to the track.
     * @param props
     */ Track.prototype.addCC = function(props) {
        var header = privateHeaderMap.get(this);
        var cc = new ControlChange_1.ControlChange({
            controllerType: props.number
        }, header);
        delete props.number;
        Object.assign(cc, props);
        if (!Array.isArray(this.controlChanges[cc.number])) {
            this.controlChanges[cc.number] = [];
        }
        (0, BinarySearch_1.insert)(this.controlChanges[cc.number], cc, "ticks");
        return this;
    };
    /**
     * Add a control change to the track.
     */ Track.prototype.addPitchBend = function(props) {
        var header = privateHeaderMap.get(this);
        var pb = new PitchBend_1.PitchBend({}, header);
        Object.assign(pb, props);
        (0, BinarySearch_1.insert)(this.pitchBends, pb, "ticks");
        return this;
    };
    Object.defineProperty(Track.prototype, "duration", {
        /**
         * The end time of the last event in the track.
         */ get: function() {
            if (!this.notes.length) {
                return 0;
            }
            var maxDuration = this.notes[this.notes.length - 1].time + this.notes[this.notes.length - 1].duration;
            for(var i = 0; i < this.notes.length - 1; i++){
                var duration = this.notes[i].time + this.notes[i].duration;
                if (maxDuration < duration) {
                    maxDuration = duration;
                }
            }
            return maxDuration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Track.prototype, "durationTicks", {
        /**
         * The end time of the last event in the track in ticks.
         */ get: function() {
            if (!this.notes.length) {
                return 0;
            }
            var maxDuration = this.notes[this.notes.length - 1].ticks + this.notes[this.notes.length - 1].durationTicks;
            for(var i = 0; i < this.notes.length - 1; i++){
                var duration = this.notes[i].ticks + this.notes[i].durationTicks;
                if (maxDuration < duration) {
                    maxDuration = duration;
                }
            }
            return maxDuration;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Assign the JSON values to this track.
     */ Track.prototype.fromJSON = function(json) {
        var _this = this;
        this.name = json.name;
        this.channel = json.channel;
        this.instrument = new Instrument_1.Instrument(undefined, this);
        this.instrument.fromJSON(json.instrument);
        if (json.endOfTrackTicks !== undefined) {
            this.endOfTrackTicks = json.endOfTrackTicks;
        }
        for(var number in json.controlChanges){
            if (json.controlChanges[number]) {
                json.controlChanges[number].forEach(function(cc) {
                    _this.addCC({
                        number: cc.number,
                        ticks: cc.ticks,
                        value: cc.value
                    });
                });
            }
        }
        json.notes.forEach(function(n) {
            _this.addNote({
                durationTicks: n.durationTicks,
                midi: n.midi,
                ticks: n.ticks,
                velocity: n.velocity
            });
        });
    };
    /**
     * Convert the track into a JSON format.
     */ Track.prototype.toJSON = function() {
        // Convert all the CCs to JSON.
        var controlChanges = {};
        for(var i = 0; i < 127; i++){
            if (this.controlChanges.hasOwnProperty(i)) {
                controlChanges[i] = this.controlChanges[i].map(function(c) {
                    return c.toJSON();
                });
            }
        }
        var json = {
            channel: this.channel,
            controlChanges: controlChanges,
            pitchBends: this.pitchBends.map(function(pb) {
                return pb.toJSON();
            }),
            instrument: this.instrument.toJSON(),
            name: this.name,
            notes: this.notes.map(function(n) {
                return n.toJSON();
            })
        };
        if (this.endOfTrackTicks !== undefined) {
            json.endOfTrackTicks = this.endOfTrackTicks;
        }
        return json;
    };
    return Track;
}();
exports.Track = Track; //# sourceMappingURL=Track.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/Encode.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encode = void 0;
var midi_file_1 = __turbopack_context__.r("[project]/node_modules/midi-file/index.js [app-client] (ecmascript)");
var Header_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/Header.js [app-client] (ecmascript)");
var array_flatten_1 = __turbopack_context__.r("[project]/node_modules/array-flatten/dist.es2015/index.js [app-client] (ecmascript)");
function encodeNote(note, channel) {
    return [
        {
            absoluteTime: note.ticks,
            channel: channel,
            deltaTime: 0,
            noteNumber: note.midi,
            type: "noteOn",
            velocity: Math.floor(note.velocity * 127)
        },
        {
            absoluteTime: note.ticks + note.durationTicks,
            channel: channel,
            deltaTime: 0,
            noteNumber: note.midi,
            type: "noteOff",
            velocity: Math.floor(note.noteOffVelocity * 127)
        }
    ];
}
function encodeNotes(track) {
    return (0, array_flatten_1.flatten)(track.notes.map(function(note) {
        return encodeNote(note, track.channel);
    }));
}
function encodeControlChange(cc, channel) {
    return {
        absoluteTime: cc.ticks,
        channel: channel,
        controllerType: cc.number,
        deltaTime: 0,
        type: "controller",
        value: Math.floor(cc.value * 127)
    };
}
function encodeControlChanges(track) {
    var controlChanges = [];
    for(var i = 0; i < 127; i++){
        if (track.controlChanges.hasOwnProperty(i)) {
            track.controlChanges[i].forEach(function(cc) {
                controlChanges.push(encodeControlChange(cc, track.channel));
            });
        }
    }
    return controlChanges;
}
function encodePitchBend(pb, channel) {
    return {
        absoluteTime: pb.ticks,
        channel: channel,
        deltaTime: 0,
        type: "pitchBend",
        value: pb.value
    };
}
function encodePitchBends(track) {
    var pitchBends = [];
    track.pitchBends.forEach(function(pb) {
        pitchBends.push(encodePitchBend(pb, track.channel));
    });
    return pitchBends;
}
function encodeInstrument(track) {
    return {
        absoluteTime: 0,
        channel: track.channel,
        deltaTime: 0,
        programNumber: track.instrument.number,
        type: "programChange"
    };
}
function encodeTrackName(name) {
    return {
        absoluteTime: 0,
        deltaTime: 0,
        meta: true,
        text: name,
        type: "trackName"
    };
}
function encodeTempo(tempo) {
    return {
        absoluteTime: tempo.ticks,
        deltaTime: 0,
        meta: true,
        microsecondsPerBeat: Math.floor(60000000 / tempo.bpm),
        type: "setTempo"
    };
}
function encodeTimeSignature(timeSig) {
    return {
        absoluteTime: timeSig.ticks,
        deltaTime: 0,
        denominator: timeSig.timeSignature[1],
        meta: true,
        metronome: 24,
        numerator: timeSig.timeSignature[0],
        thirtyseconds: 8,
        type: "timeSignature"
    };
}
// function encodeMeta(event: )
function encodeKeySignature(keySig) {
    var keyIndex = Header_1.keySignatureKeys.indexOf(keySig.key);
    return {
        absoluteTime: keySig.ticks,
        deltaTime: 0,
        key: keyIndex + 7,
        meta: true,
        scale: keySig.scale === "major" ? 0 : 1,
        type: "keySignature"
    };
}
function encodeText(textEvent) {
    return {
        absoluteTime: textEvent.ticks,
        deltaTime: 0,
        meta: true,
        text: textEvent.text,
        type: textEvent.type
    };
}
/**
 * Convert the MIDI object to an array.
 */ function encode(midi) {
    var midiData = {
        header: {
            format: 1,
            numTracks: midi.tracks.length + 1,
            ticksPerBeat: midi.header.ppq
        },
        tracks: __spreadArray([
            __spreadArray(__spreadArray(__spreadArray(__spreadArray([
                // The name data.
                {
                    absoluteTime: 0,
                    deltaTime: 0,
                    meta: true,
                    text: midi.header.name,
                    type: "trackName"
                }
            ], midi.header.keySignatures.map(function(keySig) {
                return encodeKeySignature(keySig);
            }), true), midi.header.meta.map(function(e) {
                return encodeText(e);
            }), true), midi.header.tempos.map(function(tempo) {
                return encodeTempo(tempo);
            }), true), midi.header.timeSignatures.map(function(timeSig) {
                return encodeTimeSignature(timeSig);
            }), true)
        ], midi.tracks.map(function(track) {
            return __spreadArray(__spreadArray(__spreadArray([
                // Add the name
                encodeTrackName(track.name),
                // the instrument
                encodeInstrument(track)
            ], encodeNotes(track), true), encodeControlChanges(track), true), encodePitchBends(track), true);
        }), true)
    };
    // Sort and set `deltaTime` of all of the tracks.
    midiData.tracks = midiData.tracks.map(function(track) {
        track = track.sort(function(a, b) {
            return a.absoluteTime - b.absoluteTime;
        });
        var lastTime = 0;
        track.forEach(function(note) {
            note.deltaTime = note.absoluteTime - lastTime;
            lastTime = note.absoluteTime;
            delete note.absoluteTime;
        });
        // End of track.
        track.push({
            deltaTime: 0,
            meta: true,
            type: "endOfTrack"
        });
        return track;
    });
    // Rreturn `midiData`.
    return new Uint8Array((0, midi_file_1.writeMidi)(midiData));
}
exports.encode = encode; //# sourceMappingURL=Encode.js.map
}}),
"[project]/node_modules/@tonejs/midi/dist/Midi.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    "TURBOPACK unreachable";
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Header = exports.Track = exports.Midi = void 0;
var midi_file_1 = __turbopack_context__.r("[project]/node_modules/midi-file/index.js [app-client] (ecmascript)");
var Header_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/Header.js [app-client] (ecmascript)");
var Track_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/Track.js [app-client] (ecmascript)");
var Encode_1 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/Encode.js [app-client] (ecmascript)");
/**
 * The main midi parsing class.
 */ var Midi = function() {
    /**
     * Parse the midi data
     */ function Midi(midiArray) {
        var _this = this;
        // Parse the MIDI data if there is any.
        var midiData = null;
        if (midiArray) {
            // Transform midiArray to ArrayLike<number>
            // only if it's an ArrayBuffer.
            var midiArrayLike = midiArray instanceof ArrayBuffer ? new Uint8Array(midiArray) : midiArray;
            // Parse MIDI data.
            midiData = (0, midi_file_1.parseMidi)(midiArrayLike);
            // Add the absolute times to each of the tracks.
            midiData.tracks.forEach(function(track) {
                var currentTicks = 0;
                track.forEach(function(event) {
                    currentTicks += event.deltaTime;
                    event.absoluteTime = currentTicks;
                });
            });
            // Ensure at most one instrument per track.
            midiData.tracks = splitTracks(midiData.tracks);
        }
        this.header = new Header_1.Header(midiData);
        this.tracks = [];
        // Parse MIDI data.
        if (midiArray) {
            // Format 0, everything is on the same track.
            this.tracks = midiData.tracks.map(function(trackData) {
                return new Track_1.Track(trackData, _this.header);
            });
            // If it's format 1 and there are no notes on the first track, remove it.
            if (midiData.header.format === 1 && this.tracks[0].duration === 0) {
                this.tracks.shift();
            }
        }
    }
    /**
     * Download and parse the MIDI file. Returns a promise
     * which resolves to the generated MIDI file.
     * @param url The URL to fetch.
     */ Midi.fromUrl = function(url) {
        return __awaiter(this, void 0, void 0, function() {
            var response, arrayBuffer;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            fetch(url)
                        ];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            response.arrayBuffer()
                        ];
                    case 2:
                        arrayBuffer = _a.sent();
                        return [
                            2 /*return*/ ,
                            new Midi(arrayBuffer)
                        ];
                    case 3:
                        throw new Error("Could not load '".concat(url, "'"));
                }
            });
        });
    };
    Object.defineProperty(Midi.prototype, "name", {
        /**
         * The name of the midi file, taken from the first track.
         */ get: function() {
            return this.header.name;
        },
        set: function(n) {
            this.header.name = n;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Midi.prototype, "duration", {
        /**
         * The total length of the file in seconds.
         */ get: function() {
            // Get the max of the last note of all the tracks.
            var durations = this.tracks.map(function(t) {
                return t.duration;
            });
            return Math.max.apply(Math, durations);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Midi.prototype, "durationTicks", {
        /**
         * The total length of the file in ticks.
         */ get: function() {
            // Get the max of the last note of all the tracks.
            var durationTicks = this.tracks.map(function(t) {
                return t.durationTicks;
            });
            return Math.max.apply(Math, durationTicks);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add a track to the MIDI file.
     */ Midi.prototype.addTrack = function() {
        var track = new Track_1.Track(undefined, this.header);
        this.tracks.push(track);
        return track;
    };
    /**
     * Encode the MIDI as a Uint8Array.
     */ Midi.prototype.toArray = function() {
        return (0, Encode_1.encode)(this);
    };
    /**
     * Convert the MIDI object to JSON.
     */ Midi.prototype.toJSON = function() {
        return {
            header: this.header.toJSON(),
            tracks: this.tracks.map(function(track) {
                return track.toJSON();
            })
        };
    };
    /**
     * Parse a JSON representation of the object. Will overwrite the current
     * tracks and header.
     */ Midi.prototype.fromJSON = function(json) {
        var _this = this;
        this.header = new Header_1.Header();
        this.header.fromJSON(json.header);
        this.tracks = json.tracks.map(function(trackJSON) {
            var track = new Track_1.Track(undefined, _this.header);
            track.fromJSON(trackJSON);
            return track;
        });
    };
    /**
     * Clone the entire object MIDI object.
     */ Midi.prototype.clone = function() {
        var midi = new Midi();
        midi.fromJSON(this.toJSON());
        return midi;
    };
    return Midi;
}();
exports.Midi = Midi;
var Track_2 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/Track.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Track", {
    enumerable: true,
    get: function() {
        return Track_2.Track;
    }
});
var Header_2 = __turbopack_context__.r("[project]/node_modules/@tonejs/midi/dist/Header.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Header", {
    enumerable: true,
    get: function() {
        return Header_2.Header;
    }
});
/**
 * Given a list of MIDI tracks, make sure that each channel corresponds to at
 * most one channel and at most one instrument. This means splitting up tracks
 * that contain more than one channel or instrument.
 */ function splitTracks(tracks) {
    var newTracks = [];
    for(var i = 0; i < tracks.length; i++){
        var defaultTrack = newTracks.length;
        // a map from [program, channel] tuples to new track numbers
        var trackMap = new Map();
        // a map from channel numbers to current program numbers
        var currentProgram = Array(16).fill(0);
        for(var _i = 0, _a = tracks[i]; _i < _a.length; _i++){
            var event_1 = _a[_i];
            var targetTrack = defaultTrack;
            // If the event has a channel, we need to find that channel's current
            // program number and the appropriate track for this [program, channel]
            // pair.
            var channel = event_1.channel;
            if (channel !== undefined) {
                if (event_1.type === "programChange") {
                    currentProgram[channel] = event_1.programNumber;
                }
                var program = currentProgram[channel];
                var trackKey = "".concat(program, " ").concat(channel);
                if (trackMap.has(trackKey)) {
                    targetTrack = trackMap.get(trackKey);
                } else {
                    targetTrack = defaultTrack + trackMap.size;
                    trackMap.set(trackKey, targetTrack);
                }
            }
            if (!newTracks[targetTrack]) {
                newTracks.push([]);
            }
            newTracks[targetTrack].push(event_1);
        }
    }
    return newTracks;
} //# sourceMappingURL=Midi.js.map
}}),
"[project]/node_modules/array-flatten/dist.es2015/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Flatten an array indefinitely.
 */ __turbopack_context__.s({
    "flatten": (()=>flatten)
});
function flatten(array) {
    var result = [];
    $flatten(array, result);
    return result;
}
/**
 * Internal flatten function recursively passes `result`.
 */ function $flatten(array, result) {
    for(var i = 0; i < array.length; i++){
        var value = array[i];
        if (Array.isArray(value)) {
            $flatten(value, result);
        } else {
            result.push(value);
        }
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/staffrender/es6/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
!function(t, e) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = e() : ("TURBOPACK unreachable", undefined);
}(self, function() {
    return function(t) {
        var e = {};
        function i(s) {
            if (e[s]) return e[s].exports;
            var n = e[s] = {
                i: s,
                l: !1,
                exports: {}
            };
            return t[s].call(n.exports, n, n.exports, i), n.l = !0, n.exports;
        }
        return i.m = t, i.c = e, i.d = function(t, e, s) {
            i.o(t, e) || Object.defineProperty(t, e, {
                enumerable: !0,
                get: s
            });
        }, i.r = function(t) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(t, "__esModule", {
                value: !0
            });
        }, i.t = function(t, e) {
            if (1 & e && (t = i(t)), 8 & e) return t;
            if (4 & e && "object" == typeof t && t && t.__esModule) return t;
            var s = Object.create(null);
            if (i.r(s), Object.defineProperty(s, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t) for(var n in t)i.d(s, n, (function(e) {
                return t[e];
            }).bind(null, n));
            return s;
        }, i.n = function(t) {
            var e = t && t.__esModule ? function() {
                return t.default;
            } : function() {
                return t;
            };
            return i.d(e, "a", e), e;
        }, i.o = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e);
        }, i.p = "", i(i.s = 4);
    }([
        function(t, e, i) {
            "use strict";
            i.r(e), i.d(e, "SVGNS", function() {
                return s;
            }), i.d(e, "drawSVGPath", function() {
                return n;
            }), i.d(e, "drawSVGText", function() {
                return r;
            }), i.d(e, "createSVGGroupChild", function() {
                return a;
            }), i.d(e, "setFade", function() {
                return h;
            });
            const s = "http://www.w3.org/2000/svg";
            function n(t, e, i, n1, r, a, h = 1) {
                const l = document.createElementNS(s, "path");
                return l.setAttributeNS(null, "d", e), l.setAttributeNS(null, "transform", `translate(${i}, ${n1}) scale(${r}, ${a})`), l.setAttributeNS(null, "opacity", `${h}`), t.appendChild(l), l;
            }
            function r(t, e, i, n, r1, a = !1, h = 1, l = 1) {
                const c = document.createElementNS(s, "text");
                c.setAttributeNS(null, "font-family", "Times"), c.setAttributeNS(null, "font-size", r1), a && c.setAttributeNS(null, "font-weight", "bold"), c.setAttributeNS(null, "transform", `translate(${i}, ${n}) scale(${h}, ${l})`);
                const o = document.createTextNode(e);
                return c.appendChild(o), t.appendChild(c), c;
            }
            function a(t, e) {
                const i = document.createElementNS(s, "g");
                return i.setAttribute("data-id", e), t.appendChild(i), i;
            }
            function h(t, e = !1, i = 1, n = 0) {
                let r = t.querySelector("animate");
                if (!r) {
                    (r = document.createElementNS(s, "animate")).setAttributeNS(null, "attributeName", "opacity"), r.setAttributeNS(null, "dur", "4s"), r.setAttributeNS(null, "fill", "freeze"), r.setAttributeNS(null, "keyTimes", "0; 0.25; 0.5; 0.75; 1");
                    const t = (i + 3 * n) / 4;
                    r.setAttributeNS(null, "values", `${i}; ${t}; ${n}; ${t}; ${i}`);
                }
                return e ? r.setAttributeNS(null, "repeatCount", "indefinite") : r.setAttributeNS(null, "repeatCount", "1"), t.appendChild(r), t;
            }
        },
        function(t, e, i) {
            "use strict";
            i.r(e), i.d(e, "PATH_SCALE", function() {
                return s;
            }), i.d(e, "staffLinePath", function() {
                return r;
            }), i.d(e, "extraLinePath", function() {
                return a;
            }), i.d(e, "barPath", function() {
                return h;
            }), i.d(e, "stemPath", function() {
                return l;
            }), i.d(e, "singleFlagPath", function() {
                return c;
            }), i.d(e, "multiFlagPath", function() {
                return o;
            }), i.d(e, "tiePath", function() {
                return u;
            }), i.d(e, "dotPath", function() {
                return d;
            }), i.d(e, "NOTE_PATHS", function() {
                return f;
            }), i.d(e, "REST_PATHS", function() {
                return g;
            }), i.d(e, "CLEF_PATHS", function() {
                return S;
            }), i.d(e, "ACCIDENTAL_PATHS", function() {
                return p;
            });
            const s = 100, n = "M 0,10 C 0,-15 35,-50 80,-50 110,-50 125,-35 125,-10 \n125,15 90,50 45,50 15,50 0,35 0,10 Z", r = "m 0,0 h 100", a = "m -25,0 h 175", h = "m 0,-200 v 400", l = "m 0,0 v 100 h 15 v -100 z", c = "M0,0 h 12 c 7,100 175,156 62,314 79,-177 -49,\n-193 -61,-200 l -13,-5 z", o = "m 0,0 h 10 c 6,72 173,64 84,227 44,-120 -44,\n-123 -94,-167 z", u = "M 0,25 C 10,46 30,67 50,67 69,67 90,47 100,25 94,\n65 73,89 50,89 26,89 5,63 0,25 Z", d = "M 5 -20 a 20 20 0 1 0 0.00001 0 z", f = {
                4: {
                    path: "m 0,0 c 0,-37 49,-51 79,-51 31,0 83,13 83,51 0,39 \n-55,51 -84,51 C 49,51 0,37 0,0 Z m 111,31 c 13,-19 0,-58 -22,-68 -33,-15 \n-53,10 -39,49 9,27 48,39 61,19 z",
                    width: 150,
                    stemVSteps: 0,
                    stemAnchor: 0,
                    flags: 0
                },
                2: {
                    path: "m 0,10 c 0,-25 35,-60 80,-60 15,0 45,4 45,40 C 125,16 \n89,50 45,50 17,50 0,36 0,10 Z m 71,7 c 17,-11 45,-34 38,-45 -7,-10 -39,1 \n-57,12 -19,11 -42,31 -36,42 6,10 37,2 55,-9 z",
                    width: 125,
                    stemVSteps: 7,
                    stemAnchor: -10,
                    flags: 0
                },
                1: {
                    path: n,
                    width: 125,
                    stemVSteps: 7,
                    stemAnchor: -10,
                    flags: 0
                },
                .5: {
                    path: n,
                    width: 125,
                    stemVSteps: 7,
                    stemAnchor: -10,
                    flags: 1
                },
                .25: {
                    path: n,
                    width: 125,
                    stemVSteps: 9,
                    stemAnchor: -10,
                    flags: 2
                },
                .125: {
                    path: n,
                    width: 125,
                    stemVSteps: 11,
                    stemAnchor: -10,
                    flags: 3
                },
                .0625: {
                    path: n,
                    width: 125,
                    stemVSteps: 13,
                    stemAnchor: -10,
                    flags: 4
                }
            }, g = {
                4: "m 0,-50 h 125 v -50 H 0 Z",
                2: "M 0,0 H 125 V -50 H 0 Z",
                1: "m 0,-25 c 39,-39 37,-75 8,-120 l 6,-5 61,103 C \n40,-13 31,4 73,71 l -5,5 C 14,52 16,125 67,144 l -4,6 C -37,102 -1,22 59,60 Z",
                .5: "m 52,-47 c 26,-2 42,-21 48,-42 l 12,4 L 64,83 52,79 \n88,-49 c 0,0 -17,22 -57,22 -16,0 -31,-13 -31,-27 0,-18 10,-31 27,-31 17,0 \n33,15 25,38 z",
                .25: "m 129,-191 c -6,21 -22,40 -48,42 8,-23 -8,-38 \n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 l -20,69 \nc -7,18 -22,33 -45,35 8,-23 -8,-38 -25,-38 -17,0 -27,13 -27,31 0,14 15,27 \n31,27 40,0 57,-22 57,-22 l -36,128 12,4 77,-270 z",
                .125: "m 129,-191 c -6,21 -22,40 -48,42 8,-23 -8,-38 \n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 l -20,69 \nc -7,18 -22,33 -45,35 8,-23 -8,-38 -25,-38 -17,0 -27,13 -27,31 0,14 15,27 \n31,27 40,0 57,-22 57,-22 L 68,20 C 61,37 46,51 24,52 32,29 16,14 -1,14 c \n-17,0 -27,13 -27,31 0,14 15,27 31,27 38,0 55,-20 57,-22 l -36,128 12,4 \n105,-369 z",
                .0625: "m 158,-292 c -6,21 -22,40 -48,42 8,-23 -8,-38 \n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 l -17,61 \nv 0 c -6,21 -22,40 -48,42 8,-23 -8,-38 -25,-38 -17,0 -27,13 -27,31 0,14 \n15,27 31,27 40,0 57,-22 57,-22 l -20,69 c -7,18 -22,33 -45,35 8,-23 -8,-38 \n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 L 68,20 C \n61,37 46,51 24,52 32,29 16,14 -1,14 c -17,0 -27,13 -27,31 0,14 15,27 31,27 \n38,0 55,-20 57,-22 l -36,128 12,4 134,-469 z"
            }, S = {
                50: {
                    path: "m 101,-199 c -49,0 -100,28 -100,83 0,39 58,57 82,26 15,-20 \n-4,-47 -32,-47 -23,1 -25,0 -25,-8 0,-22 40,-46 71,-41 91,16 67,208 -105,302 \n75,-27 198,-94 211,-201 6,-66 -42,-114 -102,-114 z m 143,33 c -13,0 -23,11 \n-23,24 0,14 10,24 23,24 13,0 23,-11 23,-24 0,-13 -10,-24 -23,-24 z m 2,83 c \n-13,0 -23,11 -23,24 0,14 10,24 23,24 13,0 23,-11 23,-24 0,-13 -10,-24 -23,-24 \nz",
                    upper: -4,
                    lower: 3
                },
                71: {
                    path: "M 139,48 C 102,57 76,120 131,151 41,128 64,24 129,2 L \n117,-57 C -32,47 26,217 166,182 Z m 12,-1 27,131 C 242,153 216,46 151,47 \nZ m -35,-177 c 34,-23 82,-117 50,-140 -23,-17 -71,33 -50,140 z m -10,10 c \n-23,-77 -20,-200 48,-213 19,-4 89,171 -26,266 l 13,66 c 120,-6 137,155 \n39,191 l 12,58 c 30,131 -137,145 -138,47 0,-29 37,-59 63,-37 21,18 25,71 \n-25,70 32,42 103,0 91,-65 L 167,193 C 56,232 -112,63 106,-120 Z",
                    upper: -7,
                    lower: 8
                }
            }, p = [
                null,
                "m -49,-121 v 52 l -29,9 v -48 h -8 v 51 l -20,6 v 29 l \n20,-6 v 70 l -20,6 v 30 l 20,-6 v 51 h 8 V 69 l 30,-8 v 50 h 8 V 58 l 20,-6 \nV 23 l -20,6 v -71 l 20,-6 v -29 l -20,6 v -50 z m 1,82 v 71 l -29,9 v -71 z",
                "M -106,-166 V 67 c 52,-42 85,-56 85,-94 0,-47 -46,-51 \n-73,-22 v -117 z m 31,120 c 20,0 42,46 -20,91 V -7 c 0,-28 10,-39 20,-39 z",
                "m -81,-58 v -48 H -92 V 73 l 60,-13 v 50 h 11 V -72 Z m \n50,24 v 58 l -50,11 v -58 z"
            ];
        },
        function(t, e, i) {
            "use strict";
            i.r(e), i.d(e, "MIN_RESOLUTION", function() {
                return s;
            }), i.d(e, "STEM_WIDTH", function() {
                return n;
            }), i.d(e, "LINE_STROKE", function() {
                return r;
            }), i.d(e, "COMPACT_SPACING", function() {
                return a;
            });
            const s = .0625, n = 15, r = 1, a = 150;
        },
        function(t, e, i) {
            "use strict";
            i.r(e), i.d(e, "MAX_QUARTER_DIVISION", function() {
                return l;
            }), i.d(e, "ScrollType", function() {
                return c;
            }), i.d(e, "StaffSVGRender", function() {
                return o;
            });
            var s = i(2), n = i(0), r = i(1);
            const a = [
                {
                    steps: [
                        0,
                        0,
                        -1,
                        -1,
                        -2,
                        -3,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6
                    ],
                    accidental: [
                        0,
                        1,
                        0,
                        1,
                        0,
                        0,
                        1,
                        0,
                        1,
                        0,
                        1,
                        0
                    ]
                },
                {
                    steps: [
                        0,
                        -1,
                        -1,
                        -2,
                        -2,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6,
                        -6
                    ],
                    accidental: [
                        0,
                        0,
                        3,
                        0,
                        3,
                        0,
                        0,
                        3,
                        0,
                        3,
                        0,
                        3
                    ]
                },
                {
                    steps: [
                        0,
                        0,
                        -1,
                        -1,
                        -2,
                        -3,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6
                    ],
                    accidental: [
                        3,
                        0,
                        0,
                        1,
                        0,
                        3,
                        0,
                        0,
                        1,
                        0,
                        1,
                        0
                    ]
                },
                {
                    steps: [
                        0,
                        -1,
                        -1,
                        -2,
                        -2,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6,
                        -6
                    ],
                    accidental: [
                        0,
                        2,
                        0,
                        0,
                        3,
                        0,
                        2,
                        0,
                        0,
                        3,
                        0,
                        3
                    ]
                },
                {
                    steps: [
                        0,
                        0,
                        -1,
                        -1,
                        -2,
                        -3,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6
                    ],
                    accidental: [
                        3,
                        0,
                        3,
                        0,
                        0,
                        3,
                        0,
                        3,
                        0,
                        0,
                        1,
                        0
                    ]
                },
                {
                    steps: [
                        0,
                        -1,
                        -1,
                        -2,
                        -2,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6,
                        -6
                    ],
                    accidental: [
                        0,
                        2,
                        0,
                        2,
                        0,
                        0,
                        2,
                        0,
                        2,
                        0,
                        0,
                        3
                    ]
                },
                {
                    steps: [
                        0,
                        -1,
                        -1,
                        -2,
                        -2,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6,
                        -7
                    ],
                    accidental: [
                        3,
                        0,
                        3,
                        0,
                        3,
                        0,
                        0,
                        3,
                        0,
                        3,
                        0,
                        0
                    ]
                },
                {
                    steps: [
                        0,
                        0,
                        -1,
                        -1,
                        -2,
                        -3,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6
                    ],
                    accidental: [
                        0,
                        1,
                        0,
                        1,
                        0,
                        3,
                        0,
                        0,
                        1,
                        0,
                        1,
                        0
                    ]
                },
                {
                    steps: [
                        0,
                        -1,
                        -1,
                        -2,
                        -2,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6,
                        -6
                    ],
                    accidental: [
                        0,
                        0,
                        3,
                        0,
                        3,
                        0,
                        2,
                        0,
                        0,
                        3,
                        0,
                        3
                    ]
                },
                {
                    steps: [
                        0,
                        0,
                        -1,
                        -1,
                        -2,
                        -3,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6
                    ],
                    accidental: [
                        3,
                        0,
                        0,
                        1,
                        0,
                        3,
                        0,
                        3,
                        0,
                        0,
                        1,
                        0
                    ]
                },
                {
                    steps: [
                        0,
                        -1,
                        -1,
                        -2,
                        -2,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6,
                        -6
                    ],
                    accidental: [
                        0,
                        2,
                        0,
                        0,
                        3,
                        0,
                        2,
                        0,
                        2,
                        0,
                        0,
                        3
                    ]
                },
                {
                    steps: [
                        0,
                        0,
                        -1,
                        -1,
                        -2,
                        -3,
                        -3,
                        -4,
                        -4,
                        -5,
                        -5,
                        -6
                    ],
                    accidental: [
                        3,
                        0,
                        3,
                        0,
                        0,
                        3,
                        0,
                        3,
                        0,
                        3,
                        0,
                        0
                    ]
                }
            ], h = [
                {
                    accidental: 1,
                    pitches: []
                },
                {
                    accidental: 2,
                    pitches: [
                        70,
                        75,
                        68,
                        73,
                        66
                    ]
                },
                {
                    accidental: 1,
                    pitches: [
                        78,
                        73
                    ]
                },
                {
                    accidental: 2,
                    pitches: [
                        70,
                        75,
                        68
                    ]
                },
                {
                    accidental: 1,
                    pitches: [
                        78,
                        73,
                        80,
                        75
                    ]
                },
                {
                    accidental: 2,
                    pitches: [
                        70
                    ]
                },
                {
                    accidental: 2,
                    pitches: [
                        70,
                        75,
                        68,
                        73,
                        66,
                        71
                    ]
                },
                {
                    accidental: 1,
                    pitches: [
                        78
                    ]
                },
                {
                    accidental: 2,
                    pitches: [
                        70,
                        75,
                        68,
                        73
                    ]
                },
                {
                    accidental: 1,
                    pitches: [
                        78,
                        73,
                        80
                    ]
                },
                {
                    accidental: 2,
                    pitches: [
                        70,
                        75
                    ]
                },
                {
                    accidental: 1,
                    pitches: [
                        78,
                        73,
                        80,
                        75,
                        70
                    ]
                }
            ], l = 16;
            var c;
            !function(t) {
                t[t.PAGE = 0] = "PAGE", t[t.NOTE = 1] = "NOTE", t[t.BAR = 2] = "BAR";
            }(c || (c = {}));
            class o {
                constructor(t, e, i){
                    this.handleScrollEvent = (t)=>{
                        this.lastKnownScrollLeft = this.parentElement.scrollLeft, this.ticking || window.requestAnimationFrame(()=>{
                            this.changeAndDrawSignaturesIfNeeded(this.lastKnownScrollLeft), this.ticking = !1;
                        }), this.ticking = !0;
                    }, this.scoreInfo = t;
                    this.config = {
                        noteHeight: e.noteHeight || 6,
                        noteSpacing: e.noteSpacing || 1,
                        pixelsPerTimeStep: e.pixelsPerTimeStep || 30,
                        noteRGB: e.noteRGB || "8, 41, 64",
                        activeNoteRGB: e.activeNoteRGB || "240, 84, 119"
                    }, this.div = i, this.timeSignatureNumerator = 4, this.timeSignatureDenominator = 4, this.key = e.defaultKey || 0, this.scrollType = e.scrollType || c.PAGE, this.scale = this.config.noteHeight / r.PATH_SCALE, (void 0 === e.pixelsPerTimeStep || e.pixelsPerTimeStep <= 0) && (this.config.pixelsPerTimeStep = 0, this.config.noteSpacing = s.COMPACT_SPACING * this.scale), this.clear(), this.redraw();
                }
                clear() {
                    for(; this.div.lastChild;)this.div.removeChild(this.div.lastChild);
                    this.div.style.overflow = "visible", this.div.style.position = "relative", this.overlaySVG = document.createElementNS(n.SVGNS, "svg"), this.overlaySVG.style.position = "absolute", this.div.appendChild(this.overlaySVG), this.overlayG = Object(n.createSVGGroupChild)(this.overlaySVG, "overlay"), this.signaturesBlinking = !1, this.signaturesQuarters = 0, this.parentElement = document.createElement("div"), this.parentElement.style.overflow = "auto", this.div.appendChild(this.parentElement), this.ticking = !1, this.lastKnownScrollLeft = 0, this.parentElement.addEventListener("scroll", this.handleScrollEvent), this.staffSVG = document.createElementNS(n.SVGNS, "svg"), this.parentElement.appendChild(this.staffSVG), this.staffG = Object(n.createSVGGroupChild)(this.staffSVG, "staff"), this.linesG = Object(n.createSVGGroupChild)(this.staffSVG, "lines"), this.setStroke(this.linesG), this.staffG.appendChild(this.linesG), this.musicG = Object(n.createSVGGroupChild)(this.staffSVG, "music"), this.setFill(this.musicG), this.setStroke(this.musicG, 0), this.staffG.appendChild(this.musicG), this.signaturesG = Object(n.createSVGGroupChild)(this.staffSVG, "signatures"), this.staffG.appendChild(this.signaturesG);
                    let t = 0, e = 0;
                    this.scoreInfo.notes.forEach((i)=>{
                        t += i.pitch, ++e;
                    });
                    const i = t / e;
                    this.clef = i < 60 ? 50 : 71, this.signaturesList = [
                        {
                            x: 0,
                            q: 0
                        }
                    ], this.signatureCurrent = 0, this.signatureNext = 0, this.changeKeySignatureIfNeeded(0), this.changeTimeSignatureIfNeeded(0), this.vStepSize = this.config.noteHeight / 2, this.hStepSize = this.config.pixelsPerTimeStep, this.staffOffset = 0, this.height = 0, this.width = 0, this.musicBlockMap = new Map, this.playingNotes = [], this.lastBar = 0, this.barAccidentals = {}, this.lastQ = -1;
                }
                isPaintingActiveNote(t, e) {
                    const i = t.start === e.start, s = t.start <= e.start && t.start + t.length >= e.start + e.length;
                    return i || s;
                }
                redraw(t, e) {
                    let i = -1;
                    const s = 0 === this.config.pixelsPerTimeStep;
                    if (t) {
                        const r = [];
                        this.playingNotes.forEach((e)=>{
                            this.isPaintingActiveNote(e, t) ? r.push(e) : this.highlightElement(this.getGroup(e), !1);
                        }), this.playingNotes = r;
                        const a = this.getGroup(t);
                        if (a) {
                            this.playingNotes.push(t), this.highlightElement(a, !0), i = a.getBoundingClientRect().left - this.staffSVG.getBoundingClientRect().left;
                            const r = t.start, h = a.getAttribute("data-is-bar-beginning");
                            (this.scrollType !== c.BAR || h) && this.scrollIntoViewIfNeeded(e, i), !s && this.signaturesBlinking && r >= this.signaturesQuarters && (this.signaturesBlinking = !1, Object(n.setFade)(this.overlayG, this.signaturesBlinking));
                        }
                    } else {
                        this.setDetails();
                        const t = -1 === this.lastQ;
                        let e = 0, i = 0;
                        t ? (i = this.drawSignatures(this.overlayG, e, !0, !0, !0), s && (this.width = 0, i += this.config.noteSpacing), i += this.drawRests(this.initialRest, e + i)) : e = this.width, this.musicBlockMap.forEach((t, n)=>{
                            s || (e = this.quartersToTime(n) * this.hStepSize), n > this.lastQ ? (i += this.drawMusicBlock(t, e + i), this.lastQ = n) : n === this.lastQ && (i += this.drawRests(t, e + i));
                        });
                        const n = this.staffSVG.getBoundingClientRect(), r = this.musicG.getBoundingClientRect();
                        if (this.updateVerticalBoundaries(r.top - n.top, r.bottom - n.top), s) this.width += i;
                        else {
                            const t = this.musicBlockMap.get(this.lastQ), e = this.quartersToTime(this.lastQ + t.notes[0].length);
                            this.width = e * this.config.pixelsPerTimeStep;
                        }
                        this.staffSVG.setAttributeNS(null, "width", `${this.width}`), this.redrawStaff(this.linesG, 0, this.width);
                    }
                    return i;
                }
                drawMusicBlock(t, e) {
                    const i = t.notes[0].start;
                    let a = this.drawBarIfNeeded(i, e);
                    a += this.drawSignaturesIfNeeded(i, e + a);
                    let h = 0;
                    for(let e = 4; e >= s.MIN_RESOLUTION && !h; e /= 2)e <= t.notes[0].length && (h = e);
                    if (0 === h) {
                        const e = 0 === t.notes[0].length ? "[infinite]" : `${4 / t.notes[0].length}`;
                        console.warn(" StaffRender ", "background:orange; color:white", "StaffRender does not handle notes shorther than " + `1/${4 / s.MIN_RESOLUTION}th, and this score tries to draw a ` + `1/${e}th. Shortest possible note will be drawn instead.`), h = s.MIN_RESOLUTION;
                    }
                    const l = r.NOTE_PATHS[h];
                    let c;
                    if (l.stemAnchor && (c = Object(n.createSVGGroupChild)(this.musicG, "stem")), t.notes.forEach((i)=>{
                        const s = i.vSteps * this.vStepSize, c = 2 * (i.vSteps > 0 ? Math.floor(i.vSteps / 2) : Math.ceil(i.vSteps / 2)), o = i.vSteps > 0 ? -2 : 2;
                        for(let t = c; Math.abs(t) > 4; t += o)Object(n.drawSVGPath)(this.linesG, r.extraLinePath, e + a, t * this.vStepSize, this.scale, 1);
                        if (i.g = i.tiedFrom ? i.tiedFrom.g : Object(n.createSVGGroupChild)(this.musicG, `${i.start}-${i.pitch}`), t.isBarBeginning && i.g.setAttribute("data-is-bar-beginning", "true"), i.tiedFrom) {
                            const t = e + a - i.tiedFrom.xHeadRight;
                            Object(n.drawSVGPath)(i.g, r.tiePath, i.tiedFrom.xHeadRight, s, t / r.PATH_SCALE, this.scale * (i.vSteps < 0 ? -1 : 1), i.opacity);
                        }
                        Object(n.drawSVGPath)(i.g, l.path, e + a, s, this.scale, this.scale, i.opacity), i.xHeadRight = e + a + l.width * this.scale, 1.5 * h <= i.length && Object(n.drawSVGPath)(i.g, r.dotPath, e + a + l.width * this.scale + this.vStepSize / 2, s - this.vStepSize / 2, this.scale, this.scale, i.opacity), 0 !== i.accidental && Object(n.drawSVGPath)(i.g, r.ACCIDENTAL_PATHS[i.accidental], e + a, s, this.scale, this.scale, i.opacity);
                    }), l.stemAnchor) {
                        let i, h, o = e + a;
                        const u = l.stemAnchor * this.scale, d = t.minVStep + t.maxVStep < 0, f = l.flags > 2 ? 2 * (l.flags - 2) : 0;
                        if (d ? (i = t.maxVStep * this.vStepSize - u, h = (t.minVStep + 7 + f) * this.vStepSize) : (o += (l.width - s.STEM_WIDTH) * this.scale, i = t.minVStep * this.vStepSize + u, h = (t.maxVStep - 7 - f) * this.vStepSize), Object(n.drawSVGPath)(c, r.stemPath, o, i, this.scale, (h - i) / r.PATH_SCALE), 1 === l.flags) Object(n.drawSVGPath)(c, r.singleFlagPath, o, h, this.scale, this.scale * (d ? -1 : 1), 1);
                        else if (l.flags > 1) for(let t = 0; t < l.flags; ++t)Object(n.drawSVGPath)(c, r.multiFlagPath, o, h, this.scale, this.scale * (d ? -1 : 1), 1), h += (d ? -2 : 2) * this.vStepSize;
                    }
                    return 0 === this.config.pixelsPerTimeStep && (a += l.width * this.scale, c && (a += c.getBoundingClientRect().width), a += this.config.noteSpacing), a += this.drawRests(t, e + a);
                }
                drawBarIfNeeded(t, e) {
                    let i = 0;
                    const s = this.lastBar + this.getBarLength();
                    return 0 !== t && t >= s && (this.config.pixelsPerTimeStep > 0 ? e -= this.config.noteSpacing : i = this.config.noteSpacing, Object(n.drawSVGPath)(this.linesG, r.barPath, e, 0, 1, this.scale), this.lastBar = s), i;
                }
                drawRests(t, e) {
                    let i = 0, a = t.restToNextLength;
                    if (a) {
                        this.config.pixelsPerTimeStep > 0 && (e += this.quartersToTime(t.notes[0].length) * this.hStepSize);
                        let h = t.notes[0].start + t.notes[0].length, l = 0;
                        const c = this.lastBar + this.getBarLength() - h;
                        let o;
                        for(a > c && (l = a - c, a = c), o = 4; o > this.getBarLength() && o >= s.MIN_RESOLUTION; o /= 2);
                        let u = o;
                        for(; (a || l) && u >= s.MIN_RESOLUTION;){
                            if (u <= a) {
                                i += this.drawBarIfNeeded(h, e + i), i += this.drawSignaturesIfNeeded(h, e + i);
                                const t = Object(n.drawSVGPath)(this.musicG, r.REST_PATHS[u], e + i, 0, this.scale, this.scale);
                                this.config.pixelsPerTimeStep > 0 ? e += this.quartersToTime(u) * this.hStepSize : (i += t.getBoundingClientRect().width, i += this.config.noteSpacing), h += u, a -= u;
                            }
                            if (l && a <= 0) {
                                const t = this.getBarLength();
                                for(l > t ? (a = t, l -= t) : (a = l, l = 0), o = 4; o > this.getBarLength() && o >= s.MIN_RESOLUTION; o /= 2);
                                u = o;
                            }
                            a < u && (u /= 2);
                        }
                    }
                    return i;
                }
                redrawStaff(t, e, i) {
                    let s = t.querySelector('g[data-id="staff-five-lines"]');
                    if (s) s.setAttributeNS(null, "transform", `scale(${i / r.PATH_SCALE}, 1)`);
                    else {
                        s = Object(n.createSVGGroupChild)(t, "staff-five-lines");
                        const a = 0;
                        for(let t = -4; t <= 4; t += 2)Object(n.drawSVGPath)(s, r.staffLinePath, e, a + t * this.vStepSize, i / r.PATH_SCALE, 1);
                    }
                    return s;
                }
                clearSignatureOverlay() {
                    for(; this.overlayG.lastChild;)this.overlayG.removeChild(this.overlayG.lastChild);
                }
                drawSignaturesIfNeeded(t, e) {
                    let i = 0;
                    const r = this.changeKeySignatureIfNeeded(t), a = this.changeTimeSignatureIfNeeded(t);
                    if (r || a) {
                        const h = s.COMPACT_SPACING * this.scale * (this.config.pixelsPerTimeStep > 0 ? 3 : 2);
                        this.signaturesList.push({
                            x: e - h,
                            q: t
                        }), null === this.signatureNext && (this.signatureNext = e);
                        const l = t > 0 ? Object(n.createSVGGroupChild)(this.signaturesG, "signatures") : this.overlayG;
                        i += this.drawSignatures(l, e + i, !1, r, a);
                    }
                    return 0 === this.config.pixelsPerTimeStep ? i : 0;
                }
                drawSignatures(t, e, i, a, l) {
                    const c = s.COMPACT_SPACING * this.scale;
                    let o, u = c;
                    const d = t === this.overlayG || this.config.pixelsPerTimeStep > 0;
                    if (d) {
                        (o = document.createElementNS(n.SVGNS, "rect")).setAttributeNS(null, "x", `${e}`), o.setAttributeNS(null, "y", "0"), o.setAttributeNS(null, "width", "1"), o.setAttributeNS(null, "height", "1"), o.setAttribute("data-id", "background"), t.appendChild(o);
                        const i = document.defaultView.getComputedStyle(this.div.parentElement);
                        o.setAttributeNS(null, "fill", i.getPropertyValue("background-color"));
                    }
                    if (i) {
                        const i = Object(n.drawSVGPath)(t, r.CLEF_PATHS[this.clef].path, e + u, 0, this.scale, this.scale);
                        this.setFill(i), u += 3 * c;
                    }
                    if (a) {
                        const i = h[this.key].accidental, s = 71 === this.clef ? 0 : 14;
                        h[this.key].pitches.forEach((a)=>{
                            const h = this.getPitchDetails(a).vSteps, l = Object(n.drawSVGPath)(t, r.ACCIDENTAL_PATHS[i], e + u, (s + h) * this.vStepSize, this.scale, this.scale);
                            this.setFill(l), u += l.getBoundingClientRect().width;
                        });
                    }
                    if (l) {
                        const i = Object(n.createSVGGroupChild)(t, "time-key"), s = `${2.85 * this.config.noteHeight}px`;
                        Object(n.drawSVGText)(i, `${this.timeSignatureNumerator}`, e + u, -.5, s, !0), Object(n.drawSVGText)(i, `${this.timeSignatureDenominator}`, e + u, 4 * this.vStepSize - .5, s, !0), this.setFill(i), u += i.getBoundingClientRect().width + c;
                    }
                    const f = this.redrawStaff(t, e, u);
                    this.setStroke(f);
                    const g = this.div.getBoundingClientRect(), S = t.getBoundingClientRect();
                    if (this.updateVerticalBoundaries(S.top - g.top, S.bottom - g.top), d && (o.setAttributeNS(null, "y", `${-this.staffOffset}`), o.setAttributeNS(null, "height", `${this.height}`), o.setAttributeNS(null, "width", `${u}`)), t === this.overlayG) {
                        this.overlaySVG.setAttributeNS(null, "width", `${u + 5}`);
                        for(let e = 0; e < 5; ++e){
                            const i = Object(n.drawSVGPath)(t, r.stemPath, u + e, e * e - this.staffOffset, 1 / s.STEM_WIDTH, (this.height - 2 * e * e) / r.PATH_SCALE, (e - 5) * (e - 5) * 2 / r.PATH_SCALE);
                            this.setFill(i);
                        }
                    }
                    if (this.config.pixelsPerTimeStep > 0) {
                        const i = 0 === this.signaturesQuarters;
                        return i && (this.signaturesQuarters = this.timeToQuarters(u / this.hStepSize)), (i || e > 0) && (this.signaturesBlinking = !0, Object(n.setFade)(t, this.signaturesBlinking)), 0;
                    }
                    return u;
                }
                changeKeySignatureIfNeeded(t) {
                    if (this.scoreInfo.keySignatures) {
                        let e = this.key;
                        for(let i = 0; i < this.scoreInfo.keySignatures.length && this.scoreInfo.keySignatures[i].start <= t; ++i)e = this.scoreInfo.keySignatures[i].key;
                        if (e !== this.key) return this.key = e, !0;
                    }
                    return !1;
                }
                changeTimeSignatureIfNeeded(t) {
                    if (this.scoreInfo.timeSignatures) {
                        let e = this.timeSignatureNumerator, i = this.timeSignatureDenominator;
                        for(let s = 0; s < this.scoreInfo.timeSignatures.length && this.scoreInfo.timeSignatures[s].start <= t; ++s)e = this.scoreInfo.timeSignatures[s].numerator, i = this.scoreInfo.timeSignatures[s].denominator;
                        if (e !== this.timeSignatureNumerator || i !== this.timeSignatureDenominator) return this.timeSignatureNumerator = e, this.timeSignatureDenominator = i, !0;
                    }
                    return !1;
                }
                changeAndDrawSignaturesIfNeeded(t) {
                    let e;
                    if (t < this.signatureCurrent || null !== this.signatureNext && this.signatureNext <= t) {
                        e = this.signaturesList[0].q, this.signatureNext = null;
                        for(let i = 0; i < this.signaturesList.length; ++i){
                            if (t < this.signaturesList[i].x) {
                                this.signatureNext = this.signaturesList[i].x;
                                break;
                            }
                            this.signatureCurrent = this.signaturesList[i].x, e = this.signaturesList[i].q;
                        }
                    }
                    if (void 0 !== e) {
                        const t = this.key, i = this.timeSignatureNumerator, s = this.timeSignatureDenominator;
                        this.changeKeySignatureIfNeeded(e), this.changeTimeSignatureIfNeeded(e), this.clearSignatureOverlay(), this.drawSignatures(this.overlayG, 0, !0, !0, !0), this.key = t, this.timeSignatureNumerator = i, this.timeSignatureDenominator = s;
                    }
                    this.config.pixelsPerTimeStep > 0 && 0 === t && (this.signatureNext = 0, this.signaturesBlinking = !0, Object(n.setFade)(this.overlayG, this.signaturesBlinking));
                }
                getBarLength() {
                    return 4 * this.timeSignatureNumerator / this.timeSignatureDenominator;
                }
                scrollIntoViewIfNeeded(t, e) {
                    if (t) if (this.scrollType === c.PAGE) {
                        const t = this.parentElement.getBoundingClientRect().width;
                        e > this.parentElement.scrollLeft + t && (this.parentElement.scrollLeft = e - 20);
                    } else {
                        const t = this.parentElement.getBoundingClientRect().width;
                        this.parentElement.scrollLeft = e - .5 * t;
                    }
                }
                updateVerticalBoundaries(t, e) {
                    let i = 0;
                    if (t < 0) {
                        this.staffOffset -= t;
                        const e = `translate(0, ${this.staffOffset})`;
                        this.overlayG.setAttributeNS(null, "transform", e), this.staffG.setAttributeNS(null, "transform", e), i = this.height - t;
                    }
                    if ((i = Math.max(i, e - t)) > this.height) {
                        this.height = i, this.overlaySVG.setAttributeNS(null, "height", `${this.height}`), this.staffSVG.setAttributeNS(null, "height", `${this.height}`);
                        const t = this.div.querySelectorAll('rect[data-id="background"]');
                        for(let e = 0; e < t.length; ++e){
                            const i = t[e];
                            i.setAttributeNS(null, "y", `${-this.staffOffset}`), i.setAttributeNS(null, "height", `${this.height}`);
                        }
                    }
                }
                setFill(t, e = !1) {
                    t.setAttributeNS(null, "fill", this.getColor(e));
                }
                setStroke(t, e = s.LINE_STROKE, i = !1) {
                    t.setAttributeNS(null, "stroke", this.getColor(i)), t.setAttributeNS(null, "stroke-width", `${e}`);
                }
                getColor(t) {
                    return `rgb(${t ? this.config.activeNoteRGB : this.config.noteRGB})`;
                }
                getOpacity(t) {
                    return t ? t / 127 * .8 + .2 : 1;
                }
                getGroup(t) {
                    const e = t.start, i = t.pitch;
                    return this.staffSVG.querySelector(`g[data-id="${e}-${i}"]`);
                }
                highlightElement(t, e) {
                    t.setAttribute("fill", this.getColor(e)), t.setAttribute("stroke", this.getColor(e));
                }
                getBarBeginnings() {
                    const t = new Set;
                    let e = 0;
                    this.scoreInfo.notes.forEach((t)=>{
                        t.start + t.length > e && (e = t.start + t.length);
                    });
                    const i = this.scoreInfo.timeSignatures ? this.scoreInfo.timeSignatures.slice(0) : [
                        {
                            start: 0,
                            numerator: 4,
                            denominator: 4
                        }
                    ];
                    i.sort((t, e)=>t.start - e.start);
                    let s = 0;
                    for(let n = 0; n < i.length; ++n){
                        const r = n === i.length - 1 ? e : i[n].start, a = 4 * i[n].numerator / i[n].denominator;
                        for(; s < r; s += a)t.add(s);
                    }
                    return t;
                }
                quartersToTime(t) {
                    return t / this.scoreInfo.tempos[0].qpm * 60;
                }
                timeToQuarters(t) {
                    return t * this.scoreInfo.tempos[0].qpm / 60;
                }
                setDetails() {
                    let t = new Map;
                    const e = this.getBarBeginnings(), i = new Set(e);
                    this.scoreInfo.notes.slice().sort((t, e)=>t.start - e.start).forEach((e)=>{
                        const s = this.getQNote(e);
                        i.add(s.start), i.add(s.start + s.length), t.has(s.start) ? t.get(s.start).push(s) : t.set(s.start, [
                            s
                        ]);
                    }), Array.from(i).sort((t, e)=>t - e).forEach((e)=>{
                        const i = [];
                        t.forEach((t)=>{
                            t.forEach((t)=>{
                                const s = this.splitQNote(t, e);
                                s && i.push(s);
                            });
                        }), i.forEach((e)=>{
                            t.has(e.start) ? t.get(e.start).push(e) : t.set(e.start, [
                                e
                            ]);
                        });
                    }), t = new Map(Array.from(t).sort((t, e)=>t[0] - e[0]));
                    const s = this.key;
                    let n = null, r = 0;
                    const a = e[Symbol.iterator]();
                    let h = a.next();
                    t.forEach((t, e)=>{
                        const i = {
                            maxVStep: Number.MAX_SAFE_INTEGER,
                            minVStep: Number.MIN_SAFE_INTEGER,
                            restToNextLength: 0,
                            isBarBeginning: !1,
                            notes: []
                        };
                        this.changeKeySignatureIfNeeded(e);
                        const s = h.value + this.getBarLength();
                        !h.done && e >= s && (h = a.next(), this.barAccidentals = {}, i.isBarBeginning = !0), t.forEach((t)=>{
                            this.analyzePitch(t, e), i.minVStep = Math.max(t.vSteps, i.minVStep), i.maxVStep = Math.min(t.vSteps, i.maxVStep), i.notes.push(t);
                        }), n && (n.restToNextLength = e - r), this.musicBlockMap.set(e, i), n = i, r = e + i.notes[0].length;
                    }), this.initialRest = {
                        maxVStep: 0,
                        minVStep: 0,
                        restToNextLength: this.musicBlockMap.values().next().value.notes[0].start,
                        isBarBeginning: !0,
                        notes: [
                            {
                                start: 0,
                                length: 0,
                                vSteps: 0,
                                accidental: 0,
                                opacity: 0,
                                pitch: 0,
                                xHeadRight: 0
                            }
                        ]
                    }, this.key = s;
                }
                getQNote(t) {
                    return {
                        start: t.start,
                        length: t.length,
                        vSteps: 0,
                        accidental: 0,
                        opacity: this.getOpacity(t.intensity),
                        pitch: t.pitch,
                        xHeadRight: 0
                    };
                }
                splitQNote(t, e) {
                    const i = t.start + t.length - e;
                    return e > t.start && i > 0 ? (t.length -= i, {
                        start: e,
                        length: i,
                        vSteps: t.vSteps,
                        accidental: t.accidental,
                        opacity: t.opacity,
                        pitch: t.pitch,
                        xHeadRight: 0,
                        tiedFrom: t
                    }) : null;
                }
                analyzePitch(t, e) {
                    const i = this.getPitchDetails(t.pitch);
                    i.vSteps in this.barAccidentals ? i.accidental === this.barAccidentals[i.vSteps] ? i.accidental = 0 : (3 === this.barAccidentals[i.vSteps] ? i.accidental = i.keyAccidental : 0 === i.accidental && (i.accidental = 3), this.barAccidentals[i.vSteps] = i.accidental) : (t.tiedFrom && (i.accidental = 0), this.barAccidentals[i.vSteps] = i.accidental), t.vSteps = i.vSteps, t.accidental = i.accidental;
                }
                getPitchDetails(t) {
                    const e = t - 60, i = Math.floor(e / 12), s = e - 12 * i, n = a[this.key].steps[s], r = 71 === this.clef ? 6 : -6, l = 1 === h[this.key].accidental ? 69 + (s + 3) % 12 : 64 + (s + 8) % 12;
                    return {
                        vSteps: r - 7 * i + n,
                        accidental: a[this.key].accidental[s],
                        keyAccidental: h[this.key].pitches.indexOf(l) > -1 ? h[this.key].accidental : 0
                    };
                }
            }
        },
        function(t, e, i) {
            "use strict";
            i.r(e);
            var s = i(3);
            i.d(e, "MAX_QUARTER_DIVISION", function() {
                return s.MAX_QUARTER_DIVISION;
            }), i.d(e, "ScrollType", function() {
                return s.ScrollType;
            }), i.d(e, "StaffSVGRender", function() {
                return s.StaffSVGRender;
            });
        }
    ]);
});
}}),
"[project]/node_modules/fft.js/lib/fft.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
function FFT(size) {
    this.size = size | 0;
    if (this.size <= 1 || (this.size & this.size - 1) !== 0) throw new Error('FFT size must be a power of two and bigger than 1');
    this._csize = size << 1;
    // NOTE: Use of `var` is intentional for old V8 versions
    var table = new Array(this.size * 2);
    for(var i = 0; i < table.length; i += 2){
        const angle = Math.PI * i / this.size;
        table[i] = Math.cos(angle);
        table[i + 1] = -Math.sin(angle);
    }
    this.table = table;
    // Find size's power of two
    var power = 0;
    for(var t = 1; this.size > t; t <<= 1)power++;
    // Calculate initial step's width:
    //   * If we are full radix-4 - it is 2x smaller to give inital len=8
    //   * Otherwise it is the same as `power` to give len=4
    this._width = power % 2 === 0 ? power - 1 : power;
    // Pre-compute bit-reversal patterns
    this._bitrev = new Array(1 << this._width);
    for(var j = 0; j < this._bitrev.length; j++){
        this._bitrev[j] = 0;
        for(var shift = 0; shift < this._width; shift += 2){
            var revShift = this._width - shift - 2;
            this._bitrev[j] |= (j >>> shift & 3) << revShift;
        }
    }
    this._out = null;
    this._data = null;
    this._inv = 0;
}
module.exports = FFT;
FFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {
    var res = storage || new Array(complex.length >>> 1);
    for(var i = 0; i < complex.length; i += 2)res[i >>> 1] = complex[i];
    return res;
};
FFT.prototype.createComplexArray = function createComplexArray() {
    const res = new Array(this._csize);
    for(var i = 0; i < res.length; i++)res[i] = 0;
    return res;
};
FFT.prototype.toComplexArray = function toComplexArray(input, storage) {
    var res = storage || this.createComplexArray();
    for(var i = 0; i < res.length; i += 2){
        res[i] = input[i >>> 1];
        res[i + 1] = 0;
    }
    return res;
};
FFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {
    var size = this._csize;
    var half = size >>> 1;
    for(var i = 2; i < half; i += 2){
        spectrum[size - i] = spectrum[i];
        spectrum[size - i + 1] = -spectrum[i + 1];
    }
};
FFT.prototype.transform = function transform(out, data) {
    if (out === data) throw new Error('Input and output buffers must be different');
    this._out = out;
    this._data = data;
    this._inv = 0;
    this._transform4();
    this._out = null;
    this._data = null;
};
FFT.prototype.realTransform = function realTransform(out, data) {
    if (out === data) throw new Error('Input and output buffers must be different');
    this._out = out;
    this._data = data;
    this._inv = 0;
    this._realTransform4();
    this._out = null;
    this._data = null;
};
FFT.prototype.inverseTransform = function inverseTransform(out, data) {
    if (out === data) throw new Error('Input and output buffers must be different');
    this._out = out;
    this._data = data;
    this._inv = 1;
    this._transform4();
    for(var i = 0; i < out.length; i++)out[i] /= this.size;
    this._out = null;
    this._data = null;
};
// radix-4 implementation
//
// NOTE: Uses of `var` are intentional for older V8 version that do not
// support both `let compound assignments` and `const phi`
FFT.prototype._transform4 = function _transform4() {
    var out = this._out;
    var size = this._csize;
    // Initial step (permute and transform)
    var width = this._width;
    var step = 1 << width;
    var len = size / step << 1;
    var outOff;
    var t;
    var bitrev = this._bitrev;
    if (len === 4) {
        for(outOff = 0, t = 0; outOff < size; outOff += len, t++){
            const off = bitrev[t];
            this._singleTransform2(outOff, off, step);
        }
    } else {
        // len === 8
        for(outOff = 0, t = 0; outOff < size; outOff += len, t++){
            const off = bitrev[t];
            this._singleTransform4(outOff, off, step);
        }
    }
    // Loop through steps in decreasing order
    var inv = this._inv ? -1 : 1;
    var table = this.table;
    for(step >>= 2; step >= 2; step >>= 2){
        len = size / step << 1;
        var quarterLen = len >>> 2;
        // Loop through offsets in the data
        for(outOff = 0; outOff < size; outOff += len){
            // Full case
            var limit = outOff + quarterLen;
            for(var i = outOff, k = 0; i < limit; i += 2, k += step){
                const A = i;
                const B = A + quarterLen;
                const C = B + quarterLen;
                const D = C + quarterLen;
                // Original values
                const Ar = out[A];
                const Ai = out[A + 1];
                const Br = out[B];
                const Bi = out[B + 1];
                const Cr = out[C];
                const Ci = out[C + 1];
                const Dr = out[D];
                const Di = out[D + 1];
                // Middle values
                const MAr = Ar;
                const MAi = Ai;
                const tableBr = table[k];
                const tableBi = inv * table[k + 1];
                const MBr = Br * tableBr - Bi * tableBi;
                const MBi = Br * tableBi + Bi * tableBr;
                const tableCr = table[2 * k];
                const tableCi = inv * table[2 * k + 1];
                const MCr = Cr * tableCr - Ci * tableCi;
                const MCi = Cr * tableCi + Ci * tableCr;
                const tableDr = table[3 * k];
                const tableDi = inv * table[3 * k + 1];
                const MDr = Dr * tableDr - Di * tableDi;
                const MDi = Dr * tableDi + Di * tableDr;
                // Pre-Final values
                const T0r = MAr + MCr;
                const T0i = MAi + MCi;
                const T1r = MAr - MCr;
                const T1i = MAi - MCi;
                const T2r = MBr + MDr;
                const T2i = MBi + MDi;
                const T3r = inv * (MBr - MDr);
                const T3i = inv * (MBi - MDi);
                // Final values
                const FAr = T0r + T2r;
                const FAi = T0i + T2i;
                const FCr = T0r - T2r;
                const FCi = T0i - T2i;
                const FBr = T1r + T3i;
                const FBi = T1i - T3r;
                const FDr = T1r - T3i;
                const FDi = T1i + T3r;
                out[A] = FAr;
                out[A + 1] = FAi;
                out[B] = FBr;
                out[B + 1] = FBi;
                out[C] = FCr;
                out[C + 1] = FCi;
                out[D] = FDr;
                out[D + 1] = FDi;
            }
        }
    }
};
// radix-2 implementation
//
// NOTE: Only called for len=4
FFT.prototype._singleTransform2 = function _singleTransform2(outOff, off, step) {
    const out = this._out;
    const data = this._data;
    const evenR = data[off];
    const evenI = data[off + 1];
    const oddR = data[off + step];
    const oddI = data[off + step + 1];
    const leftR = evenR + oddR;
    const leftI = evenI + oddI;
    const rightR = evenR - oddR;
    const rightI = evenI - oddI;
    out[outOff] = leftR;
    out[outOff + 1] = leftI;
    out[outOff + 2] = rightR;
    out[outOff + 3] = rightI;
};
// radix-4
//
// NOTE: Only called for len=8
FFT.prototype._singleTransform4 = function _singleTransform4(outOff, off, step) {
    const out = this._out;
    const data = this._data;
    const inv = this._inv ? -1 : 1;
    const step2 = step * 2;
    const step3 = step * 3;
    // Original values
    const Ar = data[off];
    const Ai = data[off + 1];
    const Br = data[off + step];
    const Bi = data[off + step + 1];
    const Cr = data[off + step2];
    const Ci = data[off + step2 + 1];
    const Dr = data[off + step3];
    const Di = data[off + step3 + 1];
    // Pre-Final values
    const T0r = Ar + Cr;
    const T0i = Ai + Ci;
    const T1r = Ar - Cr;
    const T1i = Ai - Ci;
    const T2r = Br + Dr;
    const T2i = Bi + Di;
    const T3r = inv * (Br - Dr);
    const T3i = inv * (Bi - Di);
    // Final values
    const FAr = T0r + T2r;
    const FAi = T0i + T2i;
    const FBr = T1r + T3i;
    const FBi = T1i - T3r;
    const FCr = T0r - T2r;
    const FCi = T0i - T2i;
    const FDr = T1r - T3i;
    const FDi = T1i + T3r;
    out[outOff] = FAr;
    out[outOff + 1] = FAi;
    out[outOff + 2] = FBr;
    out[outOff + 3] = FBi;
    out[outOff + 4] = FCr;
    out[outOff + 5] = FCi;
    out[outOff + 6] = FDr;
    out[outOff + 7] = FDi;
};
// Real input radix-4 implementation
FFT.prototype._realTransform4 = function _realTransform4() {
    var out = this._out;
    var size = this._csize;
    // Initial step (permute and transform)
    var width = this._width;
    var step = 1 << width;
    var len = size / step << 1;
    var outOff;
    var t;
    var bitrev = this._bitrev;
    if (len === 4) {
        for(outOff = 0, t = 0; outOff < size; outOff += len, t++){
            const off = bitrev[t];
            this._singleRealTransform2(outOff, off >>> 1, step >>> 1);
        }
    } else {
        // len === 8
        for(outOff = 0, t = 0; outOff < size; outOff += len, t++){
            const off = bitrev[t];
            this._singleRealTransform4(outOff, off >>> 1, step >>> 1);
        }
    }
    // Loop through steps in decreasing order
    var inv = this._inv ? -1 : 1;
    var table = this.table;
    for(step >>= 2; step >= 2; step >>= 2){
        len = size / step << 1;
        var halfLen = len >>> 1;
        var quarterLen = halfLen >>> 1;
        var hquarterLen = quarterLen >>> 1;
        // Loop through offsets in the data
        for(outOff = 0; outOff < size; outOff += len){
            for(var i = 0, k = 0; i <= hquarterLen; i += 2, k += step){
                var A = outOff + i;
                var B = A + quarterLen;
                var C = B + quarterLen;
                var D = C + quarterLen;
                // Original values
                var Ar = out[A];
                var Ai = out[A + 1];
                var Br = out[B];
                var Bi = out[B + 1];
                var Cr = out[C];
                var Ci = out[C + 1];
                var Dr = out[D];
                var Di = out[D + 1];
                // Middle values
                var MAr = Ar;
                var MAi = Ai;
                var tableBr = table[k];
                var tableBi = inv * table[k + 1];
                var MBr = Br * tableBr - Bi * tableBi;
                var MBi = Br * tableBi + Bi * tableBr;
                var tableCr = table[2 * k];
                var tableCi = inv * table[2 * k + 1];
                var MCr = Cr * tableCr - Ci * tableCi;
                var MCi = Cr * tableCi + Ci * tableCr;
                var tableDr = table[3 * k];
                var tableDi = inv * table[3 * k + 1];
                var MDr = Dr * tableDr - Di * tableDi;
                var MDi = Dr * tableDi + Di * tableDr;
                // Pre-Final values
                var T0r = MAr + MCr;
                var T0i = MAi + MCi;
                var T1r = MAr - MCr;
                var T1i = MAi - MCi;
                var T2r = MBr + MDr;
                var T2i = MBi + MDi;
                var T3r = inv * (MBr - MDr);
                var T3i = inv * (MBi - MDi);
                // Final values
                var FAr = T0r + T2r;
                var FAi = T0i + T2i;
                var FBr = T1r + T3i;
                var FBi = T1i - T3r;
                out[A] = FAr;
                out[A + 1] = FAi;
                out[B] = FBr;
                out[B + 1] = FBi;
                // Output final middle point
                if (i === 0) {
                    var FCr = T0r - T2r;
                    var FCi = T0i - T2i;
                    out[C] = FCr;
                    out[C + 1] = FCi;
                    continue;
                }
                // Do not overwrite ourselves
                if (i === hquarterLen) continue;
                // In the flipped case:
                // MAi = -MAi
                // MBr=-MBi, MBi=-MBr
                // MCr=-MCr
                // MDr=MDi, MDi=MDr
                var ST0r = T1r;
                var ST0i = -T1i;
                var ST1r = T0r;
                var ST1i = -T0i;
                var ST2r = -inv * T3i;
                var ST2i = -inv * T3r;
                var ST3r = -inv * T2i;
                var ST3i = -inv * T2r;
                var SFAr = ST0r + ST2r;
                var SFAi = ST0i + ST2i;
                var SFBr = ST1r + ST3i;
                var SFBi = ST1i - ST3r;
                var SA = outOff + quarterLen - i;
                var SB = outOff + halfLen - i;
                out[SA] = SFAr;
                out[SA + 1] = SFAi;
                out[SB] = SFBr;
                out[SB + 1] = SFBi;
            }
        }
    }
};
// radix-2 implementation
//
// NOTE: Only called for len=4
FFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff, off, step) {
    const out = this._out;
    const data = this._data;
    const evenR = data[off];
    const oddR = data[off + step];
    const leftR = evenR + oddR;
    const rightR = evenR - oddR;
    out[outOff] = leftR;
    out[outOff + 1] = 0;
    out[outOff + 2] = rightR;
    out[outOff + 3] = 0;
};
// radix-4
//
// NOTE: Only called for len=8
FFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff, off, step) {
    const out = this._out;
    const data = this._data;
    const inv = this._inv ? -1 : 1;
    const step2 = step * 2;
    const step3 = step * 3;
    // Original values
    const Ar = data[off];
    const Br = data[off + step];
    const Cr = data[off + step2];
    const Dr = data[off + step3];
    // Pre-Final values
    const T0r = Ar + Cr;
    const T1r = Ar - Cr;
    const T2r = Br + Dr;
    const T3r = inv * (Br - Dr);
    // Final values
    const FAr = T0r + T2r;
    const FBr = T1r;
    const FBi = -T3r;
    const FCr = T0r - T2r;
    const FDr = T1r;
    const FDi = T3r;
    out[outOff] = FAr;
    out[outOff + 1] = 0;
    out[outOff + 2] = FBr;
    out[outOff + 3] = FBi;
    out[outOff + 4] = FCr;
    out[outOff + 5] = 0;
    out[outOff + 6] = FDr;
    out[outOff + 7] = FDi;
};
}}),
"[project]/node_modules/iota-array/iota.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function iota(n) {
    var result = new Array(n);
    for(var i = 0; i < n; ++i){
        result[i] = i;
    }
    return result;
}
module.exports = iota;
}}),
"[project]/node_modules/is-buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ // The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}
}}),
"[project]/node_modules/ndarray/ndarray.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var iota = __turbopack_context__.r("[project]/node_modules/iota-array/iota.js [app-client] (ecmascript)");
var isBuffer = __turbopack_context__.r("[project]/node_modules/is-buffer/index.js [app-client] (ecmascript)");
var hasTypedArrays = typeof Float64Array !== "undefined";
function compare1st(a, b) {
    return a[0] - b[0];
}
function order() {
    var stride = this.stride;
    var terms = new Array(stride.length);
    var i;
    for(i = 0; i < terms.length; ++i){
        terms[i] = [
            Math.abs(stride[i]),
            i
        ];
    }
    terms.sort(compare1st);
    var result = new Array(terms.length);
    for(i = 0; i < result.length; ++i){
        result[i] = terms[i][1];
    }
    return result;
}
function compileConstructor(dtype, dimension) {
    var className = [
        "View",
        dimension,
        "d",
        dtype
    ].join("");
    if (dimension < 0) {
        className = "View_Nil" + dtype;
    }
    var useGetters = dtype === "generic";
    if (dimension === -1) {
        //Special case for trivial arrays
        var code = "function " + className + "(a){this.data=a;};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new " + className + "(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
    } else if (dimension === 0) {
        //Special case for 0d arrays
        var code = "function " + className + "(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function " + className + "_copy() {\
return new " + className + "(this.data,this.offset)\
};\
proto.pick=function " + className + "_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function " + className + "_get(){\
return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};\
proto.set=function " + className + "_set(v){\
return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
};\
return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
    }
    var code = [
        "'use strict'"
    ];
    //Create constructor for view
    var indices = iota(dimension);
    var args = indices.map(function(i) {
        return "i" + i;
    });
    var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i;
    }).join("+");
    var shapeArg = indices.map(function(i) {
        return "b" + i;
    }).join(",");
    var strideArg = indices.map(function(i) {
        return "c" + i;
    }).join(",");
    code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension);
    //view.size:
    code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
return " + indices.map(function(i) {
        return "this.shape[" + i + "]";
    }).join("*"), "}})");
    //view.order:
    if (dimension === 1) {
        code.push("proto.order=[0]");
    } else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
            code.push("function " + className + "_order(){");
            if (dimension === 2) {
                code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
            } else if (dimension === 3) {
                code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
            }
        } else {
            code.push("ORDER})");
        }
    }
    //view.set(i0, ..., v):
    code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");
    if (useGetters) {
        code.push("return this.data.set(" + index_str + ",v)}");
    } else {
        code.push("return this.data[" + index_str + "]=v}");
    }
    //view.get(i0, ...):
    code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
    if (useGetters) {
        code.push("return this.data.get(" + index_str + ")}");
    } else {
        code.push("return this.data[" + index_str + "]}");
    }
    //view.index:
    code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}");
    //view.hi():
    code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i) {
        return [
            "(typeof i",
            i,
            "!=='number'||i",
            i,
            "<0)?this.shape[",
            i,
            "]:i",
            i,
            "|0"
        ].join("");
    }).join(",") + "," + indices.map(function(i) {
        return "this.stride[" + i + "]";
    }).join(",") + ",this.offset)}");
    //view.lo():
    var a_vars = indices.map(function(i) {
        return "a" + i + "=this.shape[" + i + "]";
    });
    var c_vars = indices.map(function(i) {
        return "c" + i + "=this.stride[" + i + "]";
    });
    code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
    for(var i = 0; i < dimension; ++i){
        code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){\
d=i" + i + "|0;\
b+=c" + i + "*d;\
a" + i + "-=d}");
    }
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
        return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
        return "c" + i;
    }).join(",") + ",b)}");
    //view.step():
    code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i) {
        return "a" + i + "=this.shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
        return "b" + i + "=this.stride[" + i + "]";
    }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
    for(var i = 0; i < dimension; ++i){
        code.push("if(typeof i" + i + "==='number'){\
d=i" + i + "|0;\
if(d<0){\
c+=b" + i + "*(a" + i + "-1);\
a" + i + "=ceil(-a" + i + "/d)\
}else{\
a" + i + "=ceil(a" + i + "/d)\
}\
b" + i + "*=d\
}");
    }
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
        return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
        return "b" + i;
    }).join(",") + ",c)}");
    //view.transpose():
    var tShape = new Array(dimension);
    var tStride = new Array(dimension);
    for(var i = 0; i < dimension; ++i){
        tShape[i] = "a[i" + i + "]";
        tStride[i] = "b[i" + i + "]";
    }
    code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
        return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
    }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}");
    //view.pick():
    code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
    for(var i = 0; i < dimension; ++i){
        code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
    }
    code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
    //Add return statement
    code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i) {
        return "shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
        return "stride[" + i + "]";
    }).join(",") + ",offset)}");
    //Compile procedure
    var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
    return procedure(CACHED_CONSTRUCTORS[dtype], order);
}
function arrayDType(data) {
    if (isBuffer(data)) {
        return "buffer";
    }
    if (hasTypedArrays) {
        switch(Object.prototype.toString.call(data)){
            case "[object Float64Array]":
                return "float64";
            case "[object Float32Array]":
                return "float32";
            case "[object Int8Array]":
                return "int8";
            case "[object Int16Array]":
                return "int16";
            case "[object Int32Array]":
                return "int32";
            case "[object Uint8Array]":
                return "uint8";
            case "[object Uint16Array]":
                return "uint16";
            case "[object Uint32Array]":
                return "uint32";
            case "[object Uint8ClampedArray]":
                return "uint8_clamped";
            case "[object BigInt64Array]":
                return "bigint64";
            case "[object BigUint64Array]":
                return "biguint64";
        }
    }
    if (Array.isArray(data)) {
        return "array";
    }
    return "generic";
}
var CACHED_CONSTRUCTORS = {
    "float32": [],
    "float64": [],
    "int8": [],
    "int16": [],
    "int32": [],
    "uint8": [],
    "uint16": [],
    "uint32": [],
    "array": [],
    "uint8_clamped": [],
    "bigint64": [],
    "biguint64": [],
    "buffer": [],
    "generic": []
};
(function() {
    for(var id in CACHED_CONSTRUCTORS){
        CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));
    }
});
function wrappedNDArrayCtor(data, shape, stride, offset) {
    if (data === undefined) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
    } else if (typeof data === "number") {
        data = [
            data
        ];
    }
    if (shape === undefined) {
        shape = [
            data.length
        ];
    }
    var d = shape.length;
    if (stride === undefined) {
        stride = new Array(d);
        for(var i = d - 1, sz = 1; i >= 0; --i){
            stride[i] = sz;
            sz *= shape[i];
        }
    }
    if (offset === undefined) {
        offset = 0;
        for(var i = 0; i < d; ++i){
            if (stride[i] < 0) {
                offset -= (shape[i] - 1) * stride[i];
            }
        }
    }
    var dtype = arrayDType(data);
    var ctor_list = CACHED_CONSTRUCTORS[dtype];
    while(ctor_list.length <= d + 1){
        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
    }
    var ctor = ctor_list[d + 1];
    return ctor(data, shape, stride, offset);
}
module.exports = wrappedNDArrayCtor;
}}),
"[project]/node_modules/uniq/uniq.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function unique_pred(list, compare) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for(var i = 1; i < len; ++i){
        b = a;
        a = list[i];
        if (compare(a, b)) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique_eq(list) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for(var i = 1; i < len; ++i, b = a){
        b = a;
        a = list[i];
        if (a !== b) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique(list, compare, sorted) {
    if (list.length === 0) {
        return list;
    }
    if (compare) {
        if (!sorted) {
            list.sort(compare);
        }
        return unique_pred(list, compare);
    }
    if (!sorted) {
        list.sort();
    }
    return unique_eq(list);
}
module.exports = unique;
}}),
"[project]/node_modules/cwise-compiler/lib/compile.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var uniq = __turbopack_context__.r("[project]/node_modules/uniq/uniq.js [app-client] (ecmascript)");
// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
    for(i = 0; i < dimension; ++i){
        vars.push([
            "i",
            i,
            "=0"
        ].join(""));
    }
    //Compute scan deltas
    for(j = 0; j < nargs; ++j){
        for(i = 0; i < dimension; ++i){
            pidx = idx;
            idx = order[i];
            if (i === 0) {
                vars.push([
                    "d",
                    j,
                    "s",
                    i,
                    "=t",
                    j,
                    "p",
                    idx
                ].join(""));
            } else {
                vars.push([
                    "d",
                    j,
                    "s",
                    i,
                    "=(t",
                    j,
                    "p",
                    idx,
                    "-s",
                    pidx,
                    "*t",
                    j,
                    "p",
                    pidx,
                    ")"
                ].join(""));
            }
        }
    }
    if (vars.length > 0) {
        code.push("var " + vars.join(","));
    }
    //Scan loop
    for(i = dimension - 1; i >= 0; --i){
        idx = order[i];
        code.push([
            "for(i",
            i,
            "=0;i",
            i,
            "<s",
            idx,
            ";++i",
            i,
            "){"
        ].join(""));
    }
    //Push body of inner loop
    code.push(body);
    //Advance scan pointers
    for(i = 0; i < dimension; ++i){
        pidx = idx;
        idx = order[i];
        for(j = 0; j < nargs; ++j){
            code.push([
                "p",
                j,
                "+=d",
                j,
                "s",
                i
            ].join(""));
        }
        if (has_index) {
            if (i > 0) {
                code.push([
                    "index[",
                    pidx,
                    "]-=s",
                    pidx
                ].join(""));
            }
            code.push([
                "++index[",
                idx,
                "]"
            ].join(""));
        }
        code.push("}");
    }
    return code.join("\n");
}
// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
    for(var i = 0; i < nargs; ++i){
        code.push([
            "var offset",
            i,
            "=p",
            i
        ].join(""));
    }
    //Generate loops for unmatched dimensions
    // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
    // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
    for(var i = matched; i < dimension; ++i){
        code.push([
            "for(var j" + i + "=SS[",
            order[i],
            "]|0;j",
            i,
            ">0;){"
        ].join("")) // Iterate back to front
        ;
        code.push([
            "if(j",
            i,
            "<",
            blockSize,
            "){"
        ].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
        ;
        code.push([
            "s",
            order[i],
            "=j",
            i
        ].join(""));
        code.push([
            "j",
            i,
            "=0"
        ].join(""));
        code.push([
            "}else{s",
            order[i],
            "=",
            blockSize
        ].join(""));
        code.push([
            "j",
            i,
            "-=",
            blockSize,
            "}"
        ].join(""));
        if (has_index) {
            code.push([
                "index[",
                order[i],
                "]=j",
                i
            ].join(""));
        }
    }
    for(var i = 0; i < nargs; ++i){
        var indexStr = [
            "offset" + i
        ];
        for(var j = matched; j < dimension; ++j){
            indexStr.push([
                "j",
                j,
                "*t",
                i,
                "p",
                order[j]
            ].join(""));
        }
        code.push([
            "p",
            i,
            "=(",
            indexStr.join("+"),
            ")"
        ].join(""));
    }
    code.push(innerFill(order, proc, body));
    for(var i = matched; i < dimension; ++i){
        code.push("}");
    }
    return code.join("\n");
}
//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
    var matched = 0, dimension = orders[0].length;
    while(matched < dimension){
        for(var j = 1; j < orders.length; ++j){
            if (orders[j][matched] !== orders[0][matched]) {
                return matched;
            }
        }
        ++matched;
    }
    return matched;
}
//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
    var code = block.body;
    var pre = [];
    var post = [];
    for(var i = 0; i < block.args.length; ++i){
        var carg = block.args[i];
        if (carg.count <= 0) {
            continue;
        }
        var re = new RegExp(carg.name, "g");
        var ptrStr = "";
        var arrNum = proc.arrayArgs.indexOf(i);
        switch(proc.argTypes[i]){
            case "offset":
                var offArgIndex = proc.offsetArgIndex.indexOf(i);
                var offArg = proc.offsetArgs[offArgIndex];
                arrNum = offArg.array;
                ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
                ;
            case "array":
                ptrStr = "p" + arrNum + ptrStr;
                var localStr = "l" + i;
                var arrStr = "a" + arrNum;
                if (proc.arrayBlockIndices[arrNum] === 0) {
                    if (carg.count === 1) {
                        if (dtypes[arrNum] === "generic") {
                            if (carg.lvalue) {
                                pre.push([
                                    "var ",
                                    localStr,
                                    "=",
                                    arrStr,
                                    ".get(",
                                    ptrStr,
                                    ")"
                                ].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                                ;
                                code = code.replace(re, localStr);
                                post.push([
                                    arrStr,
                                    ".set(",
                                    ptrStr,
                                    ",",
                                    localStr,
                                    ")"
                                ].join(""));
                            } else {
                                code = code.replace(re, [
                                    arrStr,
                                    ".get(",
                                    ptrStr,
                                    ")"
                                ].join(""));
                            }
                        } else {
                            code = code.replace(re, [
                                arrStr,
                                "[",
                                ptrStr,
                                "]"
                            ].join(""));
                        }
                    } else if (dtypes[arrNum] === "generic") {
                        pre.push([
                            "var ",
                            localStr,
                            "=",
                            arrStr,
                            ".get(",
                            ptrStr,
                            ")"
                        ].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                        ;
                        code = code.replace(re, localStr);
                        if (carg.lvalue) {
                            post.push([
                                arrStr,
                                ".set(",
                                ptrStr,
                                ",",
                                localStr,
                                ")"
                            ].join(""));
                        }
                    } else {
                        pre.push([
                            "var ",
                            localStr,
                            "=",
                            arrStr,
                            "[",
                            ptrStr,
                            "]"
                        ].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                        ;
                        code = code.replace(re, localStr);
                        if (carg.lvalue) {
                            post.push([
                                arrStr,
                                "[",
                                ptrStr,
                                "]=",
                                localStr
                            ].join(""));
                        }
                    }
                } else {
                    var reStrArr = [
                        carg.name
                    ], ptrStrArr = [
                        ptrStr
                    ];
                    for(var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++){
                        reStrArr.push("\\s*\\[([^\\]]+)\\]");
                        ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j) // Matched index times stride
                        ;
                    }
                    re = new RegExp(reStrArr.join(""), "g");
                    ptrStr = ptrStrArr.join("+");
                    if (dtypes[arrNum] === "generic") {
                        /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/ throw new Error("cwise: Generic arrays not supported in combination with blocks!");
                    } else {
                        // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
                        code = code.replace(re, [
                            arrStr,
                            "[",
                            ptrStr,
                            "]"
                        ].join(""));
                    }
                }
                break;
            case "scalar":
                code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
                break;
            case "index":
                code = code.replace(re, "index");
                break;
            case "shape":
                code = code.replace(re, "shape");
                break;
        }
    }
    return [
        pre.join("\n"),
        code,
        post.join("\n")
    ].join("\n").trim();
}
function typeSummary(dtypes) {
    var summary = new Array(dtypes.length);
    var allEqual = true;
    for(var i = 0; i < dtypes.length; ++i){
        var t = dtypes[i];
        var digits = t.match(/\d+/);
        if (!digits) {
            digits = "";
        } else {
            digits = digits[0];
        }
        if (t.charAt(0) === 0) {
            summary[i] = "u" + t.charAt(1) + digits;
        } else {
            summary[i] = t.charAt(0) + digits;
        }
        if (i > 0) {
            allEqual = allEqual && summary[i] === summary[i - 1];
        }
    }
    if (allEqual) {
        return summary[0];
    }
    return summary.join("");
}
//Generates a cwise operator
function generateCWiseOp(proc, typesig) {
    //Compute dimension
    // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
    var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
    var orders = new Array(proc.arrayArgs.length);
    var dtypes = new Array(proc.arrayArgs.length);
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        dtypes[i] = typesig[2 * i];
        orders[i] = typesig[2 * i + 1];
    }
    //Determine where block and loop indices start and end
    var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
    ;
    var loopBegin = [], loopEnd = [] // These indices are iterated over
    ;
    var loopOrders = [] // orders restricted to the loop indices
    ;
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        if (proc.arrayBlockIndices[i] < 0) {
            loopBegin.push(0);
            loopEnd.push(dimension);
            blockBegin.push(dimension);
            blockEnd.push(dimension + proc.arrayBlockIndices[i]);
        } else {
            loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
            ;
            loopEnd.push(proc.arrayBlockIndices[i] + dimension);
            blockBegin.push(0);
            blockEnd.push(proc.arrayBlockIndices[i]);
        }
        var newOrder = [];
        for(var j = 0; j < orders[i].length; j++){
            if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
                newOrder.push(orders[i][j] - loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
                ;
            }
        }
        loopOrders.push(newOrder);
    }
    //First create arguments for procedure
    var arglist = [
        "SS"
    ] // SS is the overall shape over which we iterate
    ;
    var code = [
        "'use strict'"
    ];
    var vars = [];
    for(var j = 0; j < dimension; ++j){
        vars.push([
            "s",
            j,
            "=SS[",
            j,
            "]"
        ].join("")) // The limits for each dimension.
        ;
    }
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        arglist.push("a" + i) // Actual data array
        ;
        arglist.push("t" + i) // Strides
        ;
        arglist.push("p" + i) // Offset in the array at which the data starts (also used for iterating over the data)
        ;
        for(var j = 0; j < dimension; ++j){
            vars.push([
                "t",
                i,
                "p",
                j,
                "=t",
                i,
                "[",
                loopBegin[i] + j,
                "]"
            ].join(""));
        }
        for(var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j){
            vars.push([
                "t",
                i,
                "b",
                j,
                "=t",
                i,
                "[",
                blockBegin[i] + j,
                "]"
            ].join(""));
        }
    }
    for(var i = 0; i < proc.scalarArgs.length; ++i){
        arglist.push("Y" + i);
    }
    if (proc.shapeArgs.length > 0) {
        vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
        ;
    }
    if (proc.indexArgs.length > 0) {
        // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
        var zeros = new Array(dimension);
        for(var i = 0; i < dimension; ++i){
            zeros[i] = "0";
        }
        vars.push([
            "index=[",
            zeros.join(","),
            "]"
        ].join(""));
    }
    for(var i = 0; i < proc.offsetArgs.length; ++i){
        var off_arg = proc.offsetArgs[i];
        var init_string = [];
        for(var j = 0; j < off_arg.offset.length; ++j){
            if (off_arg.offset[j] === 0) {
                continue;
            } else if (off_arg.offset[j] === 1) {
                init_string.push([
                    "t",
                    off_arg.array,
                    "p",
                    j
                ].join(""));
            } else {
                init_string.push([
                    off_arg.offset[j],
                    "*t",
                    off_arg.array,
                    "p",
                    j
                ].join(""));
            }
        }
        if (init_string.length === 0) {
            vars.push("q" + i + "=0");
        } else {
            vars.push([
                "q",
                i,
                "=",
                init_string.join("+")
            ].join(""));
        }
    }
    //Prepare this variables
    var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
    vars = vars.concat(thisVars);
    if (vars.length > 0) {
        code.push("var " + vars.join(","));
    }
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        code.push("p" + i + "|=0");
    }
    //Inline prelude
    if (proc.pre.body.length > 3) {
        code.push(processBlock(proc.pre, proc, dtypes));
    }
    //Process body
    var body = processBlock(proc.body, proc, dtypes);
    var matched = countMatches(loopOrders);
    if (matched < dimension) {
        code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
        ;
    } else {
        code.push(innerFill(loopOrders[0], proc, body));
    }
    //Inline epilog
    if (proc.post.body.length > 3) {
        code.push(processBlock(proc.post, proc, dtypes));
    }
    if (proc.debug) {
        console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
    }
    var loopName = [
        proc.funcName || "unnamed",
        "_cwise_loop_",
        orders[0].join("s"),
        "m",
        matched,
        typeSummary(dtypes)
    ].join("");
    var f = new Function([
        "function ",
        loopName,
        "(",
        arglist.join(","),
        "){",
        code.join("\n"),
        "} return ",
        loopName
    ].join(""));
    return f();
}
module.exports = generateCWiseOp;
}}),
"[project]/node_modules/cwise-compiler/lib/thunk.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }
var compile = __turbopack_context__.r("[project]/node_modules/cwise-compiler/lib/compile.js [app-client] (ecmascript)");
function createThunk(proc) {
    var code = [
        "'use strict'",
        "var CACHED={}"
    ];
    var vars = [];
    var thunkName = proc.funcName + "_cwise_thunk";
    //Build thunk
    code.push([
        "return function ",
        thunkName,
        "(",
        proc.shimArgs.join(","),
        "){"
    ].join(""));
    var typesig = [];
    var string_typesig = [];
    var proc_args = [
        [
            "array",
            proc.arrayArgs[0],
            ".shape.slice(",
            Math.max(0, proc.arrayBlockIndices[0]),
            proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"
        ].join("")
    ];
    var shapeLengthConditions = [], shapeConditions = [];
    // Process array arguments
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        var j = proc.arrayArgs[i];
        vars.push([
            "t",
            j,
            "=array",
            j,
            ".dtype,",
            "r",
            j,
            "=array",
            j,
            ".order"
        ].join(""));
        typesig.push("t" + j);
        typesig.push("r" + j);
        string_typesig.push("t" + j);
        string_typesig.push("r" + j + ".join()");
        proc_args.push("array" + j + ".data");
        proc_args.push("array" + j + ".stride");
        proc_args.push("array" + j + ".offset|0");
        if (i > 0) {
            shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
            shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
        }
    }
    // Check for shape equality
    if (proc.arrayArgs.length > 1) {
        code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
        code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
        code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
        code.push("}");
    }
    // Process scalar arguments
    for(var i = 0; i < proc.scalarArgs.length; ++i){
        proc_args.push("scalar" + proc.scalarArgs[i]);
    }
    // Check for cached function (and if not present, generate it)
    vars.push([
        "type=[",
        string_typesig.join(","),
        "].join()"
    ].join(""));
    vars.push("proc=CACHED[type]");
    code.push("var " + vars.join(","));
    code.push([
        "if(!proc){",
        "CACHED[type]=proc=compile([",
        typesig.join(","),
        "])}",
        "return proc(",
        proc_args.join(","),
        ")}"
    ].join(""));
    if (proc.debug) {
        console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
    }
    //Compile thunk
    var thunk = new Function("compile", code.join("\n"));
    return thunk(compile.bind(undefined, proc));
}
module.exports = createThunk;
}}),
"[project]/node_modules/cwise-compiler/compiler.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var createThunk = __turbopack_context__.r("[project]/node_modules/cwise-compiler/lib/thunk.js [app-client] (ecmascript)");
function Procedure() {
    this.argTypes = [];
    this.shimArgs = [];
    this.arrayArgs = [];
    this.arrayBlockIndices = [];
    this.scalarArgs = [];
    this.offsetArgs = [];
    this.offsetArgIndex = [];
    this.indexArgs = [];
    this.shapeArgs = [];
    this.funcName = "";
    this.pre = null;
    this.body = null;
    this.post = null;
    this.debug = false;
}
function compileCwise(user_args) {
    //Create procedure
    var proc = new Procedure();
    //Parse blocks
    proc.pre = user_args.pre;
    proc.body = user_args.body;
    proc.post = user_args.post;
    //Parse arguments
    var proc_args = user_args.args.slice(0);
    proc.argTypes = proc_args;
    for(var i = 0; i < proc_args.length; ++i){
        var arg_type = proc_args[i];
        if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
            proc.argTypes[i] = "array";
            proc.arrayArgs.push(i);
            proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
            proc.shimArgs.push("array" + i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                throw new Error("cwise: pre() block may not reference array args");
            }
            if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                throw new Error("cwise: post() block may not reference array args");
            }
        } else if (arg_type === "scalar") {
            proc.scalarArgs.push(i);
            proc.shimArgs.push("scalar" + i);
        } else if (arg_type === "index") {
            proc.indexArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                throw new Error("cwise: pre() block may not reference array index");
            }
            if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                throw new Error("cwise: body() block may not write to array index");
            }
            if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                throw new Error("cwise: post() block may not reference array index");
            }
        } else if (arg_type === "shape") {
            proc.shapeArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
                throw new Error("cwise: pre() block may not write to array shape");
            }
            if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                throw new Error("cwise: body() block may not write to array shape");
            }
            if (i < proc.post.args.length && proc.post.args[i].lvalue) {
                throw new Error("cwise: post() block may not write to array shape");
            }
        } else if (typeof arg_type === "object" && arg_type.offset) {
            proc.argTypes[i] = "offset";
            proc.offsetArgs.push({
                array: arg_type.array,
                offset: arg_type.offset
            });
            proc.offsetArgIndex.push(i);
        } else {
            throw new Error("cwise: Unknown argument type " + proc_args[i]);
        }
    }
    //Make sure at least one array argument was specified
    if (proc.arrayArgs.length <= 0) {
        throw new Error("cwise: No array arguments specified");
    }
    //Make sure arguments are correct
    if (proc.pre.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in pre() block");
    }
    if (proc.body.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in body() block");
    }
    if (proc.post.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in post() block");
    }
    //Check debug flag
    proc.debug = !!user_args.printCode || !!user_args.debug;
    //Retrieve name
    proc.funcName = user_args.funcName || "cwise";
    //Read in block size
    proc.blockSize = user_args.blockSize || 64;
    return createThunk(proc);
}
module.exports = compileCwise;
}}),
"[project]/node_modules/ndarray-ops/ndarray-ops.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var compile = __turbopack_context__.r("[project]/node_modules/cwise-compiler/compiler.js [app-client] (ecmascript)");
var EmptyProc = {
    body: "",
    args: [],
    thisVars: [],
    localVars: []
};
function fixup(x) {
    if (!x) {
        return EmptyProc;
    }
    for(var i = 0; i < x.args.length; ++i){
        var a = x.args[i];
        if (i === 0) {
            x.args[i] = {
                name: a,
                lvalue: true,
                rvalue: !!x.rvalue,
                count: x.count || 1
            };
        } else {
            x.args[i] = {
                name: a,
                lvalue: false,
                rvalue: true,
                count: 1
            };
        }
    }
    if (!x.thisVars) {
        x.thisVars = [];
    }
    if (!x.localVars) {
        x.localVars = [];
    }
    return x;
}
function pcompile(user_args) {
    return compile({
        args: user_args.args,
        pre: fixup(user_args.pre),
        body: fixup(user_args.body),
        post: fixup(user_args.proc),
        funcName: user_args.funcName
    });
}
function makeOp(user_args) {
    var args = [];
    for(var i = 0; i < user_args.args.length; ++i){
        args.push("a" + i);
    }
    var wrapper = new Function("P", [
        "return function ",
        user_args.funcName,
        "_ndarrayops(",
        args.join(","),
        ") {P(",
        args.join(","),
        ");return a0}"
    ].join(""));
    return wrapper(pcompile(user_args));
}
var assign_ops = {
    add: "+",
    sub: "-",
    mul: "*",
    div: "/",
    mod: "%",
    band: "&",
    bor: "|",
    bxor: "^",
    lshift: "<<",
    rshift: ">>",
    rrshift: ">>>"
};
(function() {
    for(var id in assign_ops){
        var op = assign_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=b" + op + "c"
            },
            funcName: id
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a" + op + "=b"
            },
            rvalue: true,
            funcName: id + "eq"
        });
        exports[id + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "s"
                ],
                body: "a=b" + op + "s"
            },
            funcName: id + "s"
        });
        exports[id + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "s"
                ],
                body: "a" + op + "=s"
            },
            rvalue: true,
            funcName: id + "seq"
        });
    }
})();
var unary_ops = {
    not: "!",
    bnot: "~",
    neg: "-",
    recip: "1.0/"
};
(function() {
    for(var id in unary_ops){
        var op = unary_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=" + op + "b"
            },
            funcName: id
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array"
            ],
            body: {
                args: [
                    "a"
                ],
                body: "a=" + op + "a"
            },
            rvalue: true,
            count: 2,
            funcName: id + "eq"
        });
    }
})();
var binary_ops = {
    and: "&&",
    or: "||",
    eq: "===",
    neq: "!==",
    lt: "<",
    gt: ">",
    leq: "<=",
    geq: ">="
};
(function() {
    for(var id in binary_ops){
        var op = binary_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=b" + op + "c"
            },
            funcName: id
        });
        exports[id + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "s"
                ],
                body: "a=b" + op + "s"
            },
            funcName: id + "s"
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=a" + op + "b"
            },
            rvalue: true,
            count: 2,
            funcName: id + "eq"
        });
        exports[id + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "s"
                ],
                body: "a=a" + op + "s"
            },
            rvalue: true,
            count: 2,
            funcName: id + "seq"
        });
    }
})();
var math_unary = [
    "abs",
    "acos",
    "asin",
    "atan",
    "ceil",
    "cos",
    "exp",
    "floor",
    "log",
    "round",
    "sin",
    "sqrt",
    "tan"
];
(function() {
    for(var i = 0; i < math_unary.length; ++i){
        var f = math_unary[i];
        exports[f] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f
        });
        exports[f + "eq"] = makeOp({
            args: [
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a"
                ],
                body: "a=this_f(a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "eq"
        });
    }
})();
var math_comm = [
    "max",
    "min",
    "atan2",
    "pow"
];
(function() {
    for(var i = 0; i < math_comm.length; ++i){
        var f = math_comm[i];
        exports[f] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(b,c)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f
        });
        exports[f + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(b,c)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "s"
        });
        exports[f + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(a,b)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "eq"
        });
        exports[f + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(a,b)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "seq"
        });
    }
})();
var math_noncomm = [
    "atan2",
    "pow"
];
(function() {
    for(var i = 0; i < math_noncomm.length; ++i){
        var f = math_noncomm[i];
        exports[f + "op"] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(c,b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "op"
        });
        exports[f + "ops"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(c,b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "ops"
        });
        exports[f + "opeq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b,a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "opeq"
        });
        exports[f + "opseq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b,a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "opseq"
        });
    }
})();
exports.any = compile({
    args: [
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(a){return true}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return false"
    },
    funcName: "any"
});
exports.all = compile({
    args: [
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "x",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(!x){return false}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return true"
    },
    funcName: "all"
});
exports.sum = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "this_s+=a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "sum"
});
exports.prod = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=1"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "this_s*=a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "prod"
});
exports.norm2squared = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        body: "this_s+=a*a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norm2squared"
});
exports.norm2 = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        body: "this_s+=a*a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return Math.sqrt(this_s)"
    },
    funcName: "norm2"
});
exports.norminf = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 4
            }
        ],
        body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norminf"
});
exports.norm1 = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 3
            }
        ],
        body: "this_s+=a<0?-a:a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norm1"
});
exports.sup = compile({
    args: [
        "array"
    ],
    pre: {
        body: "this_h=-Infinity",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    body: {
        body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
        args: [
            {
                "name": "_inline_1_arg0_",
                "lvalue": false,
                "rvalue": true,
                "count": 2
            }
        ],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    post: {
        body: "return this_h",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    }
});
exports.inf = compile({
    args: [
        "array"
    ],
    pre: {
        body: "this_h=Infinity",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    body: {
        body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
        args: [
            {
                "name": "_inline_1_arg0_",
                "lvalue": false,
                "rvalue": true,
                "count": 2
            }
        ],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    post: {
        body: "return this_h",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    }
});
exports.argmin = compile({
    args: [
        "index",
        "array",
        "shape"
    ],
    pre: {
        body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
            {
                name: "_inline_0_arg0_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg1_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg2_",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: []
    },
    body: {
        body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
            {
                name: "_inline_1_arg0_",
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: "_inline_1_arg1_",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: [
            "_inline_1_k"
        ]
    },
    post: {
        body: "{return this_i}",
        args: [],
        thisVars: [
            "this_i"
        ],
        localVars: []
    }
});
exports.argmax = compile({
    args: [
        "index",
        "array",
        "shape"
    ],
    pre: {
        body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
            {
                name: "_inline_0_arg0_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg1_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg2_",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: []
    },
    body: {
        body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
            {
                name: "_inline_1_arg0_",
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: "_inline_1_arg1_",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: [
            "_inline_1_k"
        ]
    },
    post: {
        body: "{return this_i}",
        args: [],
        thisVars: [
            "this_i"
        ],
        localVars: []
    }
});
exports.random = makeOp({
    args: [
        "array"
    ],
    pre: {
        args: [],
        body: "this_f=Math.random",
        thisVars: [
            "this_f"
        ]
    },
    body: {
        args: [
            "a"
        ],
        body: "a=this_f()",
        thisVars: [
            "this_f"
        ]
    },
    funcName: "random"
});
exports.assign = makeOp({
    args: [
        "array",
        "array"
    ],
    body: {
        args: [
            "a",
            "b"
        ],
        body: "a=b"
    },
    funcName: "assign"
});
exports.assigns = makeOp({
    args: [
        "array",
        "scalar"
    ],
    body: {
        args: [
            "a",
            "b"
        ],
        body: "a=b"
    },
    funcName: "assigns"
});
exports.equals = compile({
    args: [
        "array",
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "x",
                lvalue: false,
                rvalue: true,
                count: 1
            },
            {
                name: "y",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(x!==y){return false}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return true"
    },
    funcName: "equals"
});
}}),
"[project]/node_modules/bit-twiddle/twiddle.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */ "use strict";
"use restrict";
//Number of bits in an integer
var INT_BITS = 32;
//Constants
exports.INT_BITS = INT_BITS;
exports.INT_MAX = 0x7fffffff;
exports.INT_MIN = -1 << INT_BITS - 1;
//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
    return (v > 0) - (v < 0);
};
//Computes absolute value of integer
exports.abs = function(v) {
    var mask = v >> INT_BITS - 1;
    return (v ^ mask) - mask;
};
//Computes minimum of integers x and y
exports.min = function(x, y) {
    return y ^ (x ^ y) & -(x < y);
};
//Computes maximum of integers x and y
exports.max = function(x, y) {
    return x ^ (x ^ y) & -(x < y);
};
//Checks if a number is a power of two
exports.isPow2 = function(v) {
    return !(v & v - 1) && !!v;
};
//Computes log base 2 of v
exports.log2 = function(v) {
    var r, shift;
    r = (v > 0xFFFF) << 4;
    v >>>= r;
    shift = (v > 0xFF) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 0xF) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 0x3) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
};
//Computes log base 10 of v
exports.log10 = function(v) {
    return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
};
//Counts number of bits
exports.popCount = function(v) {
    v = v - (v >>> 1 & 0x55555555);
    v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
    return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
};
//Counts number of trailing zeros
function countTrailingZeros(v) {
    var c = 32;
    v &= -v;
    if (v) c--;
    if (v & 0x0000FFFF) c -= 16;
    if (v & 0x00FF00FF) c -= 8;
    if (v & 0x0F0F0F0F) c -= 4;
    if (v & 0x33333333) c -= 2;
    if (v & 0x55555555) c -= 1;
    return c;
}
exports.countTrailingZeros = countTrailingZeros;
//Rounds to next power of 2
exports.nextPow2 = function(v) {
    v += v === 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
};
//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v - (v >>> 1);
};
//Computes parity of word
exports.parity = function(v) {
    v ^= v >>> 16;
    v ^= v >>> 8;
    v ^= v >>> 4;
    v &= 0xf;
    return 0x6996 >>> v & 1;
};
var REVERSE_TABLE = new Array(256);
(function(tab) {
    for(var i = 0; i < 256; ++i){
        var v = i, r = i, s = 7;
        for(v >>>= 1; v; v >>>= 1){
            r <<= 1;
            r |= v & 1;
            --s;
        }
        tab[i] = r << s & 0xff;
    }
})(REVERSE_TABLE);
//Reverse bits in a 32 bit word
exports.reverse = function(v) {
    return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
};
//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
    x &= 0xFFFF;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y &= 0xFFFF;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
};
//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
    v = v >>> n & 0x55555555;
    v = (v | v >>> 1) & 0x33333333;
    v = (v | v >>> 2) & 0x0F0F0F0F;
    v = (v | v >>> 4) & 0x00FF00FF;
    v = (v | v >>> 16) & 0x000FFFF;
    return v << 16 >> 16;
};
//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
    x &= 0x3FF;
    x = (x | x << 16) & 4278190335;
    x = (x | x << 8) & 251719695;
    x = (x | x << 4) & 3272356035;
    x = (x | x << 2) & 1227133513;
    y &= 0x3FF;
    y = (y | y << 16) & 4278190335;
    y = (y | y << 8) & 251719695;
    y = (y | y << 4) & 3272356035;
    y = (y | y << 2) & 1227133513;
    x |= y << 1;
    z &= 0x3FF;
    z = (z | z << 16) & 4278190335;
    z = (z | z << 8) & 251719695;
    z = (z | z << 4) & 3272356035;
    z = (z | z << 2) & 1227133513;
    return x | z << 2;
};
//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
    v = v >>> n & 1227133513;
    v = (v | v >>> 2) & 3272356035;
    v = (v | v >>> 4) & 251719695;
    v = (v | v >>> 8) & 4278190335;
    v = (v | v >>> 16) & 0x3FF;
    return v << 22 >> 22;
};
//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
    var t = v | v - 1;
    return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
};
}}),
"[project]/node_modules/dup/dup.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function dupe_array(count, value, i) {
    var c = count[i] | 0;
    if (c <= 0) {
        return [];
    }
    var result = new Array(c), j;
    if (i === count.length - 1) {
        for(j = 0; j < c; ++j){
            result[j] = value;
        }
    } else {
        for(j = 0; j < c; ++j){
            result[j] = dupe_array(count, value, i + 1);
        }
    }
    return result;
}
function dupe_number(count, value) {
    var result, i;
    result = new Array(count);
    for(i = 0; i < count; ++i){
        result[i] = value;
    }
    return result;
}
function dupe(count, value) {
    if (typeof value === "undefined") {
        value = 0;
    }
    switch(typeof count){
        case "number":
            if (count > 0) {
                return dupe_number(count | 0, value);
            }
            break;
        case "object":
            if (typeof count.length === "number") {
                return dupe_array(count, value, 0);
            }
            break;
    }
    return [];
}
module.exports = dupe;
}}),
"[project]/node_modules/typedarray-pool/pool.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var bits = __turbopack_context__.r("[project]/node_modules/bit-twiddle/twiddle.js [app-client] (ecmascript)");
var dup = __turbopack_context__.r("[project]/node_modules/dup/dup.js [app-client] (ecmascript)");
var Buffer = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)").Buffer;
//Legacy pool support
if (!global.__TYPEDARRAY_POOL) {
    global.__TYPEDARRAY_POOL = {
        UINT8: dup([
            32,
            0
        ]),
        UINT16: dup([
            32,
            0
        ]),
        UINT32: dup([
            32,
            0
        ]),
        BIGUINT64: dup([
            32,
            0
        ]),
        INT8: dup([
            32,
            0
        ]),
        INT16: dup([
            32,
            0
        ]),
        INT32: dup([
            32,
            0
        ]),
        BIGINT64: dup([
            32,
            0
        ]),
        FLOAT: dup([
            32,
            0
        ]),
        DOUBLE: dup([
            32,
            0
        ]),
        DATA: dup([
            32,
            0
        ]),
        UINT8C: dup([
            32,
            0
        ]),
        BUFFER: dup([
            32,
            0
        ])
    };
}
var hasUint8C = typeof Uint8ClampedArray !== 'undefined';
var hasBigUint64 = typeof BigUint64Array !== 'undefined';
var hasBigInt64 = typeof BigInt64Array !== 'undefined';
var POOL = global.__TYPEDARRAY_POOL;
//Upgrade pool
if (!POOL.UINT8C) {
    POOL.UINT8C = dup([
        32,
        0
    ]);
}
if (!POOL.BIGUINT64) {
    POOL.BIGUINT64 = dup([
        32,
        0
    ]);
}
if (!POOL.BIGINT64) {
    POOL.BIGINT64 = dup([
        32,
        0
    ]);
}
if (!POOL.BUFFER) {
    POOL.BUFFER = dup([
        32,
        0
    ]);
}
//New technique: Only allocate from ArrayBufferView and Buffer
var DATA = POOL.DATA, BUFFER = POOL.BUFFER;
exports.free = function free(array) {
    if (Buffer.isBuffer(array)) {
        BUFFER[bits.log2(array.length)].push(array);
    } else {
        if (Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
            array = array.buffer;
        }
        if (!array) {
            return;
        }
        var n = array.length || array.byteLength;
        var log_n = bits.log2(n) | 0;
        DATA[log_n].push(array);
    }
};
function freeArrayBuffer(buffer) {
    if (!buffer) {
        return;
    }
    var n = buffer.length || buffer.byteLength;
    var log_n = bits.log2(n);
    DATA[log_n].push(buffer);
}
function freeTypedArray(array) {
    freeArrayBuffer(array.buffer);
}
exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeBigUint64 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeBigInt64 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;
exports.freeArrayBuffer = freeArrayBuffer;
exports.freeBuffer = function freeBuffer(array) {
    BUFFER[bits.log2(array.length)].push(array);
};
exports.malloc = function malloc(n, dtype) {
    if (dtype === undefined || dtype === 'arraybuffer') {
        return mallocArrayBuffer(n);
    } else {
        switch(dtype){
            case 'uint8':
                return mallocUint8(n);
            case 'uint16':
                return mallocUint16(n);
            case 'uint32':
                return mallocUint32(n);
            case 'int8':
                return mallocInt8(n);
            case 'int16':
                return mallocInt16(n);
            case 'int32':
                return mallocInt32(n);
            case 'float':
            case 'float32':
                return mallocFloat(n);
            case 'double':
            case 'float64':
                return mallocDouble(n);
            case 'uint8_clamped':
                return mallocUint8Clamped(n);
            case 'bigint64':
                return mallocBigInt64(n);
            case 'biguint64':
                return mallocBigUint64(n);
            case 'buffer':
                return mallocBuffer(n);
            case 'data':
            case 'dataview':
                return mallocDataView(n);
            default:
                return null;
        }
    }
    return null;
};
function mallocArrayBuffer(n) {
    var n = bits.nextPow2(n);
    var log_n = bits.log2(n);
    var d = DATA[log_n];
    if (d.length > 0) {
        return d.pop();
    }
    return new ArrayBuffer(n);
}
exports.mallocArrayBuffer = mallocArrayBuffer;
function mallocUint8(n) {
    return new Uint8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocUint8 = mallocUint8;
function mallocUint16(n) {
    return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocUint16 = mallocUint16;
function mallocUint32(n) {
    return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocUint32 = mallocUint32;
function mallocInt8(n) {
    return new Int8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocInt8 = mallocInt8;
function mallocInt16(n) {
    return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocInt16 = mallocInt16;
function mallocInt32(n) {
    return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocInt32 = mallocInt32;
function mallocFloat(n) {
    return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat;
function mallocDouble(n) {
    return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble;
function mallocUint8Clamped(n) {
    if (hasUint8C) {
        return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
    } else {
        return mallocUint8(n);
    }
}
exports.mallocUint8Clamped = mallocUint8Clamped;
function mallocBigUint64(n) {
    if (hasBigUint64) {
        return new BigUint64Array(mallocArrayBuffer(8 * n), 0, n);
    } else {
        return null;
    }
}
exports.mallocBigUint64 = mallocBigUint64;
function mallocBigInt64(n) {
    if (hasBigInt64) {
        return new BigInt64Array(mallocArrayBuffer(8 * n), 0, n);
    } else {
        return null;
    }
}
exports.mallocBigInt64 = mallocBigInt64;
function mallocDataView(n) {
    return new DataView(mallocArrayBuffer(n), 0, n);
}
exports.mallocDataView = mallocDataView;
function mallocBuffer(n) {
    n = bits.nextPow2(n);
    var log_n = bits.log2(n);
    var cache = BUFFER[log_n];
    if (cache.length > 0) {
        return cache.pop();
    }
    return new Buffer(n);
}
exports.mallocBuffer = mallocBuffer;
exports.clearCache = function clearCache() {
    for(var i = 0; i < 32; ++i){
        POOL.UINT8[i].length = 0;
        POOL.UINT16[i].length = 0;
        POOL.UINT32[i].length = 0;
        POOL.INT8[i].length = 0;
        POOL.INT16[i].length = 0;
        POOL.INT32[i].length = 0;
        POOL.FLOAT[i].length = 0;
        POOL.DOUBLE[i].length = 0;
        POOL.BIGUINT64[i].length = 0;
        POOL.BIGINT64[i].length = 0;
        POOL.UINT8C[i].length = 0;
        DATA[i].length = 0;
        BUFFER[i].length = 0;
    }
};
}}),
"[project]/node_modules/ndarray-fft/lib/fft-matrix.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var bits = __turbopack_context__.r("[project]/node_modules/bit-twiddle/twiddle.js [app-client] (ecmascript)");
function fft(dir, nrows, ncols, buffer, x_ptr, y_ptr, scratch_ptr) {
    dir |= 0;
    nrows |= 0;
    ncols |= 0;
    x_ptr |= 0;
    y_ptr |= 0;
    if (bits.isPow2(ncols)) {
        fftRadix2(dir, nrows, ncols, buffer, x_ptr, y_ptr);
    } else {
        fftBluestein(dir, nrows, ncols, buffer, x_ptr, y_ptr, scratch_ptr);
    }
}
module.exports = fft;
function scratchMemory(n) {
    if (bits.isPow2(n)) {
        return 0;
    }
    return 2 * n + 4 * bits.nextPow2(2 * n + 1);
}
module.exports.scratchMemory = scratchMemory;
//Radix 2 FFT Adapted from Paul Bourke's C Implementation
function fftRadix2(dir, nrows, ncols, buffer, x_ptr, y_ptr) {
    dir |= 0;
    nrows |= 0;
    ncols |= 0;
    x_ptr |= 0;
    y_ptr |= 0;
    var nn, m, i, i1, j, k, i2, l, l1, l2;
    var c1, c2, t, t1, t2, u1, u2, z, row, a, b, c, d, k1, k2, k3;
    // Calculate the number of points
    nn = ncols;
    m = bits.log2(nn);
    for(row = 0; row < nrows; ++row){
        // Do the bit reversal
        i2 = nn >> 1;
        j = 0;
        for(i = 0; i < nn - 1; i++){
            if (i < j) {
                t = buffer[x_ptr + i];
                buffer[x_ptr + i] = buffer[x_ptr + j];
                buffer[x_ptr + j] = t;
                t = buffer[y_ptr + i];
                buffer[y_ptr + i] = buffer[y_ptr + j];
                buffer[y_ptr + j] = t;
            }
            k = i2;
            while(k <= j){
                j -= k;
                k >>= 1;
            }
            j += k;
        }
        // Compute the FFT
        c1 = -1.0;
        c2 = 0.0;
        l2 = 1;
        for(l = 0; l < m; l++){
            l1 = l2;
            l2 <<= 1;
            u1 = 1.0;
            u2 = 0.0;
            for(j = 0; j < l1; j++){
                for(i = j; i < nn; i += l2){
                    i1 = i + l1;
                    a = buffer[x_ptr + i1];
                    b = buffer[y_ptr + i1];
                    c = buffer[x_ptr + i];
                    d = buffer[y_ptr + i];
                    k1 = u1 * (a + b);
                    k2 = a * (u2 - u1);
                    k3 = b * (u1 + u2);
                    t1 = k1 - k3;
                    t2 = k1 + k2;
                    buffer[x_ptr + i1] = c - t1;
                    buffer[y_ptr + i1] = d - t2;
                    buffer[x_ptr + i] += t1;
                    buffer[y_ptr + i] += t2;
                }
                k1 = c1 * (u1 + u2);
                k2 = u1 * (c2 - c1);
                k3 = u2 * (c1 + c2);
                u1 = k1 - k3;
                u2 = k1 + k2;
            }
            c2 = Math.sqrt((1.0 - c1) / 2.0);
            if (dir < 0) {
                c2 = -c2;
            }
            c1 = Math.sqrt((1.0 + c1) / 2.0);
        }
        // Scaling for inverse transform
        if (dir < 0) {
            var scale_f = 1.0 / nn;
            for(i = 0; i < nn; i++){
                buffer[x_ptr + i] *= scale_f;
                buffer[y_ptr + i] *= scale_f;
            }
        }
        // Advance pointers
        x_ptr += ncols;
        y_ptr += ncols;
    }
}
// Use Bluestein algorithm for npot FFTs
// Scratch memory required:  2 * ncols + 4 * bits.nextPow2(2*ncols + 1)
function fftBluestein(dir, nrows, ncols, buffer, x_ptr, y_ptr, scratch_ptr) {
    dir |= 0;
    nrows |= 0;
    ncols |= 0;
    x_ptr |= 0;
    y_ptr |= 0;
    scratch_ptr |= 0;
    // Initialize tables
    var m = bits.nextPow2(2 * ncols + 1), cos_ptr = scratch_ptr, sin_ptr = cos_ptr + ncols, xs_ptr = sin_ptr + ncols, ys_ptr = xs_ptr + m, cft_ptr = ys_ptr + m, sft_ptr = cft_ptr + m, w = -dir * Math.PI / ncols, row, a, b, c, d, k1, k2, k3, i;
    for(i = 0; i < ncols; ++i){
        a = w * (i * i % (ncols * 2));
        c = Math.cos(a);
        d = Math.sin(a);
        buffer[cft_ptr + (m - i)] = buffer[cft_ptr + i] = buffer[cos_ptr + i] = c;
        buffer[sft_ptr + (m - i)] = buffer[sft_ptr + i] = buffer[sin_ptr + i] = d;
    }
    for(i = ncols; i <= m - ncols; ++i){
        buffer[cft_ptr + i] = 0.0;
    }
    for(i = ncols; i <= m - ncols; ++i){
        buffer[sft_ptr + i] = 0.0;
    }
    fftRadix2(1, 1, m, buffer, cft_ptr, sft_ptr);
    //Compute scale factor
    if (dir < 0) {
        w = 1.0 / ncols;
    } else {
        w = 1.0;
    }
    //Handle direction
    for(row = 0; row < nrows; ++row){
        // Copy row into scratch memory, multiply weights
        for(i = 0; i < ncols; ++i){
            a = buffer[x_ptr + i];
            b = buffer[y_ptr + i];
            c = buffer[cos_ptr + i];
            d = -buffer[sin_ptr + i];
            k1 = c * (a + b);
            k2 = a * (d - c);
            k3 = b * (c + d);
            buffer[xs_ptr + i] = k1 - k3;
            buffer[ys_ptr + i] = k1 + k2;
        }
        //Zero out the rest
        for(i = ncols; i < m; ++i){
            buffer[xs_ptr + i] = 0.0;
        }
        for(i = ncols; i < m; ++i){
            buffer[ys_ptr + i] = 0.0;
        }
        // FFT buffer
        fftRadix2(1, 1, m, buffer, xs_ptr, ys_ptr);
        // Apply multiplier
        for(i = 0; i < m; ++i){
            a = buffer[xs_ptr + i];
            b = buffer[ys_ptr + i];
            c = buffer[cft_ptr + i];
            d = buffer[sft_ptr + i];
            k1 = c * (a + b);
            k2 = a * (d - c);
            k3 = b * (c + d);
            buffer[xs_ptr + i] = k1 - k3;
            buffer[ys_ptr + i] = k1 + k2;
        }
        // Inverse FFT buffer
        fftRadix2(-1, 1, m, buffer, xs_ptr, ys_ptr);
        // Copy result back into x/y
        for(i = 0; i < ncols; ++i){
            a = buffer[xs_ptr + i];
            b = buffer[ys_ptr + i];
            c = buffer[cos_ptr + i];
            d = -buffer[sin_ptr + i];
            k1 = c * (a + b);
            k2 = a * (d - c);
            k3 = b * (c + d);
            buffer[x_ptr + i] = w * (k1 - k3);
            buffer[y_ptr + i] = w * (k1 + k2);
        }
        x_ptr += ncols;
        y_ptr += ncols;
    }
}
}}),
"[project]/node_modules/ndarray-fft/fft.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var ops = __turbopack_context__.r("[project]/node_modules/ndarray-ops/ndarray-ops.js [app-client] (ecmascript)");
var ndarray = __turbopack_context__.r("[project]/node_modules/ndarray/ndarray.js [app-client] (ecmascript)");
var pool = __turbopack_context__.r("[project]/node_modules/typedarray-pool/pool.js [app-client] (ecmascript)");
var fftm = __turbopack_context__.r("[project]/node_modules/ndarray-fft/lib/fft-matrix.js [app-client] (ecmascript)");
function ndfft(dir, x, y) {
    var shape = x.shape, d = shape.length, size = 1, stride = new Array(d), pad = 0, i, j;
    for(i = d - 1; i >= 0; --i){
        stride[i] = size;
        size *= shape[i];
        pad = Math.max(pad, fftm.scratchMemory(shape[i]));
        if (x.shape[i] !== y.shape[i]) {
            throw new Error('Shape mismatch, real and imaginary arrays must have same size');
        }
    }
    var buf_size = 4 * size + pad;
    var buffer;
    if (x.dtype === 'array' || x.dtype === 'float64' || x.dtype === 'custom') {
        buffer = pool.mallocDouble(buf_size);
    } else {
        buffer = pool.mallocFloat(buf_size);
    }
    var x1 = ndarray(buffer, shape.slice(0), stride, 0), y1 = ndarray(buffer, shape.slice(0), stride.slice(0), size), x2 = ndarray(buffer, shape.slice(0), stride.slice(0), 2 * size), y2 = ndarray(buffer, shape.slice(0), stride.slice(0), 3 * size), tmp, n, s1, s2, scratch_ptr = 4 * size;
    //Copy into x1/y1
    ops.assign(x1, x);
    ops.assign(y1, y);
    for(i = d - 1; i >= 0; --i){
        fftm(dir, size / shape[i], shape[i], buffer, x1.offset, y1.offset, scratch_ptr);
        if (i === 0) {
            break;
        }
        //Compute new stride for x2/y2
        n = 1;
        s1 = x2.stride;
        s2 = y2.stride;
        for(j = i - 1; j < d; ++j){
            s2[j] = s1[j] = n;
            n *= shape[j];
        }
        for(j = i - 2; j >= 0; --j){
            s2[j] = s1[j] = n;
            n *= shape[j];
        }
        //Transpose
        ops.assign(x2, x1);
        ops.assign(y2, y1);
        //Swap buffers
        tmp = x1;
        x1 = x2;
        x2 = tmp;
        tmp = y1;
        y1 = y2;
        y2 = tmp;
    }
    //Copy result back into x
    ops.assign(x, x1);
    ops.assign(y, y1);
    pool.free(buffer);
}
module.exports = ndfft;
}}),
"[project]/node_modules/ndarray-scratch/scratch.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var ndarray = __turbopack_context__.r("[project]/node_modules/ndarray/ndarray.js [app-client] (ecmascript)");
var ops = __turbopack_context__.r("[project]/node_modules/ndarray-ops/ndarray-ops.js [app-client] (ecmascript)");
var pool = __turbopack_context__.r("[project]/node_modules/typedarray-pool/pool.js [app-client] (ecmascript)");
function clone(array) {
    var dtype = array.dtype;
    if (dtype === "generic" || dtype === "array") {
        dtype = "double";
    }
    var data = pool.malloc(array.size, dtype);
    var result = ndarray(data, array.shape);
    ops.assign(result, array);
    return result;
}
exports.clone = clone;
function malloc(shape, dtype) {
    if (!dtype) {
        dtype = "double";
    }
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    return ndarray(pool.malloc(sz, dtype), shape, stride, 0);
}
exports.malloc = malloc;
function free(array) {
    if (array.dtype === "generic" || array.dtype === "array") {
        return;
    }
    pool.free(array.data);
}
exports.free = free;
function zeros(shape, dtype) {
    if (!dtype) {
        dtype = "double";
    }
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(var i = 0; i < sz; ++i){
        buf[i] = 0;
    }
    return ndarray(buf, shape, stride, 0);
}
exports.zeros = zeros;
function ones(shape, dtype) {
    if (!dtype) {
        dtype = "double";
    }
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(var i = 0; i < sz; ++i){
        buf[i] = 1;
    }
    return ndarray(buf, shape, stride, 0);
}
exports.ones = ones;
function eye(shape, dtype) {
    var i, offset;
    if (!dtype) {
        dtype = "double";
    }
    var sz = 1;
    var stride = new Array(shape.length);
    for(i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(i = 0; i < sz; ++i){
        buf[i] = 0;
    }
    var mindim = Infinity;
    var offsum = 0;
    for(i = shape.length - 1; i >= 0; i--){
        offsum += stride[i];
        mindim = Math.min(mindim, shape[i]);
    }
    for(i = 0, offset = 0; i < mindim; i++, offset += offsum){
        buf[offset] = 1;
    }
    return ndarray(buf, shape, stride, 0);
}
exports.eye = eye;
}}),
"[project]/node_modules/esprima/esprima.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/ /*jslint bitwise:true plusplus:true */ /*global esprima:true, define:true, exports:true, window: true,
throwErrorTolerant: true,
throwError: true, generateStatement: true, peek: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true,
parseUnaryExpression: true,
parseStatement: true, parseSourceElement: true */ (function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    /* istanbul ignore next */ if (typeof define === 'function' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(factory(exports));
    } else if ("TURBOPACK compile-time truthy", 1) {
        factory(exports);
    } else {
        "TURBOPACK unreachable";
    }
})(this, function(exports1) {
    'use strict';
    var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;
    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
    };
    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';
    // A function following one of those tokens is an expression.
    FnExprTokens = [
        '(',
        '{',
        '[',
        'in',
        'typeof',
        'instanceof',
        'new',
        'return',
        'case',
        'delete',
        'throw',
        'void',
        // assignment operators
        '=',
        '+=',
        '-=',
        '*=',
        '/=',
        '%=',
        '<<=',
        '>>=',
        '>>>=',
        '&=',
        '|=',
        '^=',
        ',',
        // binary/unary operators
        '+',
        '-',
        '*',
        '/',
        '%',
        '++',
        '--',
        '<<',
        '>>',
        '>>>',
        '&',
        '|',
        '^',
        '!',
        '~',
        '&&',
        '||',
        '?',
        ':',
        '===',
        '==',
        '>=',
        '<=',
        '<',
        '>',
        '!=',
        '!=='
    ];
    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };
    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };
    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode'
    };
    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };
    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.
    function assert(condition, message) {
        /* istanbul ignore if */ if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }
    function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57; // 0..9
    }
    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }
    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }
    // 7.2 White Space
    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [
            0x1680,
            0x180E,
            0x2000,
            0x2001,
            0x2002,
            0x2003,
            0x2004,
            0x2005,
            0x2006,
            0x2007,
            0x2008,
            0x2009,
            0x200A,
            0x202F,
            0x205F,
            0x3000,
            0xFEFF
        ].indexOf(ch) >= 0;
    }
    // 7.3 Line Terminators
    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }
    // 7.6 Identifier Names and Identifiers
    function isIdentifierStart(ch) {
        return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch === 0x5C || ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
    }
    function isIdentifierPart(ch) {
        return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch >= 0x30 && ch <= 0x39 || ch === 0x5C || ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
    }
    // 7.6.1.2 Future Reserved Words
    function isFutureReservedWord(id) {
        switch(id){
            case 'class':
            case 'enum':
            case 'export':
            case 'extends':
            case 'import':
            case 'super':
                return true;
            default:
                return false;
        }
    }
    function isStrictModeReservedWord(id) {
        switch(id){
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'yield':
            case 'let':
                return true;
            default:
                return false;
        }
    }
    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }
    // 7.6.1.1 Keywords
    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }
        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.
        switch(id.length){
            case 2:
                return id === 'if' || id === 'in' || id === 'do';
            case 3:
                return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
            case 4:
                return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
            case 5:
                return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
            case 6:
                return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
            case 7:
                return id === 'default' || id === 'finally' || id === 'extends';
            case 8:
                return id === 'function' || id === 'continue' || id === 'debugger';
            case 10:
                return id === 'instanceof';
            default:
                return false;
        }
    }
    // 7.4 Comments
    function addComment(type, value, start, end, loc) {
        var comment, attacher;
        assert(typeof start === 'number', 'Comment must have valid position');
        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;
        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [
                start,
                end
            ];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }
    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;
        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };
        while(index < length){
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }
        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }
    function skipMultiLineComment() {
        var start, loc, ch, comment;
        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }
        while(index < length){
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }
        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }
    function skipComment() {
        var ch, start;
        start = index === 0;
        while(index < length){
            ch = source.charCodeAt(index);
            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) {
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) {
                // U+003E is '>'
                if (source.charCodeAt(index + 1) === 0x2D && source.charCodeAt(index + 2) === 0x3E) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) {
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }
    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;
        len = prefix === 'u' ? 4 : 2;
        for(i = 0; i < len; ++i){
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }
    function getEscapedIdentifier() {
        var ch, id;
        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);
        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id = ch;
        }
        while(index < length){
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);
            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id += ch;
            }
        }
        return id;
    }
    function getIdentifier() {
        var start, ch;
        start = index++;
        while(index < length){
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }
        return source.slice(start, index);
    }
    function scanIdentifier() {
        var start, id, type;
        start = index;
        // Backslash (U+005C) starts an escaped character.
        id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier();
        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }
        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    // 7.7 Punctuators
    function scanPunctuator() {
        var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;
        switch(code){
            // Check for most common single-character punctuators.
            case 0x2E:
            case 0x28:
            case 0x29:
            case 0x3B:
            case 0x2C:
            case 0x7B:
            case 0x7D:
            case 0x5B:
            case 0x5D:
            case 0x3A:
            case 0x3F:
            case 0x7E:
                ++index;
                if (extra.tokenize) {
                    if (code === 0x28) {
                        extra.openParenToken = extra.tokens.length;
                    } else if (code === 0x7B) {
                        extra.openCurlyToken = extra.tokens.length;
                    }
                }
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    start: start,
                    end: index
                };
            default:
                code2 = source.charCodeAt(index + 1);
                // '=' (U+003D) marks an assignment or comparison operator.
                if (code2 === 0x3D) {
                    switch(code){
                        case 0x2B:
                        case 0x2D:
                        case 0x2F:
                        case 0x3C:
                        case 0x3E:
                        case 0x5E:
                        case 0x7C:
                        case 0x25:
                        case 0x26:
                        case 0x2A:
                            index += 2;
                            return {
                                type: Token.Punctuator,
                                value: String.fromCharCode(code) + String.fromCharCode(code2),
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                start: start,
                                end: index
                            };
                        case 0x21:
                        case 0x3D:
                            index += 2;
                            // !== and ===
                            if (source.charCodeAt(index) === 0x3D) {
                                ++index;
                            }
                            return {
                                type: Token.Punctuator,
                                value: source.slice(start, index),
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                start: start,
                                end: index
                            };
                    }
                }
        }
        // 4-character punctuator: >>>=
        ch4 = source.substr(index, 4);
        if (ch4 === '>>>=') {
            index += 4;
            return {
                type: Token.Punctuator,
                value: ch4,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        // 3-character punctuators: === !== >>> <<= >>=
        ch3 = ch4.substr(0, 3);
        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: ch3,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        // Other 2-character punctuators: ++ -- << >> && ||
        ch2 = ch3.substr(0, 2);
        if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        // 1-character punctuators: < > = ! + - * % & | ^ /
        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }
    // 7.8.3 Numeric Literals
    function scanHexLiteral(start) {
        var number = '';
        while(index < length){
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }
        if (number.length === 0) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    function scanOctalLiteral(start) {
        var number = '0' + source[index++];
        while(index < length){
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }
        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: true,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    function isImplicitOctalLiteral() {
        var i, ch;
        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for(i = index + 1; i < length; ++i){
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }
        return true;
    }
    function scanNumericLiteral() {
        var number, start, ch;
        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];
            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(start);
                    }
                }
            }
            while(isDecimalDigit(source.charCodeAt(index))){
                number += source[index++];
            }
            ch = source[index];
        }
        if (ch === '.') {
            number += source[index++];
            while(isDecimalDigit(source.charCodeAt(index))){
                number += source[index++];
            }
            ch = source[index];
        }
        if (ch === 'e' || ch === 'E') {
            number += source[index++];
            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while(isDecimalDigit(source.charCodeAt(index))){
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    // 7.8.4 String Literals
    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        quote = source[index];
        assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
        start = index;
        ++index;
        while(index < length){
            ch = source[index++];
            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch(ch){
                        case 'u':
                        case 'x':
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                            break;
                        case 'n':
                            str += '\n';
                            break;
                        case 'r':
                            str += '\r';
                            break;
                        case 't':
                            str += '\t';
                            break;
                        case 'b':
                            str += '\b';
                            break;
                        case 'f':
                            str += '\f';
                            break;
                        case 'v':
                            str += '\x0B';
                            break;
                        default:
                            if (isOctalDigit(ch)) {
                                code = '01234567'.indexOf(ch);
                                // \0 is not octal escape sequence
                                if (code !== 0) {
                                    octal = true;
                                }
                                if (index < length && isOctalDigit(source[index])) {
                                    octal = true;
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                    // 3 digits are only allowed when string starts
                                    // with 0, 1, 2, 3
                                    if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                                        code = code * 8 + '01234567'.indexOf(source[index++]);
                                    }
                                }
                                str += String.fromCharCode(code);
                            } else {
                                str += ch;
                            }
                            break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }
        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }
    function testRegExp(pattern, flags) {
        var value;
        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }
        return value;
    }
    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];
        classMarker = false;
        terminated = false;
        while(index < length){
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError({}, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }
        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }
        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }
    function scanRegExpFlags() {
        var ch, str, flags, restore;
        str = '';
        flags = '';
        while(index < length){
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }
            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for(str += '\\u'; restore < index; ++restore){
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                } else {
                    str += '\\';
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else {
                flags += ch;
                str += ch;
            }
        }
        return {
            value: flags,
            literal: str
        };
    }
    function scanRegExp() {
        var start, body, flags, pattern, value;
        lookahead = null;
        skipComment();
        start = index;
        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }
        return {
            literal: body.literal + flags.literal,
            value: value,
            start: start,
            end: index
        };
    }
    function collectRegex() {
        var pos, loc, regex, token;
        skipComment();
        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };
        regex = scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };
        /* istanbul ignore next */ if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }
            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                range: [
                    pos,
                    index
                ],
                loc: loc
            });
        }
        return regex;
    }
    function isIdentifierName(token) {
        return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
    }
    function advanceSlash() {
        var prevToken, checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
            return collectRegex();
        }
        return scanPunctuator();
    }
    function advance() {
        var ch;
        skipComment();
        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }
        ch = source.charCodeAt(index);
        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }
        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }
        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }
        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }
        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }
        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && ch === 0x2F) {
            return advanceSlash();
        }
        return scanPunctuator();
    }
    function collectToken() {
        var loc, token, range, value;
        skipComment();
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };
        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };
        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: [
                    token.start,
                    token.end
                ],
                loc: loc
            });
        }
        return token;
    }
    function lex() {
        var token;
        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        return token;
    }
    function peek() {
        var pos, line, start;
        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }
    function Position(line, column) {
        this.line = line;
        this.column = column;
    }
    function SourceLocation(startLine, startColumn, line, column) {
        this.start = new Position(startLine, startColumn);
        this.end = new Position(line, column);
    }
    SyntaxTreeDelegate = {
        name: 'SyntaxTree',
        processComment: function(node) {
            var lastChild, trailingComments;
            if (node.type === Syntax.Program) {
                if (node.body.length > 0) {
                    return;
                }
            }
            if (extra.trailingComments.length > 0) {
                if (extra.trailingComments[0].range[0] >= node.range[1]) {
                    trailingComments = extra.trailingComments;
                    extra.trailingComments = [];
                } else {
                    extra.trailingComments.length = 0;
                }
            } else {
                if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
                    trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                    delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                }
            }
            // Eating the stack.
            while(extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]){
                lastChild = extra.bottomRightStack.pop();
            }
            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
                    node.leadingComments = lastChild.leadingComments;
                    delete lastChild.leadingComments;
                }
            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
                node.leadingComments = extra.leadingComments;
                extra.leadingComments = [];
            }
            if (trailingComments) {
                node.trailingComments = trailingComments;
            }
            extra.bottomRightStack.push(node);
        },
        markEnd: function(node, startToken) {
            if (extra.range) {
                node.range = [
                    startToken.start,
                    index
                ];
            }
            if (extra.loc) {
                node.loc = new SourceLocation(startToken.startLineNumber === undefined ? startToken.lineNumber : startToken.startLineNumber, startToken.start - (startToken.startLineStart === undefined ? startToken.lineStart : startToken.startLineStart), lineNumber, index - lineStart);
                this.postProcess(node);
            }
            if (extra.attachComment) {
                this.processComment(node);
            }
            return node;
        },
        postProcess: function(node) {
            if (extra.source) {
                node.loc.source = extra.source;
            }
            return node;
        },
        createArrayExpression: function(elements) {
            return {
                type: Syntax.ArrayExpression,
                elements: elements
            };
        },
        createAssignmentExpression: function(operator, left, right) {
            return {
                type: Syntax.AssignmentExpression,
                operator: operator,
                left: left,
                right: right
            };
        },
        createBinaryExpression: function(operator, left, right) {
            var type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            return {
                type: type,
                operator: operator,
                left: left,
                right: right
            };
        },
        createBlockStatement: function(body) {
            return {
                type: Syntax.BlockStatement,
                body: body
            };
        },
        createBreakStatement: function(label) {
            return {
                type: Syntax.BreakStatement,
                label: label
            };
        },
        createCallExpression: function(callee, args) {
            return {
                type: Syntax.CallExpression,
                callee: callee,
                'arguments': args
            };
        },
        createCatchClause: function(param, body) {
            return {
                type: Syntax.CatchClause,
                param: param,
                body: body
            };
        },
        createConditionalExpression: function(test, consequent, alternate) {
            return {
                type: Syntax.ConditionalExpression,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },
        createContinueStatement: function(label) {
            return {
                type: Syntax.ContinueStatement,
                label: label
            };
        },
        createDebuggerStatement: function() {
            return {
                type: Syntax.DebuggerStatement
            };
        },
        createDoWhileStatement: function(body, test) {
            return {
                type: Syntax.DoWhileStatement,
                body: body,
                test: test
            };
        },
        createEmptyStatement: function() {
            return {
                type: Syntax.EmptyStatement
            };
        },
        createExpressionStatement: function(expression) {
            return {
                type: Syntax.ExpressionStatement,
                expression: expression
            };
        },
        createForStatement: function(init, test, update, body) {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        },
        createForInStatement: function(left, right, body) {
            return {
                type: Syntax.ForInStatement,
                left: left,
                right: right,
                body: body,
                each: false
            };
        },
        createFunctionDeclaration: function(id, params, defaults, body) {
            return {
                type: Syntax.FunctionDeclaration,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },
        createFunctionExpression: function(id, params, defaults, body) {
            return {
                type: Syntax.FunctionExpression,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },
        createIdentifier: function(name) {
            return {
                type: Syntax.Identifier,
                name: name
            };
        },
        createIfStatement: function(test, consequent, alternate) {
            return {
                type: Syntax.IfStatement,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },
        createLabeledStatement: function(label, body) {
            return {
                type: Syntax.LabeledStatement,
                label: label,
                body: body
            };
        },
        createLiteral: function(token) {
            return {
                type: Syntax.Literal,
                value: token.value,
                raw: source.slice(token.start, token.end)
            };
        },
        createMemberExpression: function(accessor, object, property) {
            return {
                type: Syntax.MemberExpression,
                computed: accessor === '[',
                object: object,
                property: property
            };
        },
        createNewExpression: function(callee, args) {
            return {
                type: Syntax.NewExpression,
                callee: callee,
                'arguments': args
            };
        },
        createObjectExpression: function(properties) {
            return {
                type: Syntax.ObjectExpression,
                properties: properties
            };
        },
        createPostfixExpression: function(operator, argument) {
            return {
                type: Syntax.UpdateExpression,
                operator: operator,
                argument: argument,
                prefix: false
            };
        },
        createProgram: function(body) {
            return {
                type: Syntax.Program,
                body: body
            };
        },
        createProperty: function(kind, key, value) {
            return {
                type: Syntax.Property,
                key: key,
                value: value,
                kind: kind
            };
        },
        createReturnStatement: function(argument) {
            return {
                type: Syntax.ReturnStatement,
                argument: argument
            };
        },
        createSequenceExpression: function(expressions) {
            return {
                type: Syntax.SequenceExpression,
                expressions: expressions
            };
        },
        createSwitchCase: function(test, consequent) {
            return {
                type: Syntax.SwitchCase,
                test: test,
                consequent: consequent
            };
        },
        createSwitchStatement: function(discriminant, cases) {
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant,
                cases: cases
            };
        },
        createThisExpression: function() {
            return {
                type: Syntax.ThisExpression
            };
        },
        createThrowStatement: function(argument) {
            return {
                type: Syntax.ThrowStatement,
                argument: argument
            };
        },
        createTryStatement: function(block, guardedHandlers, handlers, finalizer) {
            return {
                type: Syntax.TryStatement,
                block: block,
                guardedHandlers: guardedHandlers,
                handlers: handlers,
                finalizer: finalizer
            };
        },
        createUnaryExpression: function(operator, argument) {
            if (operator === '++' || operator === '--') {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            }
            return {
                type: Syntax.UnaryExpression,
                operator: operator,
                argument: argument,
                prefix: true
            };
        },
        createVariableDeclaration: function(declarations, kind) {
            return {
                type: Syntax.VariableDeclaration,
                declarations: declarations,
                kind: kind
            };
        },
        createVariableDeclarator: function(id, init) {
            return {
                type: Syntax.VariableDeclarator,
                id: id,
                init: init
            };
        },
        createWhileStatement: function(test, body) {
            return {
                type: Syntax.WhileStatement,
                test: test,
                body: body
            };
        },
        createWithStatement: function(object, body) {
            return {
                type: Syntax.WithStatement,
                object: object,
                body: body
            };
        }
    };
    // Return true if there is a line terminator before the next token.
    function peekLineTerminator() {
        var pos, line, start, found;
        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;
        return found;
    }
    // Throw an exception
    function throwError(token, messageFormat) {
        var error, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, function(whole, index) {
            assert(index < args.length, 'Message reference must be in range');
            return args[index];
        });
        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.start;
            error.lineNumber = token.lineNumber;
            error.column = token.start - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }
        error.description = msg;
        throw error;
    }
    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }
    // Throw an exception because of the token.
    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }
        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }
        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }
        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }
        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }
        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }
    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.
    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }
    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.
    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }
    // Return true if the next token matches the specified punctuator.
    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }
    // Return true if the next token matches the specified keyword
    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }
    // Return true if the next token is an assignment operator
    function matchAssign() {
        var op;
        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
    }
    function consumeSemicolon() {
        var line, oldIndex = index, oldLineNumber = lineNumber, oldLineStart = lineStart, oldLookahead = lookahead;
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B || match(';')) {
            lex();
            return;
        }
        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            index = oldIndex;
            lineNumber = oldLineNumber;
            lineStart = oldLineStart;
            lookahead = oldLookahead;
            return;
        }
        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }
    // Return true if provided expression is LeftHandSideExpression
    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }
    // 11.1.4 Array Initialiser
    function parseArrayInitialiser() {
        var elements = [], startToken;
        startToken = lookahead;
        expect('[');
        while(!match(']')){
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());
                if (!match(']')) {
                    expect(',');
                }
            }
        }
        lex();
        return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
    }
    // 11.1.5 Object Initialiser
    function parsePropertyFunction(param, first) {
        var previousStrict, body, startToken;
        previousStrict = strict;
        startToken = lookahead;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
    }
    function parseObjectPropertyKey() {
        var token, startToken;
        startToken = lookahead;
        token = lex();
        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return delegate.markEnd(delegate.createLiteral(token), startToken);
        }
        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
    }
    function parseObjectProperty() {
        var token, key, id, value, param, startToken;
        token = lookahead;
        startToken = lookahead;
        if (token.type === Token.Identifier) {
            id = parseObjectPropertyKey();
            // Property Assignment: Getter and Setter.
            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                value = parsePropertyFunction([]);
                return delegate.markEnd(delegate.createProperty('get', key, value), startToken);
            }
            if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    expect(')');
                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                    value = parsePropertyFunction([]);
                } else {
                    param = [
                        parseVariableIdentifier()
                    ];
                    expect(')');
                    value = parsePropertyFunction(param, token);
                }
                return delegate.markEnd(delegate.createProperty('set', key, value), startToken);
            }
            expect(':');
            value = parseAssignmentExpression();
            return delegate.markEnd(delegate.createProperty('init', id, value), startToken);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            value = parseAssignmentExpression();
            return delegate.markEnd(delegate.createProperty('init', key, value), startToken);
        }
    }
    function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String, startToken;
        startToken = lookahead;
        expect('{');
        while(!match('}')){
            property = parseObjectProperty();
            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;
            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }
            properties.push(property);
            if (!match('}')) {
                expect(',');
            }
        }
        expect('}');
        return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
    }
    // 11.1.6 The Grouping Operator
    function parseGroupExpression() {
        var expr;
        expect('(');
        expr = parseExpression();
        expect(')');
        return expr;
    }
    // 11.1 Primary Expressions
    function parsePrimaryExpression() {
        var type, token, expr, startToken;
        if (match('(')) {
            return parseGroupExpression();
        }
        if (match('[')) {
            return parseArrayInitialiser();
        }
        if (match('{')) {
            return parseObjectInitialiser();
        }
        type = lookahead.type;
        startToken = lookahead;
        if (type === Token.Identifier) {
            expr = delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                expr = delegate.createThisExpression();
            } else {
                throwUnexpected(lex());
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = token.value === 'true';
            expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = delegate.createLiteral(token);
        } else if (match('/') || match('/=')) {
            if (typeof extra.tokens !== 'undefined') {
                expr = delegate.createLiteral(collectRegex());
            } else {
                expr = delegate.createLiteral(scanRegExp());
            }
            peek();
        } else {
            throwUnexpected(lex());
        }
        return delegate.markEnd(expr, startToken);
    }
    // 11.2 Left-Hand-Side Expressions
    function parseArguments() {
        var args = [];
        expect('(');
        if (!match(')')) {
            while(index < length){
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }
        expect(')');
        return args;
    }
    function parseNonComputedProperty() {
        var token, startToken;
        startToken = lookahead;
        token = lex();
        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }
        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
    }
    function parseNonComputedMember() {
        expect('.');
        return parseNonComputedProperty();
    }
    function parseComputedMember() {
        var expr;
        expect('[');
        expr = parseExpression();
        expect(']');
        return expr;
    }
    function parseNewExpression() {
        var callee, args, startToken;
        startToken = lookahead;
        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];
        return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
    }
    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property, startToken, previousAllowIn = state.allowIn;
        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        for(;;){
            if (match('.')) {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                break;
            }
            delegate.markEnd(expr, startToken);
        }
        state.allowIn = previousAllowIn;
        return expr;
    }
    function parseLeftHandSideExpression() {
        var expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');
        startToken = lookahead;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        while(match('.') || match('[')){
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            }
            delegate.markEnd(expr, startToken);
        }
        return expr;
    }
    // 11.3 Postfix Expressions
    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;
        expr = parseLeftHandSideExpressionAllowCall();
        if (lookahead.type === Token.Punctuator) {
            if ((match('++') || match('--')) && !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPostfix);
                }
                if (!isLeftHandSide(expr)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }
                token = lex();
                expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
            }
        }
        return expr;
    }
    // 11.4 Unary Operators
    function parseUnaryExpression() {
        var token, expr, startToken;
        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }
            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }
            expr = delegate.createUnaryExpression(token.value, expr);
            expr = delegate.markEnd(expr, startToken);
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
            expr = delegate.markEnd(expr, startToken);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
            expr = delegate.markEnd(expr, startToken);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
        } else {
            expr = parsePostfixExpression();
        }
        return expr;
    }
    function binaryPrecedence(token, allowIn) {
        var prec = 0;
        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }
        switch(token.value){
            case '||':
                prec = 1;
                break;
            case '&&':
                prec = 2;
                break;
            case '|':
                prec = 3;
                break;
            case '^':
                prec = 4;
                break;
            case '&':
                prec = 5;
                break;
            case '==':
            case '!=':
            case '===':
            case '!==':
                prec = 6;
                break;
            case '<':
            case '>':
            case '<=':
            case '>=':
            case 'instanceof':
                prec = 7;
                break;
            case 'in':
                prec = allowIn ? 7 : 0;
                break;
            case '<<':
            case '>>':
            case '>>>':
                prec = 8;
                break;
            case '+':
            case '-':
                prec = 9;
                break;
            case '*':
            case '/':
            case '%':
                prec = 11;
                break;
            default:
                break;
        }
        return prec;
    }
    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators
    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;
        marker = lookahead;
        left = parseUnaryExpression();
        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();
        markers = [
            marker,
            lookahead
        ];
        right = parseUnaryExpression();
        stack = [
            left,
            token,
            right
        ];
        while((prec = binaryPrecedence(lookahead, state.allowIn)) > 0){
            // Reduce: make a binary expression from the three topmost entries.
            while(stack.length > 2 && prec <= stack[stack.length - 2].prec){
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                markers.pop();
                marker = markers[markers.length - 1];
                delegate.markEnd(expr, marker);
                stack.push(expr);
            }
            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = parseUnaryExpression();
            stack.push(expr);
        }
        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while(i > 1){
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
            marker = markers.pop();
            delegate.markEnd(expr, marker);
        }
        return expr;
    }
    // 11.12 Conditional Operator
    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;
        startToken = lookahead;
        expr = parseBinaryExpression();
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();
            expr = delegate.createConditionalExpression(expr, consequent, alternate);
            delegate.markEnd(expr, startToken);
        }
        return expr;
    }
    // 11.13 Assignment Operators
    function parseAssignmentExpression() {
        var token, left, right, node, startToken;
        token = lookahead;
        startToken = lookahead;
        node = left = parseConditionalExpression();
        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(left)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }
            // 11.13.1
            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }
            token = lex();
            right = parseAssignmentExpression();
            node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
        }
        return node;
    }
    // 11.14 Comma Operator
    function parseExpression() {
        var expr, startToken = lookahead;
        expr = parseAssignmentExpression();
        if (match(',')) {
            expr = delegate.createSequenceExpression([
                expr
            ]);
            while(index < length){
                if (!match(',')) {
                    break;
                }
                lex();
                expr.expressions.push(parseAssignmentExpression());
            }
            delegate.markEnd(expr, startToken);
        }
        return expr;
    }
    // 12.1 Block
    function parseStatementList() {
        var list = [], statement;
        while(index < length){
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }
        return list;
    }
    function parseBlock() {
        var block, startToken;
        startToken = lookahead;
        expect('{');
        block = parseStatementList();
        expect('}');
        return delegate.markEnd(delegate.createBlockStatement(block), startToken);
    }
    // 12.2 Variable Statement
    function parseVariableIdentifier() {
        var token, startToken;
        startToken = lookahead;
        token = lex();
        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }
        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
    }
    function parseVariableDeclaration(kind) {
        var init = null, id, startToken;
        startToken = lookahead;
        id = parseVariableIdentifier();
        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }
        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }
        return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
    }
    function parseVariableDeclarationList(kind) {
        var list = [];
        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        }while (index < length)
        return list;
    }
    function parseVariableStatement() {
        var declarations;
        expectKeyword('var');
        declarations = parseVariableDeclarationList();
        consumeSemicolon();
        return delegate.createVariableDeclaration(declarations, 'var');
    }
    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations, startToken;
        startToken = lookahead;
        expectKeyword(kind);
        declarations = parseVariableDeclarationList(kind);
        consumeSemicolon();
        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
    }
    // 12.3 Empty Statement
    function parseEmptyStatement() {
        expect(';');
        return delegate.createEmptyStatement();
    }
    // 12.4 Expression Statement
    function parseExpressionStatement() {
        var expr = parseExpression();
        consumeSemicolon();
        return delegate.createExpressionStatement(expr);
    }
    // 12.5 If statement
    function parseIfStatement() {
        var test, consequent, alternate;
        expectKeyword('if');
        expect('(');
        test = parseExpression();
        expect(')');
        consequent = parseStatement();
        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }
        return delegate.createIfStatement(test, consequent, alternate);
    }
    // 12.6 Iteration Statements
    function parseDoWhileStatement() {
        var body, test, oldInIteration;
        expectKeyword('do');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        expectKeyword('while');
        expect('(');
        test = parseExpression();
        expect(')');
        if (match(';')) {
            lex();
        }
        return delegate.createDoWhileStatement(body, test);
    }
    function parseWhileStatement() {
        var test, body, oldInIteration;
        expectKeyword('while');
        expect('(');
        test = parseExpression();
        expect(')');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return delegate.createWhileStatement(test, body);
    }
    function parseForVariableDeclaration() {
        var token, declarations, startToken;
        startToken = lookahead;
        token = lex();
        declarations = parseVariableDeclarationList();
        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
    }
    function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;
        init = test = update = null;
        expectKeyword('for');
        expect('(');
        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = previousAllowIn;
                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = previousAllowIn;
                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                    }
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }
            if (typeof left === 'undefined') {
                expect(';');
            }
        }
        if (typeof left === 'undefined') {
            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');
            if (!match(')')) {
                update = parseExpression();
            }
        }
        expect(')');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return typeof left === 'undefined' ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);
    }
    // 12.7 The continue statement
    function parseContinueStatement() {
        var label = null, key;
        expectKeyword('continue');
        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 0x3B) {
            lex();
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }
            return delegate.createContinueStatement(null);
        }
        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }
            return delegate.createContinueStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();
            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }
        consumeSemicolon();
        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }
        return delegate.createContinueStatement(label);
    }
    // 12.8 The break statement
    function parseBreakStatement() {
        var label = null, key;
        expectKeyword('break');
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B) {
            lex();
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }
            return delegate.createBreakStatement(null);
        }
        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }
            return delegate.createBreakStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();
            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }
        consumeSemicolon();
        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }
        return delegate.createBreakStatement(label);
    }
    // 12.9 The return statement
    function parseReturnStatement() {
        var argument = null;
        expectKeyword('return');
        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }
        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return delegate.createReturnStatement(argument);
            }
        }
        if (peekLineTerminator()) {
            return delegate.createReturnStatement(null);
        }
        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }
        consumeSemicolon();
        return delegate.createReturnStatement(argument);
    }
    // 12.10 The with statement
    function parseWithStatement() {
        var object, body;
        if (strict) {
            // TODO(ikarienator): Should we update the test cases instead?
            skipComment();
            throwErrorTolerant({}, Messages.StrictModeWith);
        }
        expectKeyword('with');
        expect('(');
        object = parseExpression();
        expect(')');
        body = parseStatement();
        return delegate.createWithStatement(object, body);
    }
    // 12.10 The swith statement
    function parseSwitchCase() {
        var test, consequent = [], statement, startToken;
        startToken = lookahead;
        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');
        while(index < length){
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }
        return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
    }
    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;
        expectKeyword('switch');
        expect('(');
        discriminant = parseExpression();
        expect(')');
        expect('{');
        cases = [];
        if (match('}')) {
            lex();
            return delegate.createSwitchStatement(discriminant, cases);
        }
        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;
        while(index < length){
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }
        state.inSwitch = oldInSwitch;
        expect('}');
        return delegate.createSwitchStatement(discriminant, cases);
    }
    // 12.13 The throw statement
    function parseThrowStatement() {
        var argument;
        expectKeyword('throw');
        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }
        argument = parseExpression();
        consumeSemicolon();
        return delegate.createThrowStatement(argument);
    }
    // 12.14 The try statement
    function parseCatchClause() {
        var param, body, startToken;
        startToken = lookahead;
        expectKeyword('catch');
        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead);
        }
        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }
        expect(')');
        body = parseBlock();
        return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
    }
    function parseTryStatement() {
        var block, handlers = [], finalizer = null;
        expectKeyword('try');
        block = parseBlock();
        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }
        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }
        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }
        return delegate.createTryStatement(block, [], handlers, finalizer);
    }
    // 12.15 The debugger statement
    function parseDebuggerStatement() {
        expectKeyword('debugger');
        consumeSemicolon();
        return delegate.createDebuggerStatement();
    }
    // 12 Statements
    function parseStatement() {
        var type = lookahead.type, expr, labeledBody, key, startToken;
        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }
        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }
        startToken = lookahead;
        if (type === Token.Punctuator) {
            switch(lookahead.value){
                case ';':
                    return delegate.markEnd(parseEmptyStatement(), startToken);
                case '(':
                    return delegate.markEnd(parseExpressionStatement(), startToken);
                default:
                    break;
            }
        }
        if (type === Token.Keyword) {
            switch(lookahead.value){
                case 'break':
                    return delegate.markEnd(parseBreakStatement(), startToken);
                case 'continue':
                    return delegate.markEnd(parseContinueStatement(), startToken);
                case 'debugger':
                    return delegate.markEnd(parseDebuggerStatement(), startToken);
                case 'do':
                    return delegate.markEnd(parseDoWhileStatement(), startToken);
                case 'for':
                    return delegate.markEnd(parseForStatement(), startToken);
                case 'function':
                    return delegate.markEnd(parseFunctionDeclaration(), startToken);
                case 'if':
                    return delegate.markEnd(parseIfStatement(), startToken);
                case 'return':
                    return delegate.markEnd(parseReturnStatement(), startToken);
                case 'switch':
                    return delegate.markEnd(parseSwitchStatement(), startToken);
                case 'throw':
                    return delegate.markEnd(parseThrowStatement(), startToken);
                case 'try':
                    return delegate.markEnd(parseTryStatement(), startToken);
                case 'var':
                    return delegate.markEnd(parseVariableStatement(), startToken);
                case 'while':
                    return delegate.markEnd(parseWhileStatement(), startToken);
                case 'with':
                    return delegate.markEnd(parseWithStatement(), startToken);
                default:
                    break;
            }
        }
        expr = parseExpression();
        // 12.12 Labelled Statements
        if (expr.type === Syntax.Identifier && match(':')) {
            lex();
            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }
            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
        }
        consumeSemicolon();
        return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
    }
    // 13 Function Definition
    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;
        startToken = lookahead;
        expect('{');
        while(index < length){
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;
            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }
        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        while(index < length){
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        expect('}');
        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
    }
    function parseParams(firstRestricted) {
        var param, params = [], token, stricted, paramSet, key, message;
        expect('(');
        if (!match(')')) {
            paramSet = {};
            while(index < length){
                token = lookahead;
                param = parseVariableIdentifier();
                key = '$' + token.value;
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[key] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }
        expect(')');
        return {
            params: params,
            stricted: stricted,
            firstRestricted: firstRestricted,
            message: message
        };
    }
    function parseFunctionDeclaration() {
        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;
        startToken = lookahead;
        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
    }
    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;
        startToken = lookahead;
        expectKeyword('function');
        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
    }
    // 14 Program
    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch(lookahead.value){
                case 'const':
                case 'let':
                    return parseConstLetDeclaration(lookahead.value);
                case 'function':
                    return parseFunctionDeclaration();
                default:
                    return parseStatement();
            }
        }
        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }
    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;
        while(index < length){
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }
            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }
        while(index < length){
            sourceElement = parseSourceElement();
            /* istanbul ignore if */ if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }
    function parseProgram() {
        var body, startToken;
        skipComment();
        peek();
        startToken = lookahead;
        strict = false;
        body = parseSourceElements();
        return delegate.markEnd(delegate.createProgram(body), startToken);
    }
    function filterTokenLocation() {
        var i, entry, token, tokens = [];
        for(i = 0; i < extra.tokens.length; ++i){
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }
        extra.tokens = tokens;
    }
    function tokenize(code, options) {
        var toString, token, tokens;
        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }
        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = source.length > 0 ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };
        extra = {};
        // Options matching.
        options = options || {};
        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;
        extra.range = typeof options.range === 'boolean' && options.range;
        extra.loc = typeof options.loc === 'boolean' && options.loc;
        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }
        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }
            token = lex();
            while(lookahead.type !== Token.EOF){
                try {
                    token = lex();
                } catch (lexError) {
                    token = lookahead;
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }
            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally{
            extra = {};
        }
        return tokens;
    }
    function parse(code, options) {
        var program, toString;
        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }
        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = source.length > 0 ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };
        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = typeof options.range === 'boolean' && options.range;
            extra.loc = typeof options.loc === 'boolean' && options.loc;
            extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }
            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }
        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally{
            extra = {};
        }
        return program;
    }
    // Sync with *.json manifests.
    exports1.version = '1.2.5';
    exports1.tokenize = tokenize;
    exports1.parse = parse;
    // Deep copy.
    /* istanbul ignore next */ exports1.Syntax = function() {
        var name, types = {};
        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }
        for(name in Syntax){
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }
        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }
        return types;
    }();
}); /* vim: set sw=4 ts=4 et tw=80 : */ 
}}),
"[project]/node_modules/cwise-parser/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var esprima = __turbopack_context__.r("[project]/node_modules/esprima/esprima.js [app-client] (ecmascript)");
var uniq = __turbopack_context__.r("[project]/node_modules/uniq/uniq.js [app-client] (ecmascript)");
var PREFIX_COUNTER = 0;
function CompiledArgument(name, lvalue, rvalue) {
    this.name = name;
    this.lvalue = lvalue;
    this.rvalue = rvalue;
    this.count = 0;
}
function CompiledRoutine(body, args, thisVars, localVars) {
    this.body = body;
    this.args = args;
    this.thisVars = thisVars;
    this.localVars = localVars;
}
function isGlobal(identifier) {
    if (identifier === "eval") {
        throw new Error("cwise-parser: eval() not allowed");
    }
    if (typeof window !== "undefined") {
        return identifier in window;
    } else if (typeof global !== "undefined") {
        return identifier in global;
    } else if (typeof self !== "undefined") {
        return identifier in self;
    } else {
        return false;
    }
}
function getArgNames(ast) {
    var params = ast.body[0].expression.callee.params;
    var names = new Array(params.length);
    for(var i = 0; i < params.length; ++i){
        names[i] = params[i].name;
    }
    return names;
}
function preprocess(func) {
    var src = [
        "(",
        func,
        ")()"
    ].join("");
    var ast = esprima.parse(src, {
        range: true
    });
    //Compute new prefix
    var prefix = "_inline_" + PREFIX_COUNTER++ + "_";
    //Parse out arguments
    var argNames = getArgNames(ast);
    var compiledArgs = new Array(argNames.length);
    for(var i = 0; i < argNames.length; ++i){
        compiledArgs[i] = new CompiledArgument([
            prefix,
            "arg",
            i,
            "_"
        ].join(""), false, false);
    }
    //Create temporary data structure for source rewriting
    var exploded = new Array(src.length);
    for(var i = 0, n = src.length; i < n; ++i){
        exploded[i] = src.charAt(i);
    }
    //Local variables
    var localVars = [];
    var thisVars = [];
    var computedThis = false;
    //Retrieves a local variable
    function createLocal(id) {
        var nstr = prefix + id.replace(/\_/g, "__");
        localVars.push(nstr);
        return nstr;
    }
    //Creates a this variable
    function createThisVar(id) {
        var nstr = "this_" + id.replace(/\_/g, "__");
        thisVars.push(nstr);
        return nstr;
    }
    //Rewrites an ast node
    function rewrite(node, nstr) {
        var lo = node.range[0], hi = node.range[1];
        for(var i = lo + 1; i < hi; ++i){
            exploded[i] = "";
        }
        exploded[lo] = nstr;
    }
    //Remove any underscores
    function escapeString(str) {
        return "'" + str.replace(/\_/g, "\\_").replace(/\'/g, "\'") + "'";
    }
    //Returns the source of an identifier
    function source(node) {
        return exploded.slice(node.range[0], node.range[1]).join("");
    }
    //Computes the usage of a node
    var LVALUE = 1;
    var RVALUE = 2;
    function getUsage(node) {
        if (node.parent.type === "AssignmentExpression") {
            if (node.parent.left === node) {
                if (node.parent.operator === "=") {
                    return LVALUE;
                }
                return LVALUE | RVALUE;
            }
        }
        if (node.parent.type === "UpdateExpression") {
            return LVALUE | RVALUE;
        }
        return RVALUE;
    }
    //Handle visiting a node
    (function visit(node, parent) {
        node.parent = parent;
        if (node.type === "MemberExpression") {
            //Handle member expression
            if (node.computed) {
                visit(node.object, node);
                visit(node.property, node);
            } else if (node.object.type === "ThisExpression") {
                rewrite(node, createThisVar(node.property.name));
            } else {
                visit(node.object, node);
            }
        } else if (node.type === "ThisExpression") {
            throw new Error("cwise-parser: Computed this is not allowed");
        } else if (node.type === "Identifier") {
            //Handle identifier
            var name = node.name;
            var argNo = argNames.indexOf(name);
            if (argNo >= 0) {
                var carg = compiledArgs[argNo];
                var usage = getUsage(node);
                if (usage & LVALUE) {
                    carg.lvalue = true;
                }
                if (usage & RVALUE) {
                    carg.rvalue = true;
                }
                ++carg.count;
                rewrite(node, carg.name);
            } else if (isGlobal(name)) {
            //Don't rewrite globals
            } else {
                rewrite(node, createLocal(name));
            }
        } else if (node.type === "Literal") {
            if (typeof node.value === "string") {
                rewrite(node, escapeString(node.value));
            }
        } else if (node.type === "WithStatement") {
            throw new Error("cwise-parser: with() statements not allowed");
        } else {
            //Visit all children
            var keys = Object.keys(node);
            for(var i = 0, n = keys.length; i < n; ++i){
                if (keys[i] === "parent") {
                    continue;
                }
                var value = node[keys[i]];
                if (value) {
                    if (value instanceof Array) {
                        for(var j = 0; j < value.length; ++j){
                            if (value[j] && typeof value[j].type === "string") {
                                visit(value[j], node);
                            }
                        }
                    } else if (typeof value.type === "string") {
                        visit(value, node);
                    }
                }
            }
        }
    })(ast.body[0].expression.callee.body, undefined);
    //Remove duplicate variables
    uniq(localVars);
    uniq(thisVars);
    //Return body
    var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars);
    return routine;
}
module.exports = preprocess;
}}),
"[project]/node_modules/cwise/lib/cwise-esprima.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var parse = __turbopack_context__.r("[project]/node_modules/cwise-parser/index.js [app-client] (ecmascript)");
var compile = __turbopack_context__.r("[project]/node_modules/cwise-compiler/compiler.js [app-client] (ecmascript)");
var REQUIRED_FIELDS = [
    "args",
    "body"
];
var OPTIONAL_FIELDS = [
    "pre",
    "post",
    "printCode",
    "funcName",
    "blockSize"
];
function createCWise(user_args) {
    //Check parameters
    for(var id in user_args){
        if (REQUIRED_FIELDS.indexOf(id) < 0 && OPTIONAL_FIELDS.indexOf(id) < 0) {
            console.warn("cwise: Unknown argument '" + id + "' passed to expression compiler");
        }
    }
    for(var i = 0; i < REQUIRED_FIELDS.length; ++i){
        if (!user_args[REQUIRED_FIELDS[i]]) {
            throw new Error("cwise: Missing argument: " + REQUIRED_FIELDS[i]);
        }
    }
    //Parse blocks
    return compile({
        args: user_args.args,
        pre: parse(user_args.pre || function() {}),
        body: parse(user_args.body),
        post: parse(user_args.post || function() {}),
        debug: !!user_args.printCode,
        funcName: user_args.funcName || user_args.body.name || "cwise",
        blockSize: user_args.blockSize || 64
    });
}
module.exports = createCWise;
}}),
"[project]/node_modules/ndarray-resample/resample.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var fft = __turbopack_context__.r("[project]/node_modules/ndarray-fft/fft.js [app-client] (ecmascript)");
var pool = __turbopack_context__.r("[project]/node_modules/ndarray-scratch/scratch.js [app-client] (ecmascript)");
var ops = __turbopack_context__.r("[project]/node_modules/ndarray-ops/ndarray-ops.js [app-client] (ecmascript)");
var cwise = __turbopack_context__.r("[project]/node_modules/cwise/lib/cwise-esprima.js [app-client] (ecmascript)");
var clampScale = cwise({
    args: [
        "array",
        "array",
        "scalar",
        "scalar",
        "scalar"
    ],
    body: function clampScale(out, inp, s, l, h) {
        var x = inp * s;
        if (x < l) {
            x = l;
        }
        if (x > h) {
            x = h;
        }
        out = x;
    }
});
function resample(out, inp, clamp_lo, clamp_hi) {
    if (typeof clamp_lo === "undefined") {
        clamp_lo = -Infinity;
    }
    if (typeof clamp_hi === "undefined") {
        clamp_hi = Infinity;
    }
    var ishp = inp.shape;
    var oshp = out.shape;
    if (inp.shape.length !== out.shape.length) throw new Error("ndarray-resample: input and output arrays should have the same dimensions");
    var v, zeroInds = ishp.map(function() {
        return 0;
    });
    if (out.size === 1) {
        v = ops.sum(inp) / inp.size;
        if (v < clamp_lo) {
            v = clamp_lo;
        }
        if (v > clamp_hi) {
            v = clamp_hi;
        }
        out.set.apply(out, zeroInds.concat(v));
        return;
    } else if (inp.size === 1) {
        v = inp.get.apply(inp, zeroInds);
        if (v < clamp_lo) {
            v = clamp_lo;
        }
        if (v > clamp_hi) {
            v = clamp_hi;
        }
        ops.assigns(out, v);
        return;
    }
    var d = ishp.length;
    var mshp = new Array(d), initToZero = false;
    for(var i = 0; i < d; i++){
        mshp[i] = Math.min(oshp[i], ishp[i]);
        if (oshp[i] > ishp[i]) initToZero = true // When upsampling, initialize the Fourier components of the output to zero
        ;
    }
    var x = pool.malloc(ishp), y = pool.malloc(ishp);
    ops.assign(x, inp);
    ops.assigns(y, 0.0);
    fft(1, x, y);
    var lo = x.lo, hi = x.hi;
    var s = pool.malloc(oshp), t = pool.malloc(oshp);
    if (initToZero) {
        ops.assigns(s, 0.0);
        ops.assigns(t, 0.0);
    }
    var nr = new Array(d), a = new Array(d), b = new Array(d), io = new Array(d);
    for(var i = 0; i < 1 << d; ++i){
        for(var j = 0; j < d; ++j){
            if (!(i & 1 << j)) {
                nr[j] = mshp[j] + 1 >>> 1 // Take ceil(mshp[j]/2)) low frequencies (for example [0,1] for both mshp[j]==3 and mshp[j]==4)
                ;
                a[j] = 0;
                b[j] = 0;
                io[j] = 0;
            } else {
                nr[j] = mshp[j] - (mshp[j] + 1 >>> 1) // Take the rest ([-1] for mshp[j]==3, and [-2,-1] for mshp[j]==4)
                ;
                if (nr[j] === 0) {
                    continue;
                }
                a[j] = oshp[j] - nr[j];
                b[j] = ishp[j] - nr[j];
                // If mshp[j] is even, set the first imaginary values (along this dimension) to zero.
                // For example, if mshp[j]==4, 2 and -2 correspond to the same frequency, and should be the average of the amplitudes for 2 and -2.
                // Since the input is real, the Fourier transform has Hermitian symmetry, and we can simply take one or the other and set the corresponding imaginary coefficient(s) to zero.
                // Note that when upsampling, this means that we get a asymmetric response (for example, -2, but not 2 has a non-zero weight), but this does not matter, since the weight is real anyway (again, given Hermitian symmetry).  
                io[j] = mshp[j] & 1 ? 0 : 1;
            }
        }
        ops.assign(hi.apply(lo.apply(s, a), nr), hi.apply(lo.apply(x, b), nr));
        ops.assign(lo.apply(hi.apply(lo.apply(t, a), nr), io), lo.apply(hi.apply(lo.apply(y, b), nr), io));
        ops.assigns(hi.apply(hi.apply(lo.apply(t, a), nr), io), 0.0);
    }
    fft(-1, s, t);
    clampScale(out, s, out.size / inp.size, clamp_lo, clamp_hi);
    pool.free(x);
    pool.free(y);
    pool.free(s);
    pool.free(t);
}
module.exports = resample;
}}),
}]);

//# sourceMappingURL=node_modules_fd14a805._.js.map